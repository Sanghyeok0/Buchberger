import Buchberger.Order
import Mathlib.Data.Finsupp.PWO
import Mathlib.RingTheory.Finiteness.Defs
import Mathlib.RingTheory.MvPolynomial.Ideal
import Mathlib.RingTheory.MvPolynomial.MonomialOrder

variable {σ R : Type*} [CommSemiring R]
variable {k : Type*} [Field k]
variable {m : MonomialOrder σ}

namespace MvPolynomial

variable (R) in
/--
#### Monomial ideal

An ideal `I ⊆ R[x_σ]` is called a **monomial ideal** if it is generated by monomials:
there exists a (possibly infinite) set `A` of exponent vectors such that
`I = ⟨ x^a | a ∈ A ⟩`.
-/
def monomialIdeal (s : Set (σ →₀ ℕ)) : Ideal (MvPolynomial σ R) :=
  Ideal.span ((fun a => monomial a (1 : R)) '' s)

end MvPolynomial

namespace MonomialOrder
open MvPolynomial

variable (m) in
/-- the leading coefficient of a multivariate polynomial with respect
to a monomial ordering -/
noncomputable def leadingTerm (f : MvPolynomial σ R) : MvPolynomial σ R :=
  monomial (m.degree f) (m.leadingCoeff f)

variable (m) in
/-- The set of leading terms of nonzero polynomials in an ideal I. -/
def LT_set (I : Ideal (MvPolynomial σ R)) : Set (MvPolynomial σ R) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

variable (m) in
def LM_set (I : Ideal (MvPolynomial σ R)) : Set (σ →₀ ℕ) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = f }

variable (m) in
def leadingTermIdeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  Ideal.span (LT_set m I)

variable (m) in
/-- The ideal generated by the leading monomials of the nonzero elements of I. -/
def initialIdeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  monomialIdeal R (LM_set m I)

open Set

/--
Theorem (Dickson’s Lemma for exponent vectors).

Assume `σ` is finite. Then `(σ →₀ ℕ)` with the componentwise order has the **Dickson property**:
for every subset `S ⊆ (σ →₀ ℕ)` there exists a finite subset `B ⊆ S` such that
for every `a ∈ S` there exists `b ∈ B` with `b ≤ a`.
-/
theorem Dickson_lemma {σ : Type*} [Fintype σ] :
  HasDicksonProperty (σ →₀ ℕ) := by
  apply HasDicksonProperty_iff_WellQuasiOrderedLE.mpr
  refine (wellQuasiOrderedLE_def (σ →₀ ℕ)).mpr ?_
  -- Given any sequence f : ℕ → σ →₀ ℕ, PWO gives a monotone subsequence
  intro f
  have hPWO : (Set.univ : Set (σ →₀ ℕ)).IsPWO := Finsupp.isPWO (S := Set.univ)
  obtain ⟨g, hg_mono⟩ := @hPWO.exists_monotone_subseq _ _ _ f (fun _ => mem_univ _)
  -- Take the first two indices i := g 0, j := g 1
  let i := g 0
  let j := g 1
  -- Strict‐mono of g turns 0 < 1 into i < j
  have hij : i < j := g.strictMono (Nat.zero_lt_succ 0)
  -- Monotonicity of f ∘ g at 0 ≤ 1 gives f i ≤ f j
  have hle : f i ≤ f j := by
    rw [Monotone] at hg_mono
    refine hg_mono ?_
    exact Nat.zero_le 1
  exact ⟨i, j, hij, hle⟩


variable [Fintype σ] (R) [DecidableEq σ] [DecidableEq R] in
/--
Theorem 5 (Dickson’s Lemma). Let
 I = ⟨ x^α | α ∈ A ⟩ ⊆ k[x₁, …, xₙ]
be a monomial ideal. Then there exists a finite subset s ⊆ A such that
 I = ⟨ x^α | α ∈ s ⟩.
In other words, every monomial ideal has a finite basis.
-/
theorem Dickson_lemma_MV (S : Set (σ →₀ ℕ)) :
  (monomialIdeal R S).FG := by
  rw [monomialIdeal, Ideal.FG]
  obtain ⟨B', hB'fin, ⟨hB'sub, hB'basis⟩⟩ := Dickson_lemma S
  let B := @Set.toFinset (σ →₀ ℕ) B' (by exact hB'fin.fintype)
  use Finset.image (fun x ↦ (monomial x) (1:R) ) B
  have hBsub : SetLike.coe B ⊆ S := by
    rw [Set.coe_toFinset]
    exact hB'sub
  have hBbasis : ∀ a ∈ S, ∃ b ∈ B, b ≤ a := by
    intro a ha
    obtain ⟨b₀, hb₀B', hb₀a⟩ := hB'basis a ha
    use b₀
    constructor
    · simp only [mem_toFinset, B]
      exact hb₀B'
    · exact hb₀a
  simp only [Finset.coe_image]
  apply le_antisymm
  · apply Ideal.span_mono
    refine Set.image_mono ?_
    exact hBsub
  · refine Ideal.span_le.mpr ?_
    rw [Set.subset_def]
    intro d hS
    rw [Set.mem_image] at hS
    obtain ⟨x, hxd⟩ := hS
    have hy : ∃ y ∈ B, ∀ (i : σ), y i ≤ x i := by apply hBbasis x hxd.1
    obtain ⟨y, hyx⟩ := hy
    simp only [SetLike.mem_coe]
    let j : σ → ℕ := fun (i : σ) ↦ (x i - y i)
    refine mem_ideal_span_monomial_image.mpr ?_
    rw [←hxd.2, MvPolynomial.support_monomial]
    by_cases h_triv : (1:R) = 0
    · rw [ite_cond_eq_true]
      simp only [Finset.notMem_empty, Finset.mem_coe, IsEmpty.forall_iff, implies_true]
      exact eq_true h_triv
    · intro xi hxi
      rw [ite_cond_eq_false] at hxi
      simp only [Finset.mem_singleton] at hxi
      rw [hxi]
      use y
      simp only [Finset.mem_coe]
      exact hyx
      exact eq_false h_triv

/--
**Proposition 3 (i) (Cox, Little, O'Shea, Ch 2, §5, Proposition 3)**
⟨LT(I)⟩ is a monomial ideal.
-/
lemma leadingTermIdeal_is_initialIdeal (I : Ideal (MvPolynomial σ k)) :
    leadingTermIdeal m I = initialIdeal m I := by
  apply le_antisymm
  · -- Show span(LT) ⊆ span(LM)
    rw [initialIdeal, leadingTermIdeal, Ideal.span_le]
    unfold LT_set LM_set
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_LT_eq⟩
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 := MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lt : leadingTerm m g = (MvPolynomial.C (m.leadingCoeff g)) * (monomial (m.degree g) (1 : k)) := by
      simp only [leadingTerm, C_mul_monomial, mul_one]
    rw [h_lt] at h_LT_eq
    rw [←h_LT_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq] -- , Set.mem_setOf_eq, one_ne_zero, not_false_eq_true, monomial_left_inj
    apply Ideal.subset_span
    simp only [Set.mem_image, Set.mem_setOf_eq, ne_eq, one_ne_zero, not_false_eq_true,
      monomial_left_inj, exists_eq_right]
    use g
  · -- Show span(LM) ⊆ span(LT)
    rw [initialIdeal, monomialIdeal, leadingTermIdeal, Ideal.span_le]
    unfold LT_set LM_set
    simp only [Set.image_subset_iff]
    intro lmg hlmg_in
    rcases hlmg_in with ⟨g, hg_mem⟩
    rcases hg_mem with ⟨hg_mem_I, ⟨hg_ne_zero, h_lm_eq⟩⟩
    simp only [Set.mem_preimage, SetLike.mem_coe]
    have : (monomial lmg) 1 = C (m.leadingCoeff g)⁻¹ * (leadingTerm m g) := by
      rw [←h_lm_eq, leadingTerm]
      rw [C_mul', smul_monomial]
      rw [smul_eq_mul]
      have hlc_ne_zero : m.leadingCoeff g ≠ 0 := MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
      rw [inv_mul_cancel₀ hlc_ne_zero]
    rw [this]
    apply Ideal.mul_mem_left
    apply Ideal.subset_span (by use g)

variable [Fintype σ] [DecidableEq σ] [DecidableEq k] in
/-- **Proposition 3 (ii) (Cox, Little, O'Shea, Ch 2, §5, Proposition 3)**.
Initial Ideal is finitely generated.-/
theorem initialIdeal_is_FG (I : Ideal (MvPolynomial σ k)) : (initialIdeal m I).FG := by
  -- 1. Show initialIdeal m I is spanned by monomials with coefficient 1
  rw [Ideal.FG]
  rw [initialIdeal]
  have h_fg : (monomialIdeal k (LM_set m I)).FG := Dickson_lemma_MV k (LM_set m I)
  obtain ⟨b, h_span⟩ := h_fg
  use b

end MonomialOrder
