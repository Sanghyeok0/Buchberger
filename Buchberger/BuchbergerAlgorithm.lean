import Buchberger.GroebnerBases

/-!
# The Buchberger Algorithm

This file contains the formalization of the Buchberger algorithm, which computes a
Gröbner basis for any ideal in a polynomial ring over a field.

The algorithm is proven correct in two distinct styles:
1.  **Explicit Recursion (`Buchberger_Step`, `Buchberger_Alg`):** An explicit recursive
    function is defined, and its termination and correctness are proven using helper
    lemmas about its properties (invariants).
2.  **Well-Founded Recursion (`Buchberger_Alg_wf`):** A more abstract approach using
    `WellFounded.fix`, which is a common and powerful pattern in `mathlib`. This
    separates the one-step logic of the algorithm from the recursion mechanism itself.

Termination for both proofs is guaranteed by Hilbert's Basis Theorem, which ensures
that the strictly increasing chain of initial ideals generated at each step must
eventually stabilize.

## Main Definitions
- `MvPolynomial.NonZero_Rem_Spoly`: A helper function that computes the set of S-polynomials
  which do not reduce to zero with respect to the current basis.
- `MvPolynomial.Buchberger_Step`: A recursive function implementing one step of the
  explicit version of the Buchberger algorithm.

## Main Results
- `MvPolynomial.lt_ideal_span_of_rem_spoly_nonempty`: The key lemma for the termination proof,
  showing that adding non-zero remainders strictly increases the initial ideal.
- `MvPolynomial.Buchberger_Alg`: The main theorem (first version), proving that the
  explicit recursive algorithm terminates and returns a valid Gröbner basis.
- `MvPolynomial.Buchberger_Alg_wf`: The main theorem (second version), proving the same
  result using well-founded recursion.
-/

variable {σ : Type*}
variable {m : MonomialOrder σ}

section Field

variable {k : Type*} [Field k] [DecidableEq k]

instance Field.isNoetherianRing :
    IsNoetherianRing k := by
  refine isNoetherian_iff'.mpr ?_
  exact Finite.to_wellFoundedGT

namespace MvPolynomial

set_option maxHeartbeats 0

open MonomialOrder MvPolynomial Finset

variable [Fintype σ] in
def reduces_to_zero (G : Finset (MvPolynomial σ k)) (f : MvPolynomial σ k) : Prop :=
∃ (A : MvPolynomial σ k → MvPolynomial σ k),
  (f = ∑ g ∈ G, (A g) * g) ∧ ∀ g ∈ G, (A g) * g ≠ 0 → m.degree ((A g) * g) ≼[m] m.degree f


omit [DecidableEq k] in
lemma normalForm_not_divisible_by_basis
  (G : Finset (MvPolynomial σ k)) (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k)
  (d : σ →₀ ℕ) (hd_in_support : d ∈ (normalForm m hG p).support) :
  ∀ b ∈ G, ¬ (m.degree b ≤ d) := by
  have h_remainder_prop := (normalForm_spec m hG p).2.2

  specialize h_remainder_prop d hd_in_support

  intro b hb_in_G
  specialize h_remainder_prop b hb_in_G
  exact h_remainder_prop


variable [DecidableEq σ] in
lemma leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
  (G : Finset (MvPolynomial σ k))
  (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k)
  (h_rem_ne_zero : normalForm m hG p ≠ 0) :
  m.leadingTerm (normalForm m hG p) ∉ Ideal.span ((fun g => m.leadingTerm g) '' G.toSet) := by
  classical
  -- Let r be the remainder
  set r := normalForm m hG p
  -- Prove by contradiction
  intro hLT_r_in_span

  -- `span(LT(G))` is contained in the monomial ideal generated by `{LM(g) | g ∈ G}`
  have h_span_le :
      Ideal.span ((fun g => m.leadingTerm g) '' G.toSet)
        ≤ monomialIdeal k ((G.image m.degree).toSet) := by
    refine Ideal.span_le.mpr ?_
    intro t ht
    rcases ht with ⟨g, hgG, rfl⟩
    -- First, the generator `monomial (LM g) 1` is in that monomial ideal
    have hLMg :
        monomial (m.degree g) (1 : k)
          ∈ monomialIdeal k ((G.image m.degree).toSet) := by
      -- Show `m.degree g ∈ (G.image m.degree).toSet`
      have hgG' : g ∈ G := by simpa [Finset.mem_coe] using hgG
      have hα : m.degree g ∈ ((G.image m.degree).toSet) := by
        -- switch to finset membership and back to set
        simpa [Finset.mem_coe] using (Finset.mem_image.mpr ⟨g, hgG', rfl⟩)
      exact (mem_monomialIdeal_iff_divisible.mpr ⟨m.degree g, hα, le_rfl⟩)
    -- `LT g = C (lc g) * monomial (LM g) 1`, so it's in the ideal
    --simpa [leadingTerm, C_mul_monomial] using Ideal.mul_mem_left _ _ hLMg
    simp only [ SetLike.mem_coe]
    unfold leadingTerm
    have : (monomial (m.degree g)) (m.leadingCoeff g) = C (m.leadingCoeff g) * (monomial (m.degree g) (1 : k)) := by rw [C_mul_monomial, mul_one]
    rw [this]
    exact Ideal.mul_mem_left _ _ hLMg

  -- Transport `LT r` into that monomial ideal
  have hLT_r_in_mono :
      m.leadingTerm r ∈ monomialIdeal k ((G.image m.degree).toSet) :=
    h_span_le hLT_r_in_span

  -- Normalize to `LM r` inside the same monomial ideal
  set lc_r := m.leadingCoeff r
  have hlc_ne_zero : lc_r ≠ 0 := m.leadingCoeff_ne_zero_iff.mpr h_rem_ne_zero
  have hLM_r_in_mono :
      monomial (m.degree r) (1 : k)
        ∈ monomialIdeal k ((G.image m.degree).toSet) := by
    have : monomial (m.degree r) (1 : k) = C (lc_r⁻¹) * m.leadingTerm r := by
      simp only [leadingTerm, C_mul_monomial]
      dsimp only [lc_r]
      rw [inv_mul_cancel₀ hlc_ne_zero]
    simpa [this] using Ideal.mul_mem_left _ _ hLT_r_in_mono


  -- Divisibility in the monomial ideal ⇒ some `m.degree g ≤ m.degree r` with `g ∈ G`
  rcases (mem_monomialIdeal_iff_divisible.mp hLM_r_in_mono)
    with ⟨α, hα_in, hα_le⟩
  simp only [coe_image, Set.mem_image, mem_coe] at hα_in
  rcases hα_in with ⟨g, hgG, rfl⟩

  -- Remainder property forbids any `LM g` (with `g ∈ G`) from dividing `LM r`
  have h_remainder_prop := (normalForm_spec m hG p).2.2
  have h_deg_in_support : m.degree r ∈ r.support :=
    MonomialOrder.degree_mem_support h_rem_ne_zero
  specialize h_remainder_prop (m.degree r) h_deg_in_support
  have forbid : ∀ b ∈ G, ¬ m.degree b ≤ m.degree r :=
    fun b hb => h_remainder_prop b hb

  exact (forbid g hgG) hα_le

variable (m) [DecidableEq σ] in
noncomputable def NonZero_Rem_Spoly (G : Finset (MvPolynomial σ k))
  (hG : ∀ g ∈ G, g ≠ 0) : Finset (MvPolynomial σ k) :=
  (G.offDiag.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

variable (m) [DecidableEq σ] in
lemma lt_ideal_span_of_rem_spoly_nonempty {G : Finset (MvPolynomial σ k)}
    (hG : ∀ g ∈ G, g ≠ 0) (h_nonempty : NonZero_Rem_Spoly m G hG ≠ ∅) :
    Ideal.span ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))) <
    Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ NonZero_Rem_Spoly m G hG) : Set (MvPolynomial σ k))) := by
  apply lt_of_le_of_ne
  · -- 1) Monotonicity: ⟨LT(G)⟩ ≤ ⟨LT(G ∪ R)⟩.
    rw [←Finset.coe_union]
    apply Ideal.span_mono
    refine Set.image_mono ?_
    simp only [Finset.coe_union, Set.subset_union_left]
  · -- 2) Strictness: ⟨LT(G)⟩ ≠ ⟨LT(G ∪ R)⟩.
    intro h_ideals_eq
    obtain ⟨r, hrR⟩ : ∃ r, r ∈ (NonZero_Rem_Spoly m G hG) := by
      exact Finset.nonempty_iff_ne_empty.mpr h_nonempty
    have hlt_r_notin :
      m.leadingTerm r ∉ Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) := by
        unfold NonZero_Rem_Spoly at hrR
        simp only [Finset.mem_filter, Finset.mem_image, Finset.mem_offDiag] at hrR
        obtain ⟨pq, -, hr_eq_normalForm⟩ := hrR.1
        rw [←hr_eq_normalForm]
        apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
        rw [hr_eq_normalForm]
        exact hrR.2
    have h_lt_r_in_old_ideal : m.leadingTerm r ∈ Ideal.span ((fun g ↦ m.leadingTerm g) '' ↑G) := by
      rw [h_ideals_eq]
      simp only [←coe_union]
      apply Ideal.subset_span
      simp only [Set.mem_image]
      use r
      exact ⟨mem_union_right G hrR, rfl⟩
    exact hlt_r_notin h_lt_r_in_old_ideal

variable (m) [DecidableEq σ] in
noncomputable def Buchberger_Step
  {G : Finset (MvPolynomial σ k)}
  (hG : ∀ g ∈ G, g ≠ 0) [Finite σ]
  : Finset (MvPolynomial σ k) :=
  if h_Rem_empty : NonZero_Rem_Spoly m G hG = ∅ then
    G
  else
    have hG' : ∀ g ∈ G ∪ (NonZero_Rem_Spoly m G hG), g ≠ 0 := by
      intro g hG_mem
      rcases Finset.mem_union.mp hG_mem with hgG | hgR
      · exact hG g hgG
      · unfold NonZero_Rem_Spoly at hgR; simp only [mem_filter] at hgR; exact hgR.2
    Buchberger_Step hG'
  termination_by
  WellFounded.wrap
    (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
    (Ideal.span ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))))
  decreasing_by
    rw [Finset.coe_union]
    apply lt_ideal_span_of_rem_spoly_nonempty m hG h_Rem_empty

variable (m) [DecidableEq σ] [Finite σ] in
lemma Buchberger_Step_property (G : Finset (MvPolynomial σ k))
  (hG : ∀ g ∈ G, g ≠ 0) :
  G ⊆ Buchberger_Step m hG ∧
  ∀ g ∈ Buchberger_Step m hG, g ≠ 0 := by
    unfold Buchberger_Step
    by_cases h_Rem_empty : NonZero_Rem_Spoly m G hG = ∅

    · -- Base Case: The recursion terminates. The function returns G.
      rw [dif_pos h_Rem_empty]
      constructor
      · exact Finset.Subset.refl G
      · exact hG

    · -- Inductive Step: The function makes a recursive call.
      rw [dif_neg h_Rem_empty]

      let G' := G ∪ NonZero_Rem_Spoly m G hG
      have hG' : ∀ g ∈ G', g ≠ 0 := by
        intro g hg_mem; rcases Finset.mem_union.mp hg_mem with (hgG | hgR)
        · exact hG g hgG
        · unfold NonZero_Rem_Spoly at hgR; simp at hgR; exact hgR.2

      dsimp only [Lean.Elab.WF.paramLet]
      have ih := Buchberger_Step_property G' hG'

      constructor
      · -- First goal: G ⊆ Buchberger_Step m hG'
        trans G' -- Use G' as the intermediate set for transitivity
        · -- Subgoal 1: G ⊆ G'
          exact subset_union_left
        · -- Subgoal 2: G' ⊆ Buchberger_Step m hG'
          exact ih.1
      · -- Second goal: ∀ g ∈ Buchberger_Step m hG', g ≠ 0
        exact ih.2

termination_by
  WellFounded.wrap
  (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
  (Ideal.span ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))))
decreasing_by
  simp only [coe_union, gt_iff_lt, Subtype.coe_lt_coe]
  apply lt_ideal_span_of_rem_spoly_nonempty m hG h_Rem_empty




variable (m) [DecidableEq σ] [Finite σ] in
lemma Buchberger_Step_span_property {G : Finset (MvPolynomial σ k)}
  (hG : ∀ g ∈ G, g ≠ 0)
  {I : Ideal (MvPolynomial σ k)}
  (hspan : I = Ideal.span G)
  :
  I = Ideal.span (Buchberger_Step m hG) := by
    unfold Buchberger_Step
    by_cases h_Rem_empty : NonZero_Rem_Spoly m G hG = ∅

    · -- Base Case: The recursion terminates. The function returns G.
      rw [dif_pos h_Rem_empty]
      exact hspan

    · -- Inductive Step: The function makes a recursive call.
      rw [dif_neg h_Rem_empty]

      let G' := G ∪ NonZero_Rem_Spoly m G hG
      have hG' : ∀ g ∈ G', g ≠ 0 := by
        intro g hg_mem; rcases Finset.mem_union.mp hg_mem with (hgG | hgR)
        · exact hG g hgG
        · unfold NonZero_Rem_Spoly at hgR; simp at hgR; exact hgR.2

      have hspan' : I = Ideal.span G' := by
        unfold G'
        rw [hspan]
        apply le_antisymm
        · -- `Ideal.span G ⊆ Ideal.span (G ∪ R)` is trivial.
          apply Ideal.span_mono
          simp only [coe_union, Set.subset_union_left]
        · -- For `Ideal.span (G ∪ R) ⊆ Ideal.span G`, we show all generators are in `Ideal.span G`.
          rw [Ideal.span_le]
          simp only [coe_union, Set.union_subset_iff]
          constructor
          · exact Ideal.subset_span
          · unfold NonZero_Rem_Spoly
            simp only [coe_filter, mem_image, mem_offDiag]
            rw [Set.subset_def]
            intro r hr_in_Rem
            obtain ⟨⟨pq, hpq_in_offDiag, hr_eq_normalForm⟩, hr_ne_zero⟩ := hr_in_Rem
            rw [← hr_eq_normalForm]
            let S := S_polynomial m pq.1 pq.2
            have h_spec := normalForm_spec m hG S
            let q := quotients m hG S
            let q_sum := q.sum (fun g (h : MvPolynomial σ k) => h * g.val)
            have h_r_eq_sub : r = S - q_sum := by
              have : S = q_sum + r := by
                rw [h_spec.1]
                unfold q_sum q quotients
                congr
              exact eq_sub_of_add_eq' (id (Eq.symm this))
            rw [hr_eq_normalForm, h_r_eq_sub]
            apply Ideal.sub_mem
            · -- First goal: `S ∈ Ideal.span ↑G`.
              let I_G := @Ideal.span (MvPolynomial σ k) _ G
              have hp_in_I : pq.1 ∈ I_G := Ideal.subset_span (hpq_in_offDiag.1)
              have hq_in_I : pq.2 ∈ I_G := Ideal.subset_span (hpq_in_offDiag.2.1)
              exact Ideal.sub_mem _ (Ideal.mul_mem_left _ _ hp_in_I) (Ideal.mul_mem_left _ _ hq_in_I)

            · -- Second goal: `q_sum ∈ Ideal.span ↑G`.
              unfold q_sum
              rw [Finsupp.sum]
              apply sum_mem
              intro g_sub _
              apply Ideal.mul_mem_left
              apply Ideal.subset_span
              exact g_sub.property

      have ih := Buchberger_Step_span_property hG' hspan'
      exact ih

termination_by
  WellFounded.wrap
  (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
  (Ideal.span ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))))
decreasing_by
  simp only [coe_union, gt_iff_lt, Subtype.coe_lt_coe]
  apply lt_ideal_span_of_rem_spoly_nonempty m hG h_Rem_empty


variable (m) [DecidableEq σ] [Finite σ] in
lemma NonZero_Rem_Spoly_of_Buchberger_Step_is_empty {G : Finset (MvPolynomial σ k)}
  (hG : ∀ g ∈ G, g ≠ 0) :
  NonZero_Rem_Spoly m (Buchberger_Step m hG) (Buchberger_Step_property m G hG).2 = ∅ := by
  unfold Buchberger_Step
  by_cases h_Rem_empty : NonZero_Rem_Spoly m G hG = ∅
  · simp [dif_pos h_Rem_empty]
    exact h_Rem_empty
  · simp [dif_neg h_Rem_empty]
    let G' := G ∪ NonZero_Rem_Spoly m G hG
    have hG' : ∀ g ∈ G', g ≠ 0 := by
      intro g hg_mem; rcases Finset.mem_union.mp hg_mem with (hgG | hgR)
      · exact hG g hgG
      · unfold NonZero_Rem_Spoly at hgR; simp at hgR; exact hgR.2
    have ih := NonZero_Rem_Spoly_of_Buchberger_Step_is_empty hG'
    exact ih

termination_by
  WellFounded.wrap
  (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
  (Ideal.span ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))))
decreasing_by
  simp only [coe_union, gt_iff_lt, Subtype.coe_lt_coe]
  apply lt_ideal_span_of_rem_spoly_nonempty m hG h_Rem_empty


variable (m) [DecidableEq σ] in
theorem Buchberger_Alg [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  {I : Ideal (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0)
  (hspan : I = Ideal.span F) :
  F ⊆ Buchberger_Step m hF ∧
  IsGroebnerBasis m I (Buchberger_Step m hF) := by
  constructor
  · -- F ⊆ Buchberger_Step m hF
    exact (Buchberger_Step_property m F hF).1
  · let G := Buchberger_Step m hF
    have hG := (Buchberger_Step_property m F hF).2
    have hspan' : I = Ideal.span G := Buchberger_Step_span_property m hF hspan

    apply (Buchberger_criterion m hG hspan').mpr
    intro g₁ g₂ hg₁ hg₂ hneq
    let r := normalForm m hG (S_polynomial m g₁ g₂)
    by_contra hr_nonzero
    have hr_in : r ∈ NonZero_Rem_Spoly m G hG := by
      unfold NonZero_Rem_Spoly
      simp only [mem_filter, mem_image]
      refine ⟨?_, hr_nonzero⟩
      use ⟨g₁, g₂⟩
      simp only [mem_offDiag]
      exact ⟨⟨hg₁, ⟨hg₂, hneq⟩⟩, rfl⟩

    have Rem_fix_empty : NonZero_Rem_Spoly m G hG = ∅ :=
      NonZero_Rem_Spoly_of_Buchberger_Step_is_empty m hF

    rw [Rem_fix_empty] at hr_in
    exact Finset.notMem_empty r hr_in


variable (m) [DecidableEq σ] in
theorem Buchberger_Alg_wf [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  {I : Ideal (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0)
  (hspan : I = Ideal.span F) :
  ∃ G : Finset (MvPolynomial σ k),
  F ⊆ G ∧
  IsGroebnerBasis m I G := by
  -- 1. State packages the set with the invariant "all entries nonzero".
  let State := { G : Finset (MvPolynomial σ k) // ∀ g ∈ G, g ≠ 0 }

  -- 2. Measure and well-founded relation (OrderDual so that < is well-founded).
  let H (s : State) := OrderDual.toDual (@Ideal.span (MvPolynomial σ k) _ (s.val.image (leadingTerm m)))
  let R (s₁ s₂ : State) : Prop := H s₁ < H s₂
    -- i.e. R s₁ s₂ := Ideal.span (s₁.val.image (leadingTerm m)) > @Ideal.span (MvPolynomial σ k) _ (s₂.val.image (leadingTerm m))
  have h_wf : WellFounded R := InvImage.wf H
    (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))

  ------------------------------------------------------------------------------------------------------------------
    -- the "new" S-polys at a state
  let NonZero_Rem_Spoly_wf (s : {G : Finset (MvPolynomial σ k) // ∀ g ∈ G, g ≠ 0}) : Finset (MvPolynomial σ k) :=
    (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

  -- extend a state by adjoining new S-polys
  let extend (s : {G // ∀ g ∈ G, g ≠ (0 : (MvPolynomial σ k))}) : {G // ∀ g ∈ G, g ≠ (0 : (MvPolynomial σ k))} :=
    ⟨s.val ∪ NonZero_Rem_Spoly_wf s, by
      intro g hg
      rcases Finset.mem_union.mp hg with hgs | hgR
      · exact s.property g hgs
      · unfold NonZero_Rem_Spoly_wf at hgR; simp only [mem_filter] at hgR; exact hgR.2⟩

  have extend_decreases (s : {G // ∀ g ∈ G, g ≠ 0}) (h_nonempty : NonZero_Rem_Spoly_wf s ≠ ∅) :
    R (extend s) s := by
    unfold R H
    dsimp only [OrderDual.toDual]
    apply lt_of_le_of_ne
    · apply Ideal.span_mono
      simp only [coe_image]
      refine Set.image_subset m.leadingTerm ?_
      unfold extend
      rw [coe_union]
      exact Set.subset_union_left
    · intro h_eq
      obtain ⟨r, hr⟩ := Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_nonempty)
      have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' s.val) := by
        unfold NonZero_Rem_Spoly_wf at hr
        simp only [mem_filter, mem_image, mem_offDiag] at hr
        obtain ⟨⟨pq, hpq⟩, hr_nezero⟩ := hr
        rw [←hpq.2]
        apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
        rw [hpq.2]
        exact hr_nezero
      have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' s.val) := by
        simp only [coe_image, EmbeddingLike.apply_eq_iff_eq] at h_eq
        rw [←h_eq]
        apply Ideal.subset_span
        simp only [Set.mem_image, mem_coe]
        use r
        exact ⟨Finset.mem_union_right _ hr, rfl⟩
      exact hLT_r_notin hLT_r_in

  ------------------------------------------------------------------------------------------------------------------
  -- 3. One-step function: uses s.property as hG for normalForm.
  let buchberger_step_fn (G_sub : State) (rec_call : ∀ (G'_sub : State), R G'_sub G_sub → State) : State :=

    let G := G_sub.val
    let hG := G_sub.property

    if h_Rem_empty : NonZero_Rem_Spoly_wf G_sub = ∅ then
      G_sub
    else
      -- prove strict decrease of the measure when NonZero_Rem_Spoly_wf G ≠ ∅
      have h_decreasing := extend_decreases G_sub h_Rem_empty

      rec_call (extend G_sub) h_decreasing

  -- initial state: filter out zeroes (but hF guarantees none)
  let F₀_sub : State := ⟨F.filter (· ≠ 0), fun g hg => (Finset.mem_filter.mp hg).2⟩
  have hF_eq_F₀ : F = F₀_sub.val := Eq.symm (filter_true_of_mem hF)

  -- the fixpoint state and the resulting G
  let G_sub := @WellFounded.fix State (fun _ => State) R h_wf buchberger_step_fn F₀_sub
  let G := G_sub.val
  use G

  ----------------------------------------------------------------
  -- 1) F ⊆ G  (monotonicity of the recursion)
  ----------------------------------------------------------------
  have h_F_sub_G : F ⊆ G := by
    rw [hF_eq_F₀]
    unfold G G_sub
    apply h_wf.induction
      (C := fun s => s.val ⊆ (h_wf.fix buchberger_step_fn s).val)
      F₀_sub
    intro s IH
    let hG := s.property

    rw [WellFounded.fix_eq]
    unfold buchberger_step_fn
    by_cases h_Rem_empty : NonZero_Rem_Spoly_wf s = ∅
    · rw [dif_pos h_Rem_empty]
    · rw [dif_neg h_Rem_empty]
      have h_s_sub_union : s.val ⊆ s.val ∪ NonZero_Rem_Spoly_wf s := subset_union_left
      have : ∀ g ∈ ↑s ∪ NonZero_Rem_Spoly_wf s, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
          | inl hg_in_G => exact hG g hg_in_G
          | inr hg_in_Rem => unfold NonZero_Rem_Spoly_wf at hg_in_Rem; rw [mem_filter] at hg_in_Rem; exact hg_in_Rem.2
      have h_decreasing := extend_decreases s h_Rem_empty
      specialize IH (extend s) h_decreasing
      exact Finset.Subset.trans h_s_sub_union IH

  ----------------------------------------------------------------
  -- 2) G is zero-free (invariant)
  ----------------------------------------------------------------
  have hG_nonzero : ∀ g ∈ G, g ≠ 0 := by
    -- property is carried in the State, so just use G_sub.property
    exact G_sub.property

  ----------------------------------------------------------------
  -- 3) span equality: I = span G
  ----------------------------------------------------------------
  have h_I_eq_span_G : I = Ideal.span G := by
    rw [hspan, hF_eq_F₀]
    apply h_wf.induction
      (C := fun s => Ideal.span s.val = @Ideal.span (MvPolynomial σ k) _ (WellFounded.fix h_wf buchberger_step_fn s).val)
      F₀_sub
    intro s ih
    let hG := s.property
    rw [WellFounded.fix_eq]
    dsimp only [Lean.Elab.WF.paramLet, dite_eq_ite, buchberger_step_fn]
    by_cases h_Rem_empty : NonZero_Rem_Spoly_wf s = ∅
    · rw [if_pos h_Rem_empty]
    · rw [if_neg h_Rem_empty]
      have : ∀ g ∈ ↑s ∪ NonZero_Rem_Spoly_wf s, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
          | inl hg_in_G => exact hG g hg_in_G
          | inr hg_in_Rem => unfold NonZero_Rem_Spoly_wf at hg_in_Rem; rw [mem_filter] at hg_in_Rem; exact hg_in_Rem.2
      let s' : State := ⟨s.val ∪ NonZero_Rem_Spoly_wf s, this⟩
      have h_decreasing := extend_decreases s h_Rem_empty

      rw [← ih (extend s) h_decreasing]
      apply le_antisymm
      · apply Ideal.span_mono
        unfold extend
        simp only [coe_union, Set.subset_union_left]
      · rw [Ideal.span_le]
        unfold extend
        simp only [coe_union, Set.union_subset_iff]
        constructor
        · exact Ideal.subset_span
        · unfold NonZero_Rem_Spoly_wf
          simp only [coe_filter, mem_image, mem_offDiag]
          rw [Set.subset_def]
          intro r hr_in_Rem
          obtain ⟨⟨pq, hpq_in_offDiag, hr_eq_normalForm⟩, hr_ne_zero⟩ := hr_in_Rem
          rw [← hr_eq_normalForm]

          let S := S_polynomial m pq.1 pq.2
          have h_spec := normalForm_spec m s.property S
          let q := quotients m s.property S
          let q_sum := q.sum (fun (g : ↥s.val) (h : MvPolynomial σ k) => h * g.val)

          have h_r_eq_sub : r = S - q_sum := by
            have : S = q_sum + r := by
              rw [h_spec.1]
              unfold q_sum q quotients
              congr
            exact eq_sub_of_add_eq' (id (Eq.symm this))
          rw [hr_eq_normalForm, h_r_eq_sub]
          apply Ideal.sub_mem
          · -- First goal: `S ∈ Ideal.span s.val`.
            unfold S S_polynomial
            let I_s := Ideal.span (s.val : Set (MvPolynomial σ k))
            have hp_in_I : pq.1 ∈ I_s := Ideal.subset_span (hpq_in_offDiag.1)
            have hq_in_I : pq.2 ∈ I_s := Ideal.subset_span (hpq_in_offDiag.2.1)
            exact Ideal.sub_mem _ (Ideal.mul_mem_left _ _ hp_in_I) (Ideal.mul_mem_left _ _ hq_in_I)

          · -- Second goal: `q_sum ∈ Ideal.span s.val`.
            unfold q_sum
            rw [Finsupp.sum]
            apply sum_mem
            intro g_sub _
            -- `g_sub` is `⟨g, hg_in_s⟩` of type `↥s.val`.
            -- The term is `(q g_sub) * g_sub.val`.
            apply Ideal.mul_mem_left
            apply Ideal.subset_span
            exact g_sub.property

  ----------------------------------------------------------------
  -- 4) Use Buchberger criterion: show all S-polynomials reduce to 0.
  ----------------------------------------------------------------
  have Rem_fix_empty : NonZero_Rem_Spoly_wf (h_wf.fix buchberger_step_fn F₀_sub) = ∅ := by
    -- Do induction on arbitrary starting state s, specialize at F₀_sub
    apply h_wf.induction (C := fun s => NonZero_Rem_Spoly_wf (h_wf.fix buchberger_step_fn s) = ∅) F₀_sub
    intro s ih
    have hfix := WellFounded.fix_eq h_wf buchberger_step_fn s

    by_cases h_Rem_empty : NonZero_Rem_Spoly_wf s = ∅
    · -- stable case: fix s = s, so NonZero_Rem_Spoly_wf (fix s) = NonZero_Rem_Spoly_wf s = ∅
      have : (h_wf.fix buchberger_step_fn s) = s := by
        rw [WellFounded.fix_eq]
        dsimp only [Lean.Elab.WF.paramLet, dite_eq_ite, buchberger_step_fn]
        rw [if_pos h_Rem_empty]
      simp only [NonZero_Rem_Spoly_wf, this, h_Rem_empty]
    · -- recursive case: s ∪ NonZero_Rem_Spoly_wf s and use IH
      have h_all_nonzero : ∀ g ∈ s.val ∪ NonZero_Rem_Spoly_wf s, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
        | inl hg_in_s => exact s.property g hg_in_s
        | inr hg_in_Rem => unfold NonZero_Rem_Spoly_wf at hg_in_Rem; rw [mem_filter] at hg_in_Rem; exact hg_in_Rem.2
      -- prove strict decrease
      have h_decreasing := extend_decreases s h_Rem_empty

      have hfix : h_wf.fix buchberger_step_fn s =
              h_wf.fix buchberger_step_fn (extend s) := by
        rw [WellFounded.fix_eq]
        dsimp only [Lean.Elab.WF.paramLet, dite_eq_ite, buchberger_step_fn]
        rw [if_neg h_Rem_empty]
      -- finish using IH at (extend s)
      simpa [hfix] using ih (extend s) h_decreasing

  -- finish Buchberger criterion
  have h_G_is_GB : IsGroebnerBasis m I G := by
    apply (Buchberger_criterion m hG_nonzero h_I_eq_span_G).mpr
    intro p q hp hq h_ne
    let r := normalForm m hG_nonzero (S_polynomial m p q)
    by_contra hr_nonzero
    -- r would be in NonZero_Rem_Spoly_wf of final state
    have hr_in : r ∈ NonZero_Rem_Spoly_wf G_sub := by
      dsimp only [NonZero_Rem_Spoly_wf]
      simp only [mem_filter, mem_image, mem_offDiag]
      refine ⟨⟨(p, q), ?_, rfl⟩, ?_⟩
      · -- show (p, q) ∈ offDiag
        simpa only [mem_offDiag] using ⟨hp, hq, h_ne⟩
      · -- show r ≠ 0
        exact hr_nonzero

    rw [Rem_fix_empty] at hr_in
    exact Finset.notMem_empty r hr_in

  exact ⟨h_F_sub_G, h_G_is_GB⟩
