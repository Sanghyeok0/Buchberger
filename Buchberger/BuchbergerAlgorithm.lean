import Buchberger.GroebnerBases



variable {σ : Type*}
variable {m : MonomialOrder σ}

section Field

variable {k : Type*} [Field k] [DecidableEq k]

instance Field.isNoetherianRing :
    IsNoetherianRing k := by
  refine isNoetherian_iff'.mpr ?_
  exact Finite.to_wellFoundedGT

namespace MvPolynomial

set_option maxHeartbeats 0

open MonomialOrder MvPolynomial Finset

variable [Fintype σ] in
def reduces_to_zero (G : Finset (MvPolynomial σ k)) (f : MvPolynomial σ k) : Prop :=
∃ (A : MvPolynomial σ k → MvPolynomial σ k),
  (f = ∑ g ∈ G, (A g) * g) ∧ ∀ g ∈ G, (A g) * g ≠ 0 → m.degree ((A g) * g) ≼[m] m.degree f


omit [DecidableEq k] in
lemma normalForm_not_divisible_by_basis
  (G : Finset (MvPolynomial σ k)) (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k)
  (d : σ →₀ ℕ) (hd_in_support : d ∈ (normalForm m hG p).support) :
  ∀ b ∈ G, ¬ (m.degree b ≤ d) := by
  have h_remainder_prop := (normalForm_spec' m hG p).2.2

  specialize h_remainder_prop d hd_in_support

  intro b hb_in_G
  specialize h_remainder_prop b hb_in_G
  exact h_remainder_prop


variable [DecidableEq σ] in
lemma leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
  (G : Finset (MvPolynomial σ k))
  (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k)
  (h_rem_ne_zero : normalForm m hG p ≠ 0) :
  m.leadingTerm (normalForm m hG p) ∉ Ideal.span ((fun g => m.leadingTerm g) '' G.toSet) := by
  classical
  -- Let r be the remainder
  set r := normalForm m hG p
  -- Prove by contradiction
  intro hLT_r_in_span

  -- `span(LT(G))` is contained in the monomial ideal generated by `{LM(g) | g ∈ G}`
  have h_span_le :
      Ideal.span ((fun g => m.leadingTerm g) '' G.toSet)
        ≤ monomialIdeal k ((G.image m.degree).toSet) := by
    refine Ideal.span_le.mpr ?_
    intro t ht
    rcases ht with ⟨g, hgG, rfl⟩
    -- First, the generator `monomial (LM g) 1` is in that monomial ideal
    have hLMg :
        monomial (m.degree g) (1 : k)
          ∈ monomialIdeal k ((G.image m.degree).toSet) := by
      -- Show `m.degree g ∈ (G.image m.degree).toSet`
      have hgG' : g ∈ G := by simpa [Finset.mem_coe] using hgG
      have hα : m.degree g ∈ ((G.image m.degree).toSet) := by
        -- switch to finset membership and back to set
        simpa [Finset.mem_coe] using (Finset.mem_image.mpr ⟨g, hgG', rfl⟩)
      exact (mem_monomialIdeal_iff_divisible.mpr ⟨m.degree g, hα, le_rfl⟩)
    -- `LT g = C (lc g) * monomial (LM g) 1`, so it's in the ideal
    --simpa [leadingTerm, C_mul_monomial] using Ideal.mul_mem_left _ _ hLMg
    simp only [ SetLike.mem_coe]
    unfold leadingTerm
    have : (monomial (m.degree g)) (m.leadingCoeff g) = C (m.leadingCoeff g) * (monomial (m.degree g) (1 : k)) := by rw [C_mul_monomial, mul_one]
    rw [this]
    exact Ideal.mul_mem_left _ _ hLMg

  -- Transport `LT r` into that monomial ideal
  have hLT_r_in_mono :
      m.leadingTerm r ∈ monomialIdeal k ((G.image m.degree).toSet) :=
    h_span_le hLT_r_in_span

  -- Normalize to `LM r` inside the same monomial ideal
  set lc_r := m.leadingCoeff r
  have hlc_ne_zero : lc_r ≠ 0 := m.leadingCoeff_ne_zero_iff.mpr h_rem_ne_zero
  have hLM_r_in_mono :
      monomial (m.degree r) (1 : k)
        ∈ monomialIdeal k ((G.image m.degree).toSet) := by
    have : monomial (m.degree r) (1 : k) = C (lc_r⁻¹) * m.leadingTerm r := by
      simp [leadingTerm, C_mul_monomial]
      dsimp [lc_r]
      rw [inv_mul_cancel₀ hlc_ne_zero]
    simpa [this] using Ideal.mul_mem_left _ _ hLT_r_in_mono


  -- Divisibility in the monomial ideal ⇒ some `m.degree g ≤ m.degree r` with `g ∈ G`
  rcases (mem_monomialIdeal_iff_divisible.mp hLM_r_in_mono)
    with ⟨α, hα_in, hα_le⟩
  simp only [coe_image, Set.mem_image, mem_coe] at hα_in
  rcases hα_in with ⟨g, hgG, rfl⟩

  -- Remainder property forbids any `LM g` (with `g ∈ G`) from dividing `LM r`
  have h_remainder_prop := (normalForm_spec m hG p).2.2
  have h_deg_in_support : m.degree r ∈ r.support :=
    MonomialOrder.degree_mem_support h_rem_ne_zero
  specialize h_remainder_prop (m.degree r) h_deg_in_support
  have forbid : ∀ b ∈ G, ¬ m.degree b ≤ m.degree r :=
    fun b hb => h_remainder_prop b hb

  exact (forbid g hgG) hα_le


variable (m) [DecidableEq σ] in
theorem Buchberger_Alg [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  {I : Ideal (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0)
  (hspan : I = Ideal.span F) :
  ∃ G : Finset (MvPolynomial σ k),
  F ⊆ G ∧
  IsGroebnerBasis m I G := by

  -- 1. State packages the set with the invariant "all entries nonzero".
  let State := { G : Finset (MvPolynomial σ k) // ∀ g ∈ G, g ≠ 0 }

  -- 2. Measure and well-founded relation (OrderDual so that < is well-founded).
  let H (s : State) := OrderDual.toDual (@Ideal.span (MvPolynomial σ k) _ (s.val.image (leadingTerm m)))
  let R (s₁ s₂ : State) : Prop := H s₁ < H s₂
    -- i.e. R s₁ s₂ := Ideal.span (s₁.val.image (leadingTerm m)) > @Ideal.span (MvPolynomial σ k) _ (s₂.val.image (leadingTerm m))
  have h_wf : WellFounded R := InvImage.wf H
    (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))

  -- 3. One-step function: uses s.property as hG for normalForm.
  let buchberger_step_fn (G_sub : State) (rec_call : ∀ (G'_sub : State), R G'_sub G_sub → State) : State :=

    let G := G_sub.val
    let hG := G_sub.property

    -- new = nonzero normal forms of S-polys
    let new := (G.offDiag.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

    if hR_empty : new = ∅ then
      G_sub
    else
      let G' := G ∪ new
      have hG' : ∀ g ∈ G', g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
        | inl hgG => exact hG g hgG
        | inr hgNew => unfold new at hgNew; rw [mem_filter] at hgNew; exact hgNew.2

      -- prove strict decrease of the measure when new ≠ ∅
      have h_decreasing : R ⟨G', hG'⟩ G_sub := by
        dsimp [R, H, OrderDual.toDual, OrderDual.ofDual]
        apply lt_of_le_of_ne
        · apply Ideal.span_mono; simp only [coe_image]
          refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          unfold G'; exact subset_union_left
        · intro h_ideals_eq
          simp only [coe_image, EmbeddingLike.apply_eq_iff_eq] at h_ideals_eq
          obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr hR_empty)
          have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' G) := by
            unfold new at hr
            simp only [ne_eq, mem_filter, mem_image] at hr
            obtain ⟨⟨pq, hpq⟩, hr_nezero⟩ := hr
            rw [←hpq.2]
            apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
            rw [hpq.2]
            exact hr_nezero
          have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' G) := by
            rw [←h_ideals_eq]
            apply Ideal.subset_span
            simp only [Set.mem_image, mem_coe]
            use r
            exact ⟨by unfold G'; exact mem_union_right G hr, rfl⟩
          exact hLT_r_notin hLT_r_in

      rec_call ⟨G', hG'⟩ h_decreasing

  -- initial state: filter out zeroes (but hF guarantees none)
  let F₀_sub : State := ⟨F.filter (· ≠ 0), fun g hg => (Finset.mem_filter.mp hg).2⟩
  have hF_eq_F₀ : F = F₀_sub.val := Eq.symm (filter_true_of_mem hF)

  -- the fixpoint state and the resulting G
  let G_sub := @WellFounded.fix State (fun _ => State) R h_wf buchberger_step_fn F₀_sub
  let G := G_sub.val
  use G

  ----------------------------------------------------------------
  -- 1) F ⊆ G  (monotonicity of the recursion)
  ----------------------------------------------------------------
  have h_F_sub_G : F ⊆ G := by
    rw [hF_eq_F₀]
    unfold G G_sub
    apply h_wf.induction
      (C := fun s => s.val ⊆ (h_wf.fix buchberger_step_fn s).val)
      F₀_sub
    intro s IH
    let hG := s.property
    let new := (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

    rw [WellFounded.fix_eq]
    unfold buchberger_step_fn
    by_cases h_new_empty : new = ∅
    · rw [dif_pos h_new_empty]
    · rw [dif_neg h_new_empty]
      have h_s_sub_union : s.val ⊆ s.val ∪ new := subset_union_left
      have : ∀ g ∈ ↑s ∪ new, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
          | inl hg_in_G => exact hG g hg_in_G
          | inr hg_in_new => unfold new at hg_in_new; rw [mem_filter] at hg_in_new; exact hg_in_new.2
      let s' : State := ⟨s.val ∪ new, this⟩
      have h_decreasing : R s' s := by
        unfold R H
        simp only [ne_eq, coe_image, OrderDual.toDual_lt_toDual]
        obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_new_empty)
        apply lt_of_le_of_ne
        · apply Ideal.span_mono
          refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          unfold s'; exact subset_union_left
        · intro h_ideals_eq
          have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            unfold new at hr
            simp only [ne_eq, mem_filter, mem_image] at hr
            obtain ⟨⟨pq, hpq⟩ , hr_nezero⟩ := hr
            rw [←hpq.2]
            apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
            rw [hpq.2]
            exact hr_nezero

          have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            rw [h_ideals_eq]
            apply Ideal.subset_span
            simp only [Set.mem_image, mem_coe]
            use r
            exact ⟨by unfold s'; exact mem_union_right s hr, rfl⟩
          exact hLT_r_notin hLT_r_in
      specialize IH s' h_decreasing
      exact Finset.Subset.trans h_s_sub_union IH

  ----------------------------------------------------------------
  -- 2) G is zero-free (invariant)
  ----------------------------------------------------------------
  have hG_nonzero : ∀ g ∈ G, g ≠ 0 := by
    -- property is carried in the State, so just use G_sub.property
    exact G_sub.property

  ----------------------------------------------------------------
  -- 3) span equality: I = span G
  ----------------------------------------------------------------
  have h_I_eq_span_G : I = Ideal.span G := by
    rw [hspan, hF_eq_F₀]
    apply h_wf.induction
      (C := fun s => Ideal.span s.val = @Ideal.span (MvPolynomial σ k) _ (WellFounded.fix h_wf buchberger_step_fn s).val)
      F₀_sub
    intro s ih
    let hG := s.property
    rw [WellFounded.fix_eq]
    dsimp [buchberger_step_fn]
    let new := (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
    by_cases h_new_empty : new = ∅
    · rw [if_pos h_new_empty]
    · rw [if_neg h_new_empty]
      have : ∀ g ∈ ↑s ∪ new, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
          | inl hg_in_G => exact hG g hg_in_G
          | inr hg_in_new => unfold new at hg_in_new; rw [mem_filter] at hg_in_new; exact hg_in_new.2
      let s' : State := ⟨s.val ∪ new, this⟩

      have h_decreasing : R s' s := by
        unfold R H
        simp only [coe_image, OrderDual.toDual_lt_toDual]
        obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_new_empty)
        apply lt_of_le_of_ne
        · apply Ideal.span_mono
          refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          unfold s'; exact subset_union_left
        · intro h_ideals_eq
          have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            unfold new at hr
            simp only [mem_filter, mem_image] at hr
            obtain ⟨⟨pq, hpq⟩ , hr_nezero⟩ := hr
            rw [←hpq.2]
            apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
            rw [hpq.2]
            exact hr_nezero

          have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            rw [h_ideals_eq]
            apply Ideal.subset_span
            simp only [Set.mem_image, mem_coe]
            use r
            exact ⟨by unfold s'; exact mem_union_right s hr, rfl⟩
          exact hLT_r_notin hLT_r_in

      rw [← ih s' h_decreasing]
      apply le_antisymm
      · apply Ideal.span_mono
        unfold s'
        simp only [coe_union, Set.subset_union_left]
      · rw [Ideal.span_le]
        unfold s'
        simp only [coe_union, Set.union_subset_iff]
        constructor
        · exact Ideal.subset_span
        · unfold new
          simp only [coe_filter, mem_image, mem_offDiag]
          rw [Set.subset_def]
          intro r hr_in_new
          obtain ⟨⟨pq, hpq_in_offDiag, hr_eq_normalForm⟩, hr_ne_zero⟩ := hr_in_new
          rw [← hr_eq_normalForm]

          let S := S_polynomial m pq.1 pq.2
          have h_spec := normalForm_spec' m s.property S
          let q := quotients m s.property S
          let q_sum := q.sum (fun (g : ↥s.val) (h : MvPolynomial σ k) => h * g.val)

          have h_r_eq_sub : r = S - q_sum := by
            have : S = q_sum + r := by
              rw [h_spec.1]
              unfold q_sum q quotients
              congr
            exact eq_sub_of_add_eq' (id (Eq.symm this))
          rw [hr_eq_normalForm, h_r_eq_sub]
          apply Ideal.sub_mem
          · -- First goal: `S ∈ Ideal.span s.val`.
            unfold S S_polynomial
            let I_s := Ideal.span (s.val : Set (MvPolynomial σ k))
            have hp_in_I : pq.1 ∈ I_s := Ideal.subset_span (hpq_in_offDiag.1)
            have hq_in_I : pq.2 ∈ I_s := Ideal.subset_span (hpq_in_offDiag.2.1)
            exact Ideal.sub_mem _ (Ideal.mul_mem_left _ _ hp_in_I) (Ideal.mul_mem_left _ _ hq_in_I)

          · -- Second goal: `q_sum ∈ Ideal.span s.val`.
            unfold q_sum
            rw [Finsupp.sum]
            apply sum_mem
            intro g_sub _
            -- `g_sub` is `⟨g, hg_in_s⟩` of type `↥s.val`.
            -- The term is `(q g_sub) * g_sub.val`.
            apply Ideal.mul_mem_left
            apply Ideal.subset_span
            exact g_sub.property

  ----------------------------------------------------------------
  -- 4) Use Buchberger criterion: show all S-polynomials reduce to 0.
  ----------------------------------------------------------------
  -- define the Rset function (nonzero remainders at state s)
  let Rset (s : State) : Finset (MvPolynomial σ k) :=
    (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
  have Rset_fix_empty : Rset (h_wf.fix buchberger_step_fn F₀_sub) = ∅ := by
    -- Do induction on arbitrary starting state s, specialize at F₀_sub
    apply h_wf.induction (C := fun s => Rset (h_wf.fix buchberger_step_fn s) = ∅) F₀_sub
    intro s ih
    let new_s := (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
    have hfix := WellFounded.fix_eq h_wf buchberger_step_fn s

    by_cases h_new_empty : new_s = ∅
    · -- stable case: fix s = s, so Rset (fix s) = new_s = ∅
      have : (h_wf.fix buchberger_step_fn s) = s := by
        rw [WellFounded.fix_eq]
        dsimp [buchberger_step_fn]
        rw [if_pos h_new_empty]
      simp only [Rset, this, new_s, h_new_empty]
    · -- recursive case: form s' = s ∪ new_s and use IH
      have h_all_nonzero : ∀ g ∈ s.val ∪ new_s, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
        | inl hg_in_s => exact s.property g hg_in_s
        | inr hg_in_new => unfold new_s at hg_in_new; rw [mem_filter] at hg_in_new; exact hg_in_new.2
      let s' : State := ⟨s.val ∪ new_s, h_all_nonzero⟩
      -- prove strict decrease R s' s (same pattern as earlier)
      have h_decreasing : R s' s := by
        dsimp [R, H, OrderDual.toDual, OrderDual.ofDual]
        obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_new_empty)
        apply lt_of_le_of_ne
        · apply Ideal.span_mono
          simp only [coe_image]
          refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          unfold s'; exact subset_union_left
        · intro h_ideals_eq
          simp only [coe_image, EmbeddingLike.apply_eq_iff_eq] at h_ideals_eq
          have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f => m.leadingTerm f) '' s.val) := by
            unfold new_s at hr
            simp only [mem_filter, mem_image] at hr
            obtain ⟨⟨pq, hpq⟩, hr_nezero⟩ := hr
            rw [←hpq.2]
            apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
            rw [hpq.2]
            exact hr_nezero
          have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f => m.leadingTerm f) '' s.val) := by
            rw [id (Eq.symm h_ideals_eq)]
            apply Ideal.subset_span
            simp only [Set.mem_image, mem_coe]
            use r
            exact ⟨by unfold s'; exact mem_union_right s hr, rfl⟩
          exact hLT_r_notin hLT_r_in

      have hfix : h_wf.fix buchberger_step_fn s =
              h_wf.fix buchberger_step_fn s' := by
        rw [WellFounded.fix_eq]
        dsimp [buchberger_step_fn]
        rw [if_neg h_new_empty]
      -- finish using IH at s'
      simpa [hfix] using ih s' h_decreasing

  -- finish Buchberger criterion
  have h_G_is_GB : IsGroebnerBasis m I G := by
    apply (Buchberger_criterion m hG_nonzero h_I_eq_span_G).mpr
    intro p q hp hq h_ne
    let r := normalForm m hG_nonzero (S_polynomial m p q)
    by_contra hr_nonzero
    -- r would be in Rset of final state
    have hr_in : r ∈ (G.offDiag.image (fun pq => normalForm m hG_nonzero (S_polynomial m pq.1 pq.2))).filter (· ≠ 0) := by
      simp only [ mem_filter, mem_image, mem_offDiag]
      refine ⟨⟨(p, q), ?_, rfl⟩, ?_⟩
      · -- show (p, q) ∈ offDiag
        simpa [mem_offDiag] using ⟨hp, hq, h_ne⟩
      · -- show r ≠ 0
        exact hr_nonzero

    have hr_in' : r ∈ Rset G_sub := by
      dsimp [Rset]
      simpa [G, G_sub] using hr_in

    rw [Rset_fix_empty] at hr_in'
    exact Finset.notMem_empty r hr_in'

  exact ⟨h_F_sub_G, h_G_is_GB⟩
