import Mathlib.RingTheory.MvPolynomial.Groebner
import Mathlib.RingTheory.MvPolynomial.Ideal
import Mathlib.RingTheory.Noetherian.Defs

variable {σ R : Type*} [CommSemiring R]
variable {k : Type*} [Field k]
variable {m : MonomialOrder σ}

namespace MvPolynomial

open scoped MonomialOrder

/-
## Reference : [Becker-Weispfenning1993]

## TODO

* Authors: Antoine Chambert-Loir

* Prove that under `Field F`, `IsUnit (m.leadingCoeff (b i))` is equivalent to `b i ≠ 0`.
-/

theorem isUnit_leadingCoeff_iff_nonzero
  (m : MonomialOrder σ) (b : MvPolynomial σ k) :
  IsUnit (m.leadingCoeff b) ↔ b ≠ 0 := by
  constructor
  · intro h
    contrapose! h
    rw [h, m.leadingCoeff_zero]
    exact not_isUnit_zero
  · intro hb
    have h₁ : m.leadingCoeff b ≠ 0 := by exact MonomialOrder.leadingCoeff_ne_zero_iff.mpr hb
    exact isUnit_iff_ne_zero.mpr h₁

variable (m) in
/-- the leading coefficient of a multivariate polynomial with respect to a monomial ordering -/
noncomputable def leadingTerm (f : MvPolynomial σ R) : MvPolynomial σ R :=
  monomial (m.degree f) (f.coeff (m.degree f))

variable (m) in
/-- The S-polynomial. -/
noncomputable def S_polynomial (f g : MvPolynomial σ k) : MvPolynomial σ k :=
  let γ := monomial (m.degree f ⊔ m.degree g) (1 : k)
  (γ - leadingTerm m f) * f - (γ - leadingTerm m g) * g

variable (m) in
/-- The set of leading terms of nonzero polynomials in an ideal I. -/
def leadingTermSet (I : Ideal (MvPolynomial σ R)) : Set (MvPolynomial σ R) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

variable (m) in
/-- The ideal generated by the leading terms of the nonzero elements of I. -/
def initialIDeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  Ideal.span (leadingTermSet m I) -- initialIDeal = Ideal.span { f | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

-- Proposition 3.
theorem initialIDeal_is_monomial_ideal {I : Ideal (MvPolynomial σ R)} (hI : I ≠ ⊥) :
  ∃ (A : Finset (σ →₀ ℕ)), (A.toSet ⊆ { s : (σ →₀ ℕ) | ∃ (g : MvPolynomial σ R), g ∈ I ∧ g ≠ 0 ∧ m.degree g = s } ∧
    initialIDeal m I = Ideal.span { f | ∃ s ∈ A, f = monomial s (1 : R) }) := by sorry

/- Definition 5. Groebner_basis
A finite subset G of an ideal I is called a Gröbner basis (or standard basis)
if the ideal generated by the leading terms of the elements of G equals the leading term ideal of I.
We adopt the convention that ⟨∅⟩ = {0}, so that the empty set is the Gröbner basis of the zero ideal.
-/

variable (m) [DecidableEq (MvPolynomial σ R)] in
def is_GrobnerBasis {ι : Type*} (I : Ideal (MvPolynomial σ R)) (G : ι →₀ MvPolynomial σ R): Prop :=
  (I = ⊥ ∧ G = 0) ∨
  (I ≠ ⊥ ∧ (∀ i ∈ G.support, G i ∈ I) ∧
    Ideal.span (G.support.image (fun i ↦ leadingTerm m (G i))) = initialIDeal m I)

/-
Corollary 6.
Fix a monomial order on \(k[x_1,\dots,x_n]\). Then every ideal \(I\) has a Gröbner basis.
Furthermore, any Gröbner basis for \(I\) is a generating set of \(I\).
-/

variable [Fintype σ] [IsNoetherianRing R] in
theorem Hilbert_basis_initial (I : Ideal (MvPolynomial σ R)) : Ideal.FG (initialIDeal m I)
  := sorry --(inferInstance : IsNoetherian _ _).noetherian (initialIDeal m I)

variable [Fintype σ] [DecidableEq (MvPolynomial σ R)] in
theorem grobner_basis_exists (I : Ideal (MvPolynomial σ R)) :
  ∃ (ι : Type*) (G : ι →₀ MvPolynomial σ R), is_GrobnerBasis m I G := by
  -- have h_fin : Ideal.FG (initialIDeal m I) := Hilbert_basis_initial I
  sorry


variable [DecidableEq (MvPolynomial σ R)] in
noncomputable def remainder {ι : Type*} (b : ι →₀ MvPolynomial σ k) (hb : ∀ (i : ι), b i ≠ 0) (f : MvPolynomial σ k) : MvPolynomial σ k :=
  have hb' : ∀ (i : ι), IsUnit (m.leadingCoeff (b i)) := by
    intro i
    exact (isUnit_leadingCoeff_iff_nonzero m (b i)).mpr (hb i)
  let div_result := MonomialOrder.div hb' f
  have : Nonempty { g | ∃ r, f = (Finsupp.linearCombination (MvPolynomial σ k) ⇑b) g + r ∧
    (∀ (i : ι), m.toSyn (m.degree (b i * g i)) ≤ m.toSyn (m.degree f)) ∧ ∀ c ∈ r.support, ∀ (i : ι), ¬m.degree (b i) ≤ c } := by exact Set.Nonempty.to_subtype div_result
  let g := Exists.choose div_result
  have r_choose : ∃ r, f = (Finsupp.linearCombination (MvPolynomial σ k) ⇑b) g + r ∧
    (∀ (i : ι), m.toSyn (m.degree (b i * g i)) ≤ m.toSyn (m.degree f)) ∧ ∀ c ∈ r.support, ∀ (i : ι), ¬m.degree (b i) ≤ c := by sorry
  let r := Exists.choose r_choose
  r
  /-div_result : ∃ g r,
  f = (Finsupp.linearCombination (MvPolynomial σ k) ⇑b) g + r ∧
    (∀ (i : ι), m.toSyn (m.degree (b i * g i)) ≤ m.toSyn (m.degree f)) ∧ ∀ c ∈ r.support, ∀ (i : ι), ¬m.degree (b i) ≤ c := MonomialOrder.div hb f
  -/

-- variable [Fintype σ] [DecidableEq (MvPolynomial σ R)] in
-- noncomputable def remainder₁ {ι : Type*} (b : ι →₀ MvPolynomial σ k) (f : MvPolynomial σ k) : MvPolynomial σ k :=
--   let ⟨g, r, _⟩ := MonomialOrder.div (m := m) (fun i : {x // x ∈ b.support}  => (isUnit_leadingCoeff_iff_nonzero m (b i.val)).mpr (Finsupp.mem_support_iff.mp i.2)) f
--   r
/-
Buchberger’s Criterion (Theorem 6) says:
Let `I` be a polynomial ideal and let `G` be a basis of `I` (i.e. `I = ideal.span G`).
Then `G` is a Gröbner basis if and only if for all pairs of distinct polynomials
`g₁, g₂ ∈ G`, the remainder on division of `S_polynomial g₁ g₂` by `G` is zero.
-/

-- variable (m) [Fintype σ] [DecidableEq (MvPolynomial σ k)] in
-- theorem Buchberger_criterion
--   {ι : Type*} {I : Ideal (MvPolynomial σ k)}
--   (G : ι →₀ MvPolynomial σ k)
--   (hG : I = Ideal.span (Set.range G)) :
--   is_GrobnerBasis m I G ↔
--     (∀ (g₁ g₂ : MvPolynomial σ k),
--       g₁ ∈ (Set.range G) →
--       g₂ ∈ (Set.range G) →
--       g₁ ≠ g₂ →
--       remainder (S_polynomial m g₁ g₂) (G.toFinset.image (fun i ↦ G i)) = 0) := by sorry

/-
A polynomial `f` in `MvPolynomial σ R` is said to reduce to zero modulo a
finite set of polynomials `G ⊆ MvPolynomial σ R` (written `f ⟶[G] 0`) if there
exists a standard representation
  f = ∑ (g ∈ G), A(g) * g,
where `A : G → MvPolynomial σ R`, such that for every `g ∈ G`, if
  A(g) * g ≠ 0,
then
  m.degree (A(g) * g) ≤ m.degree f.
-/

variable [Fintype σ] in
def reduces_to_zero (G : Finset (MvPolynomial σ k)) (f : MvPolynomial σ k) : Prop :=
∃ (A : MvPolynomial σ k → MvPolynomial σ k),
  (f = ∑ g ∈ G, (A g) * g) ∧ ∀ g ∈ G, (A g) * g ≠ 0 → m.degree ((A g) * g) ≼[m] m.degree f
