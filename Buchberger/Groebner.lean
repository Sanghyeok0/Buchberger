/-
Copyright (c) 2024 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/
module

public import Mathlib.Data.Finsupp.Lex
public import Mathlib.Data.Finsupp.MonomialOrder
public import Mathlib.Data.Finsupp.WellFounded
public import Mathlib.Data.List.TFAE
public import Mathlib.RingTheory.MvPolynomial.Homogeneous
public import Mathlib.RingTheory.MvPolynomial.MonomialOrder
public import Mathlib.RingTheory.MvPolynomial.Ideal
public import Mathlib.Data.Finsupp.Defs
public import Buchberger.Finset
public import Mathlib.RingTheory.MvPolynomial.Groebner

@[expose] public section

/-! # Division algorithm with respect to monomial orders

We provide a division algorithm with respect to monomial orders in polynomial rings.
Let `R` be a commutative ring, `σ` a type of indeterminates and `m : MonomialOrder σ`
a monomial ordering on `σ →₀ ℕ`.

Consider a family of polynomials `b : ι → MvPolynomial σ R` with invertible leading coefficients
(with respect to `m`): we assume `hb : ∀ i, IsUnit (m.leadingCoeff (b i))`.

* `MonomialOrder.div hb f` furnishes
  - a finitely supported family `g : ι →₀ MvPolynomial σ R`
  - and a “remainder” `r : MvPolynomial σ R`
such that the three properties hold:
  (1) One has `f = ∑ (g i) * (b i) + r`
  (2) For every `i`, `m.degree ((g i) * (b i)` is less than or equal to that of `f`
  (3) For every `i`, every monomial in the support of `r` is strictly smaller
    than the leading term of `b i`,

The proof is done by induction, using two standard constructions

* `MonomialOrder.subLTerm f` deletes the leading term of a polynomial `f`

* `MonomialOrder.reduce hb f` subtracts from `f` the appropriate multiple of `b : MvPolynomial σ R`,
  provided `IsUnit (m.leadingCoeff b)`.

* `MonomialOrder.div_set` is the variant of `MonomialOrder.div` for a set of polynomials.

* `MonomialOrder.div_single` is the variant of `MonomialOrder.div` for a single polynomial.


## Reference : [Becker-Weispfenning1993]

-/

@[expose] public section

variable {σ : Type*} {m : MonomialOrder σ} {R : Type*} [CommRing R]

namespace MvPolynomial

variable (R) in
def monomialIdeal (s : Set (σ →₀ ℕ)) : Ideal (MvPolynomial σ R) :=
  Ideal.span ((fun a => monomial a (1 : R)) '' s)

end MvPolynomial

namespace MonomialOrder

open MvPolynomial

open scoped MonomialOrder

variable (m) in
/-- The set of leading terms of nonzero polynomials in an ideal I. -/
def LT_set (I : Ideal (MvPolynomial σ R)) : Set (MvPolynomial σ R) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

variable (m) in
def LM_set (I : Ideal (MvPolynomial σ R)) : Set (σ →₀ ℕ) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = f }

variable (m) in
def leadingTermIdeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  Ideal.span (LT_set m I)

variable (m) in
/-- The ideal generated by the leading monomials of the nonzero elements of I. -/
def initialIdeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  MvPolynomial.monomialIdeal R (LM_set m I)

/-- Multiplicativity of leading terms -/
theorem leadingTerm_mul [IsCancelMulZero R] {f g : MvPolynomial σ R} (hf : f ≠ 0) (hg : g ≠ 0) :
    m.leadingTerm (f * g) = m.leadingTerm f * m.leadingTerm g := by
  repeat rw [leadingTerm]
  rw [degree_mul hf hg, leadingCoeff_mul hf hg]
  rw [MvPolynomial.monomial_mul]

variable (m) in
lemma degree_add_lt_of_le_lt {f g : MvPolynomial σ R} {δ : σ →₀ ℕ}
  (hf : m.degree f ≺[m] δ) (hg : m.degree g ≺[m] δ) :
  m.degree (f + g) ≺[m] δ := by
  apply lt_of_le_of_lt (m.degree_add_le)
  rw [max_lt_iff]
  exact ⟨hf, hg⟩

variable (m) in
lemma degree_add_lt_of_le_lt' {f g : MvPolynomial σ R} {δ : m.syn}
  (hf : m.toSyn (m.degree f) < δ) (hg : m.toSyn (m.degree g) < δ) :
  m.toSyn (m.degree (f + g)) < δ := by
  apply lt_of_le_of_lt (m.degree_add_le)
  rw [max_lt_iff]
  exact ⟨hf, hg⟩

section Field

variable {k : Type*} [Field k]

/--
**Proposition 3 (i) (Cox, Little, O'Shea, Ch 2, §5, Proposition 3)**
⟨LT(I)⟩ is a monomial ideal.
-/
lemma leadingTermIdeal_is_initialIdeal (I : Ideal (MvPolynomial σ k)) :
    leadingTermIdeal m I = initialIdeal m I := by
  apply le_antisymm
  · -- Show span(LT) ⊆ span(LM)
    rw [initialIdeal, leadingTermIdeal, Ideal.span_le]
    unfold LT_set LM_set
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_LT_eq⟩
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 := MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lt : leadingTerm m g
      = (MvPolynomial.C (m.leadingCoeff g)) * (monomial (m.degree g) (1 : k)) := by
        simp only [leadingTerm, C_mul_monomial, mul_one]
    rw [h_lt] at h_LT_eq
    rw [←h_LT_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq] -- , Set.mem_setOf_eq, one_ne_zero, not_false_eq_true, monomial_left_inj
    apply Ideal.subset_span
    simp only [Set.mem_image, Set.mem_setOf_eq, ne_eq, one_ne_zero, not_false_eq_true,
      monomial_left_inj, exists_eq_right]
    use g
  · -- Show span(LM) ⊆ span(LT)
    rw [initialIdeal, monomialIdeal, leadingTermIdeal, Ideal.span_le]
    unfold LT_set LM_set
    simp only [Set.image_subset_iff]
    intro lmg hlmg_in
    rcases hlmg_in with ⟨g, hg_mem⟩
    rcases hg_mem with ⟨hg_mem_I, ⟨hg_ne_zero, h_lm_eq⟩⟩
    simp only [Set.mem_preimage, SetLike.mem_coe]
    have : (monomial lmg) 1 = C (m.leadingCoeff g)⁻¹ * (leadingTerm m g) := by
      rw [←h_lm_eq, leadingTerm]
      rw [C_mul', smul_monomial]
      rw [smul_eq_mul]
      have hlc_ne_zero : m.leadingCoeff g ≠ 0 :=
        MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
      rw [inv_mul_cancel₀ hlc_ne_zero]
    rw [this]
    apply Ideal.mul_mem_left
    apply Ideal.subset_span (by use g)

variable (m) in
noncomputable def quotients
  {B : Set (MvPolynomial σ k)} (hB : ∀ b ∈ B, b ≠ 0) (f : MvPolynomial σ k) :
  B →₀ MvPolynomial σ k :=
  (MonomialOrder.div_set (m := m) (B := B)
      (hB := fun b hb => isUnit_leadingCoeff.2 (hB b hb))
      f).choose

variable (m) in
noncomputable def normalForm
  {B : Set (MvPolynomial σ k)} (hB : ∀ b ∈ B, b ≠ 0) (f : MvPolynomial σ k) :
  MvPolynomial σ k :=
  (MonomialOrder.div_set (m := m) (B := B)
      (hB := fun b hb => isUnit_leadingCoeff.2 (hB b hb))
      f).choose_spec.choose

variable (m) in
@[simp]
lemma normalForm_zero
  {B : Set (MvPolynomial σ k)}
  (hB : ∀ b ∈ B, b ≠ 0) :
  m.normalForm hB (0 : MvPolynomial σ k) = 0 := by
  let D :=
    MonomialOrder.div_set (m := m) (B := B)
      (hB := fun b hb => isUnit_leadingCoeff.2 (hB b hb))
      (0 : MvPolynomial σ k)
  rcases D.choose_spec.choose_spec with ⟨h_eq, h_deg, h_rem⟩
  have hr_def :
      m.normalForm (B := B) hB (0 : MvPolynomial σ k) = D.choose_spec.choose := by
    rfl
  -- Case 1: if there exists a constant divisor, then the remainder condition alone forces `r = 0`.
  by_cases hconst : ∃ b : B, m.degree (b : MvPolynomial σ k) = 0
  · rcases hconst with ⟨b0, hb0deg⟩
    -- `D.choose_spec.choose` is the remainder (i.e. the normal form).
    have hr_support : (D.choose_spec.choose : MvPolynomial σ k).support = ∅ := by
      refine Finset.eq_empty_of_forall_notMem ?_
      intro c hc
      have hbad : ¬ m.degree (b0 : MvPolynomial σ k) ≤ c :=
        h_rem c hc (b0 : MvPolynomial σ k) b0.property
      have hle : m.degree (b0 : MvPolynomial σ k) ≤ c := by
        simp only [hb0deg, _root_.zero_le]
      exact hbad hle
    have hr0 : (D.choose_spec.choose : MvPolynomial σ k) = 0 := by
      exact (Finsupp.support_eq_empty.1 hr_support)
    exact hr0
  -- Case 2: if there is no constant divisor, then every term `b * g(b)` to be zero,
  -- hence the whole linear combination is zero, and therefore `r = 0`.
  · have hdeg_ne0 : ∀ b : B, m.degree (b : MvPolynomial σ k) ≠ 0 := by
      intro b hb0
      exact hconst ⟨b, hb0⟩
    have hg0 : ∀ b : B, D.choose b = 0 := by
      intro b
      by_contra hbq
      have hb_ne : (b : MvPolynomial σ k) ≠ 0 := hB b b.property
      have hle_syn :
          m.toSyn (m.degree ((b : MvPolynomial σ k) * D.choose b))
            ≤ m.toSyn (m.degree (0 : MvPolynomial σ k)) :=
        h_deg b
      have hle_bot :
          m.toSyn (m.degree ((b : MvPolynomial σ k) * D.choose b)) ≤ ⊥ := by
        simpa only [degree_zero, map_zero, Subtype.forall, mem_support_iff, ne_eq,
          bot_eq_zero] using hle_syn
      have hdeg_prod_zero :
          m.degree ((b : MvPolynomial σ k) * D.choose b) = 0 := by
        have h_eq_bot :
            m.toSyn (m.degree ((b : MvPolynomial σ k) * D.choose b)) = ⊥ :=
          le_bot_iff.mp hle_bot
        have h_eq_zero_syn :
            m.toSyn (m.degree ((b : MvPolynomial σ k) * D.choose b)) = 0 := by
          simpa only [degree_zero, map_zero, Subtype.forall, mem_support_iff,
            EmbeddingLike.map_eq_zero_iff, bot_eq_zero] using h_eq_bot
        exact (AddEquiv.map_eq_zero_iff m.toSyn).mp h_eq_zero_syn
      have hmul :
          m.degree ((b : MvPolynomial σ k) * D.choose b)
            = m.degree (b : MvPolynomial σ k) + m.degree (D.choose b) :=
        m.degree_mul hb_ne hbq
      have : m.degree (b : MvPolynomial σ k) = 0 := by
        have : m.degree (b : MvPolynomial σ k) + m.degree (D.choose b) = 0 := by
          rw [←hmul]
          exact hdeg_prod_zero
        exact (add_eq_zero.mp this).1
      exact (hdeg_ne0 b) this
    have hchoose0 : (D.choose : B →₀ MvPolynomial σ k) = 0 := by
      refine Finsupp.ext ?_
      intro b
      exact hg0 b
    have hlin :
        Finsupp.linearCombination (MvPolynomial σ k)
          (fun b : B ↦ (b : MvPolynomial σ k)) D.choose = 0 := by
      rw [hchoose0, map_zero]
    have hr0 : (D.choose_spec.choose : MvPolynomial σ k) = 0 := by
      have h0r : (0 : MvPolynomial σ k) = (D.choose_spec.choose : MvPolynomial σ k) := by
        have : (0 : MvPolynomial σ k) = 0 + (D.choose_spec.choose : MvPolynomial σ k) := by
          nth_rw 2 [←hlin]
          nth_rw 1 [h_eq]
        simpa only [degree_zero, map_zero, Subtype.forall, mem_support_iff, ne_eq, zero_add] using
          this
      simpa only [degree_zero, map_zero, Subtype.forall, mem_support_iff, ne_eq] using h0r.symm
    exact Eq.symm (ext 0 (m.normalForm hB 0) fun m_1 ↦ congrArg (coeff m_1) (id (Eq.symm hr0)))

variable (m) in
/--
This lemma states that the `quotients` and `normalForm` functions satisfy the properties
guaranteed by the division algorithm.
-/
lemma normalForm_spec
  {B : Set (MvPolynomial σ k)} (hB : ∀ b ∈ B, b ≠ 0) (f : MvPolynomial σ k) :
  let q := quotients m hB f
  let r := normalForm m hB f
  -- Property 1: The division equation
  f = (Finsupp.linearCombination _ (fun (b : B) ↦ (b : MvPolynomial σ k)) q) + r ∧
  -- Property 2: The degree condition
  (∀ (p : B), m.degree ((p : MvPolynomial σ k) * q p) ≼[m] m.degree f) ∧
  -- Property 3: The remainder condition (irreducibility)
  (∀ c ∈ r.support, ∀ b ∈ B, ¬ m.degree b ≤ c) := by
  simpa only [quotients, Subtype.forall, mem_support_iff, ne_eq, normalForm] using
    (MonomialOrder.div_set (m := m) (B := B) (hB := fun b hb =>
        isUnit_leadingCoeff.2 (hB b hb)) f).choose_spec.choose_spec

/--
If `normalForm m B hB f = 0`, then in fact `f = ∑ (quotients m B hB f) • b`. -/
theorem representation_of_f_of_normalForm_zero
  {B : Set (MvPolynomial σ k)} (hB : ∀ b ∈ B, b ≠ 0) (f : MvPolynomial σ k)
  (h0 : normalForm m hB f = 0) :
  f = Finsupp.linearCombination _ (fun b : B ↦ (b : MvPolynomial σ k)) (quotients m hB f) := by
  have : f = Finsupp.linearCombination _
    (fun b : B ↦ (b : MvPolynomial σ k)) (quotients m hB f) + (normalForm m hB f) := by
      apply (normalForm_spec m hB f).1
  rw [h0, add_zero] at this
  exact this

variable (m) in
/-- dividing 0 gives a representation whose linear combination is 0 -/
lemma quotients_sum_eq_zero
  {B : Set (MvPolynomial σ k)}
  (hB : ∀ b ∈ B, b ≠ 0) :
  (m.quotients (B := B) hB (0 : MvPolynomial σ k)).sum
      (fun (b : B) (q : MvPolynomial σ k) => q * (b : MvPolynomial σ k)) = 0 := by
  simpa only [Finsupp.linearCombination, Finsupp.coe_lsum, LinearMap.coe_smulRight,
    LinearMap.id_coe, id_eq, smul_eq_mul, m.normalForm_zero (B := B) hB, add_zero] using
    (normalForm_spec (m := m) (B := B) hB (0 : MvPolynomial σ k)).1.symm

variable (m) in
/--
**Gröbner basis property.**
For an ideal `I` and a finite set `G`, this means:

- `G ⊆ I`, and
- `⟨ LT(G) ⟩ = ⟨ LT(I) ⟩`,

where `LT(G) = { LT(g) | g ∈ G }` and `LT(I) = { LT(f) | f ∈ I \ {0} }`.
-/
def GroebnerBasis_prop (I : Ideal (MvPolynomial σ k)) (G : Finset (MvPolynomial σ k)) : Prop :=
  (G : Set (MvPolynomial σ k)) ⊆ I ∧
  Ideal.span ((fun g => leadingTerm m g) '' (G : Set (MvPolynomial σ k)))
  = MonomialOrder.leadingTermIdeal m I

variable (m) [DecidableEq σ] [DecidableEq k] in
/--
Removing `0` from `G` does not change the Gröbner basis property:

`G` satisfies `G ⊆ I` and `⟨ LT(G) ⟩ = ⟨ LT(I) ⟩`
if and only if `G \ {0}` satisfies the same conditions.
-/
lemma GroebnerBasis_prop_remove_zero
  (I : Ideal (MvPolynomial σ k)) (G : Finset (MvPolynomial σ k)) :
    GroebnerBasis_prop m I G ↔ GroebnerBasis_prop m I (G \ {0}) := by
  -- Auxiliary lemma: removing 0 does not change the span of leading terms
  have h_span : Ideal.span ((leadingTerm m) '' G) =
    Ideal.span ((leadingTerm m) '' (G \ {0} : Set (MvPolynomial σ k))) := by
    apply le_antisymm
    · -- (⊆) Case split: g = 0 (trivial) or g ≠ 0 (in G \ {0})
      rw [Ideal.span_le]
      rintro y ⟨g, hg, rfl⟩
      by_cases h0 : g = 0
      · rw [h0, leadingTerm_zero]; exact Ideal.zero_mem _
      · apply Ideal.subset_span
        exact ⟨g, by simpa only [Set.mem_diff, SetLike.mem_coe, Set.mem_singleton_iff]
          using ⟨hg, h0⟩, rfl⟩
    · -- (⊇) Monotonicity: G \ {0} ⊆ G
      apply Ideal.span_mono
      apply Set.image_mono
      simp only [Set.diff_singleton_subset_iff, Set.subset_insert]
  unfold GroebnerBasis_prop
  constructor
  · -- (→) If G is a GB, so is G \ {0}
    rintro ⟨hGI, hLT⟩
    constructor
    · -- G \ {0} ⊆ G ⊆ I
      simp only [Finset.coe_sdiff, Finset.coe_singleton, Set.diff_singleton_subset_iff,
        SetLike.mem_coe, zero_mem, Set.insert_eq_of_mem]
      exact hGI
    · -- The spans are equal via h_span
      simp only [Finset.coe_sdiff, Finset.coe_singleton]
      rw [←h_span, ←hLT]
  · -- (←) If G \ {0} is a GB, so is G
    rintro ⟨hGI, hLT⟩
    constructor
    · -- G ⊆ I (handle 0 case explicitly)
      intro g hg
      by_cases h0 : g = 0
      · rw [h0]; exact Ideal.zero_mem _
      · apply hGI
        simpa using ⟨hg, h0⟩
    · -- The spans are equal via h_span
      rw [h_span]
      simp only [Finset.coe_sdiff, Finset.coe_singleton] at hLT
      exact hLT

variable (m) [DecidableEq σ] in
/-- **Cox, Little, O'Shea, Ch 2, §5 Definition 5. Groebner_basis**
A finite subset `G` of an ideal `I` is called a Gröbner basis (or standard basis) if

1. `0 ∉ G`, and
2. `G ⊆ I`, and
3. `⟨ LT(G) ⟩ = ⟨ LT(I) ⟩` (the ideal generated by the leading terms of the elements of `G`
equals the leading term ideal of `I`).

We adopt the convention `⟨∅⟩ = {0}`, so `∅` is a Gröbner basis of the zero ideal.
-/
def IsGroebnerBasis (I : Ideal (MvPolynomial σ k)) (G : Finset (MvPolynomial σ k)) : Prop :=
  (∀ g ∈ G, g ≠ 0) ∧ GroebnerBasis_prop m I G

variable [DecidableEq σ] in
lemma IsGroebnerBasis.leadingTermIdeal_eq_monomialIdeal
    {I : Ideal (MvPolynomial σ k)} {G : Finset (MvPolynomial σ k)}
    (hGB : IsGroebnerBasis m I G) :
    leadingTermIdeal m I = monomialIdeal k (G.image fun g => m.degree g) := by
  rw [hGB.2.2.symm, monomialIdeal, Finset.coe_image, Set.image_image]
  apply le_antisymm <;> rw [Ideal.span_le] <;> rintro _ ⟨g, hg, rfl⟩
  · -- (⊆) leadingTerm g ∈ span { monomial (deg g) 1 }
    unfold leadingTerm
    -- Explicitly construct the equality to assist rewriting
    have h_decomp : monomial (m.degree g) (m.leadingCoeff g) =
                    C (m.leadingCoeff g) * monomial (m.degree g) 1 := by
      rw [C_mul_monomial, mul_one]
    simp only [SetLike.mem_coe]
    rw [h_decomp]
    apply Ideal.mul_mem_left
    exact Ideal.subset_span ⟨g, hg, rfl⟩
  · -- (⊇) monomial (deg g) 1 ∈ span { leadingTerm g }
    dsimp only
    have h_lc_ne0 : m.leadingCoeff g ≠ 0 := by exact leadingCoeff_ne_zero_iff.mpr (hGB.1 g hg)
    -- Construct equality: monomial n 1 = C (lc⁻¹) * leadingTerm g
    have h_decomp : monomial (m.degree g) 1 = C (m.leadingCoeff g)⁻¹ * leadingTerm m g := by
      rw [leadingTerm, C_mul_monomial, inv_mul_cancel₀ h_lc_ne0]
    rw [h_decomp]
    apply Ideal.mul_mem_left
    -- Since g ∈ G, LT(g) is in the span of LT(G)
    apply Ideal.subset_span
    exact ⟨g, hg, rfl⟩


/--
Proposition. If `G` is a Gröbner basis for `I`, then every `f` admits
a unique decomposition `f = g + r` with
1. `g ∈ I`, and
2. no term of `r` is divisible by any `LT gᵢ`.
-/
theorem normalForm_exists_unique
  {I : Ideal (MvPolynomial σ k)} {G : Finset (MvPolynomial σ k)}
  (hGB : IsGroebnerBasis m I G)
  (f : MvPolynomial σ k) :
  ExistsUnique (fun r : MvPolynomial σ k ↦
    (∃ g, g ∈ I ∧ f = g + r)
    ∧ ∀ c ∈ r.support, ∀ gi ∈ G, ¬ m.degree gi ≤ c) := by
  -- 1) **Existence**
  have h_unit : ∀ g ∈ G, IsUnit (m.leadingCoeff g) :=
    fun g hg => isUnit_leadingCoeff.mpr (hGB.1 g hg)
  obtain ⟨q, r, h_eq, -, h_rem⟩ := m.div_set h_unit f
  -- Define g as the quotient part and show g ∈ I
  let g := q.sum (fun b (coeff : MvPolynomial σ k) => coeff * b)
  have hgI : g ∈ I := by
    simp only [Finsupp.sum, Set.elem_mem, Finset.mem_val, g]
    have h_support_mem : ∀ b ∈ q.support, (b : MvPolynomial σ k) ∈ I :=
      fun b hb => hGB.2.1 b.2
    exact Submodule.sum_smul_mem I q h_support_mem
  refine ⟨r, ⟨⟨g, hgI, h_eq⟩, h_rem⟩, ?_⟩
  · -- **uniqueness**
    -- Suppose `r'` also works; then `f = g' + r'` and `r'` has no divisible LT–terms.
    rintro r' ⟨⟨g', hg'I, h_eq'⟩, h_rem'⟩
    by_contra hdiff
    have h_ne_zero : ¬(r - r' = 0) := by exact sub_ne_zero_of_ne fun a ↦ hdiff (id (Eq.symm a))
    have hrg : r - r' = g' - g := by
      rw [eq_sub_of_add_eq' (id (Eq.symm h_eq)), eq_sub_of_add_eq' (id (Eq.symm h_eq'))]
      exact sub_sub_sub_cancel_left g g' f
    have dI : r - r' ∈ I := by
      rw [hrg]
      exact (Submodule.sub_mem_iff_left I hgI).mpr hg'I
    have hlt_in : leadingTerm m (r - r') ∈ leadingTermIdeal m I := by
      unfold leadingTermIdeal
      apply Ideal.subset_span
      rw [LT_set]
      simp only [Set.mem_setOf_eq]
      exact ⟨r - r', dI, h_ne_zero, rfl⟩
    have hlm_in : monomial (m.degree (r - r')) 1 ∈ leadingTermIdeal m I := by
      rw [leadingTermIdeal_is_initialIdeal, initialIdeal]
      apply Ideal.subset_span
      simp only [Set.mem_image]
      refine ⟨m.degree (r - r'), ?_, rfl⟩
      rw [LM_set]
      exact ⟨r - r', dI, h_ne_zero, rfl⟩
    -- extract an exponent α dividing `m.degree d`
    classical
    have h_mono_mem : monomial (m.degree (r - r')) 1
      ∈ monomialIdeal k (G.image fun g => m.degree g) := by
        rw [IsGroebnerBasis.leadingTermIdeal_eq_monomialIdeal hGB] at hlm_in
        exact hlm_in
    rw [monomialIdeal, mem_ideal_span_monomial_image] at h_mono_mem
    specialize h_mono_mem (m.degree (r - r')) (by simp only [mem_support_iff, coeff_monomial,
      ↓reduceIte, ne_eq, one_ne_zero, not_false_eq_true])
    obtain ⟨d, hd_in_img, h_le⟩ := h_mono_mem
    rw [Finset.mem_coe, Finset.mem_image] at hd_in_img
    obtain ⟨g, hg_in_G, rfl⟩ := hd_in_img
    have h_deg_mem := MonomialOrder.degree_mem_support (m := m) h_ne_zero
    have h_union_mem := Finsupp.support_sub h_deg_mem
    rcases Finset.mem_union.mp h_union_mem with h_supp_r | h_supp_r'
    · exact h_rem (m.degree (r - r')) h_supp_r g hg_in_G h_le
    · exact h_rem' (m.degree (r - r')) h_supp_r' g hg_in_G h_le


/--
**§6 Corollary 2**
Let $G = \{g_1,\dots,g_t\}$ be a Gröbner basis for an ideal $I \subseteq k[x_1,\dots,x_n]$
and let $f \in k[x_1,\dots,x_n]$.
Then $f \in I$ if and only if the remainder on division of $f$ by $G$ is zero.
-/
theorem mem_Ideal_iff_GB_normalForm_eq_zero
  {I : Ideal (MvPolynomial σ k)} {G : Finset (MvPolynomial σ k)}
  (hGB : IsGroebnerBasis m I G)
  (f : MvPolynomial σ k) :
  f ∈ I ↔ normalForm m hGB.1 f = 0 := by
  -- The hypothesis that all elements of G are non-zero
  have hG_nonzero : ∀ g ∈ SetLike.coe G, g ≠ 0 := fun g hg => hGB.1 g hg
  -- The hypothesis that all elements of G have unit leading coefficients
  have hG_unit_lc : ∀ g ∈ SetLike.coe G, IsUnit (m.leadingCoeff g) := fun g hg =>
    isUnit_leadingCoeff.mpr (hG_nonzero g hg)
  -- The uniqueness of the remainder is key.
  have unique_rem := normalForm_exists_unique hGB f
  constructor
  · -- Direction (→): Assume `f ∈ I`. We must show its normal form is 0.
    intro hf_in_I
    -- We will show that `r = 0` is a valid remainder for `f`.
    -- According to `normalForm_exists_unique`, there can be only one such remainder.
    -- Since `normalForm ... f` is also a valid remainder, they must be equal.

    -- 1: The trivial decomposition `f = f + 0`.
    have P_zero : (∃ g, g ∈ I ∧ f = g + 0) ∧
        (∀ c ∈ (0 : MvPolynomial σ k).support, ∀ gi ∈ G, ¬ m.degree gi ≤ c) := by
      constructor
      · -- `f = g + 0` with `g ∈ I`. We can choose `g = f`.
        use f, hf_in_I
        simp
      · -- The remainder `0` has an empty support.
        simp
    -- 2: The decomposition given by the `normalForm` function.
    let r_n := normalForm m hG_nonzero f
    have P_normal : (∃ g, g ∈ I ∧ f = g + r_n) ∧
        (∀ c ∈ r_n.support, ∀ gi ∈ G, ¬ m.degree gi ≤ c) := by
      have spec := normalForm_spec m hG_nonzero f
      constructor
      · -- `f = g + r_n` with `g ∈ I`.
        let q_n := quotients m hG_nonzero f
        let g_n := q_n.sum fun i coeff => coeff • (i : MvPolynomial σ k)
        use g_n
        constructor
        · -- `g_n` ∈ `I`.
          apply Submodule.sum_smul_mem I
          intro i _
          exact hGB.2.1 i.2 -- i.2 is the proof that i.val ∈ G
        · -- `f = g_n + r_n` .
          exact spec.1
      · -- The remainder condition for `r_n`.
        exact spec.2.2
    -- unique_rem : ∃! r, P r
    obtain ⟨r₀, hr₀, hr_unique⟩ := unique_rem
    -- P_normal : P r_n
    have eq_rn_r0 : r_n = r₀ := hr_unique _ P_normal
    -- P_zero : P 0
    have eq_0_r0  : 0   = r₀ := hr_unique _ P_zero
    -- conclude r_n = 0
    exact eq_rn_r0.trans eq_0_r0.symm
  · -- Direction (←): Assume `normalForm m G hGB.1 f = 0`. We must show `f ∈ I`.
    intro h_norm_is_zero
    have spec := normalForm_spec m hG_nonzero f
    let q := quotients m hG_nonzero f
    let r := normalForm m hG_nonzero f
    let g := q.sum fun i coeff => coeff • (i : MvPolynomial σ k)
    -- The division equation is `f = g + r`.
    have h_div_eq := spec.1
    rw [h_norm_is_zero] at h_div_eq
    simp only [SetLike.coe_sort_coe, add_zero] at h_div_eq
    rw [h_div_eq]
    apply Submodule.sum_smul_mem I
    intro i _
    exact hGB.2.1 i.2

variable (m) in
/--
**(Cox, Little, O'Shea, Ch 2, §6, Theorem 6): Buchberger’s Criterion** :
Let `I` be a polynomial ideal and let `G` be a basis of `I` (i.e. `I =
ideal.span G`).
Then `G` is a Gröbner basis if and only if for  all pairs of distinct polynomials
`g₁, g₂ ∈ G`, the remainder on division of `S_polynomial g₁ g₂` by `G` is zero.
-/
theorem Buchberger_criterion
  {I : Ideal (MvPolynomial σ k)}
  {G : Finset (MvPolynomial σ k)}
  (hG : ∀ g ∈ G, g ≠ 0)
  (hGI : I = Ideal.span G) :
  IsGroebnerBasis m I G ↔
    (∀ g₁ ∈ G, ∀ g₂ ∈ G,
      g₁ ≠ g₂ → normalForm m hG (sPolynomial m g₁ g₂) = 0) := by
      have hG_sub_I : SetLike.coe G ⊆ I := by rw [hGI]; exact Ideal.subset_span
      constructor
      · -- (⇒)
        intro hGB g₁ hg₁ g₂ hg₂ hneq
        have hs : sPolynomial m g₁ g₂ ∈ I := sPolynomial_mem_ideal (hG_sub_I hg₁) (hG_sub_I hg₂)
        exact (mem_Ideal_iff_GB_normalForm_eq_zero hGB (m.sPolynomial g₁ g₂)).1 hs
      · -- (⇐) If all S-polynomials reduce to 0, then G is a Gröbner basis.
        intro hS_poly
        rw [IsGroebnerBasis]
        refine ⟨hG, hG_sub_I, ?_⟩
        by_cases hG_empty : G = ∅
        · simp only [hG_empty, Finset.coe_empty, Ideal.span_empty] at hGI
          rw [leadingTermIdeal, hGI, hG_empty, LT_set]
          simp only [Submodule.mem_bot, ne_eq, exists_eq_left, not_true_eq_false, leadingTerm_zero,
            false_and, Set.setOf_false, Ideal.span_empty]
          simp only [Finset.coe_empty, Set.image_empty, Ideal.span_empty]
        -- We need to show `leadingTermIdeal I = Ideal.span (LT(G))`.
        -- The inclusion `Ideal.span(LT(G)) ⊆ leadingTermIdeal I` is straightforward.
        apply le_antisymm
        · apply Ideal.span_mono
          intro lt_g h_lt_g_mem
          simp only [Set.mem_image] at h_lt_g_mem
          obtain ⟨g, hg_in_G, rfl⟩ := h_lt_g_mem
          refine Set.mem_setOf.mpr ?_
          use g
          exact ⟨by exact hG_sub_I hg_in_G, by exact hG g hg_in_G, rfl⟩
        -- The difficult inclusion: `leadingTermIdeal I ⊆ Ideal.span (LT(G))`.
        -- This means for any non-zero `f ∈ I`, we must show `LT(f) ∈ ⟨LT(G)⟩`.
        rw [leadingTermIdeal, Ideal.span_le]
        rintro _ ⟨f, hfI, hf_ne, rfl⟩
        have hfI' : f ∈ Ideal.span G := by simpa only [hGI] using hfI
        rcases (Submodule.mem_span_finset).1 hfI' with ⟨H, h_H_supp, h_f_eq⟩
        classical
        have h_image_nonempty_of_repr (H' : MvPolynomial σ k → MvPolynomial σ k) :
            (Finset.image (fun g ↦ m.degree (H' g * g)) G).Nonempty := by
          rw [Finset.image_nonempty]
          exact Finset.nonempty_of_ne_empty hG_empty
        let ℍ : ↥G →₀ MvPolynomial σ k :=
          Finsupp.onFinset G.attach
            (fun g => H g.val)
            (by
              intro g hg
              simp only [Finset.mem_attach])
        -- Representations of f using coefficients on G.attach
        have h_f_eq_ℍ : ∑ g ∈ G.attach, ℍ g * g.val = f := by
          simp only [ℍ, Finsupp.onFinset_apply]
          rw [Finset.sum_attach G (fun a => H a * a)]
          exact h_f_eq
        -- ============================================================
        -- δ-minimal representation
        -- ============================================================
        let Rep : Set (↥G →₀ MvPolynomial σ k) :=
          { h | (∑ g ∈ G.attach, h g * g.val) = f }
        -- "max degree (as syn) appearing in the representation h"
        let δOf (h : ↥G →₀ MvPolynomial σ k) : m.syn :=
          (G.attach).sup (fun g => m.toSyn (m.degree (h g * g.val)))
        let RepDegrees : Set m.syn := δOf '' Rep
        have hRep_nonempty : Rep.Nonempty := ⟨ℍ, h_f_eq_ℍ⟩
        clear h_f_eq_ℍ
        have hRepDegrees_nonempty : RepDegrees.Nonempty := hRep_nonempty.image δOf
        let δ_syn_min : m.syn :=
          WellFounded.min wellFounded_lt RepDegrees hRepDegrees_nonempty
        have hδ_syn_min_mem : δ_syn_min ∈ RepDegrees :=
          WellFounded.min_mem wellFounded_lt RepDegrees hRepDegrees_nonempty
        -- pick a representation h_min that achieves the minimal δ_syn
        rcases hδ_syn_min_mem with ⟨h_min, h_min_rep, hδ_min⟩
        have h_f_eq_min : (∑ g ∈ G.attach, h_min g * g.val) = f :=
          h_min_rep
        -- keep your δ_min definition if you need it later
        let δ_min : σ →₀ ℕ :=
          m.toSyn.symm δ_syn_min
        have hδ_syn : δ_syn_min = m.toSyn δ_min := by
          unfold δ_min
          simp only [AddEquiv.apply_symm_apply]
        -- degree(f) ≤ δ_syn_min
        have f_deg_le : m.toSyn (m.degree f) ≤ δ_syn_min := by
          have hf : f = ∑ g ∈ G.attach, h_min g * g.val := by
            simpa only using h_f_eq_min.symm
          rw [hf]
          have hdeg :
            m.toSyn (m.degree (∑ g ∈ G.attach, h_min g * g.val)) ≤ δOf h_min := by
              simpa only [Finset.sup_image, CompTriple.comp_eq] using (degree_sum_le (R := k))
          exact le_trans hdeg (le_of_eq hδ_min)
        -- termwise bound: each term degree ≤ δ_syn_min
        have h_le :
            ∀ g ∈ G.attach, m.toSyn (m.degree (h_min g * g.val)) ≤ δ_syn_min := by
          intro g hg
          have hg_mem :
              m.toSyn (m.degree (h_min g * g.val))
                ∈ (G.attach.image (m.toSyn ∘ fun g => m.degree (h_min g * g.val))) := by
            refine Finset.mem_image.2 ?_
            refine ⟨g, hg, rfl⟩
          have hle' :
              m.toSyn (m.degree (h_min g * g.val)) ≤ δOf h_min := by
            unfold δOf
            simpa only [id_eq, Finset.sup_image, CompTriple.comp_eq] using
              (Finset.le_sup (s := G.attach.image (m.toSyn ∘ fun g => m.degree (h_min g * g.val)))
                (f := id) (b := m.toSyn (m.degree (h_min g * g.val))) hg_mem)
          exact le_trans hle' (le_of_eq hδ_min)
        by_cases h_min_le_bot : δ_syn_min ≤ ⊥
        · have h_syn_min_eq_bot : δ_syn_min = ⊥ := le_bot_iff.mp h_min_le_bot
          have h_min_eq_bot :
              δ_min = 0 := (AddEquiv.map_eq_zero_iff m.toSyn.symm).mpr h_syn_min_eq_bot
          have f_deg_0 : (m.degree f) = 0 := by
            rw [h_syn_min_eq_bot] at f_deg_le
            rw [le_bot_iff] at f_deg_le
            exact (AddEquiv.map_eq_zero_iff m.toSyn).mp f_deg_le
          rw [leadingTerm, f_deg_0]
          have h_f_is_const : f = C (m.leadingCoeff f) := eq_C_of_degree_eq_zero f_deg_0
          rw [monomial_zero', SetLike.mem_coe]
          have g_deg_0 : ∀g ∈ G.attach, m.toSyn (m.degree (h_min g * g.val)) = 0 := by
            intro g hg
            rw [h_syn_min_eq_bot] at h_le
            exact (MonomialOrder.eq_zero_iff m).mpr (h_le g hg)
          have h_exists_nonzero_term : ∃ g ∈ G.attach, h_min g * g ≠ 0 := by
            have hsum_ne0 :
                (∑ g ∈ G.attach, h_min g * g.val) ≠ (0 : MvPolynomial σ k) := by
              simpa only [h_f_eq_min, ne_eq] using hf_ne
            rcases Finset.exists_ne_zero_of_sum_ne_zero hsum_ne0 with ⟨g, hg, hterm_ne0⟩
            exact ⟨g, hg, hterm_ne0⟩
          -- Now we have a `g` for which the term is non-zero.
          obtain ⟨g₀, hg₀_in_G, h_term_ne_zero⟩ := h_exists_nonzero_term
          --have : g₀
          rw [h_f_eq_min.symm]
          rw [MvPolynomial.C_eq_smul_one]
          have h_deg_g₀ : m.degree g₀.val = 0 := by
            -- We know the degree of the product is 0.
            have h_term_deg_zero : m.degree (h_min g₀ * g₀.val) = 0 := by
              exact (AddEquiv.map_eq_zero_iff m.toSyn).mp (g_deg_0 g₀ hg₀_in_G)
            -- The degree of a product is the sum of degrees (for non-zero polynomials).
            -- We need to show `h_min g₀` and `g₀` are non-zero.
            have h_g₀_ne_zero : g₀.val ≠ 0 := hG g₀.val g₀.property
            have h_h_min_g₀_ne_zero : h_min g₀ ≠ 0 := by
              -- If h_min g₀ = 0, then h_min g₀ * g₀ = 0, which contradicts `h_term_ne_zero`.
              contrapose! h_term_ne_zero
              rw [h_term_ne_zero, zero_mul]
            -- Now apply the degree of product rule.
            have h_deg_add := m.degree_mul h_h_min_g₀_ne_zero h_g₀_ne_zero
            rw [h_term_deg_zero] at h_deg_add
            have : m.degree (h_min g₀) = 0 ∧ m.degree g₀.val = 0 :=
              add_eq_zero.mp (by exact id (Eq.symm h_deg_add))
            exact this.2
          have hg₀_val_in_G : g₀.val ∈ G := by exact Finset.coe_mem g₀
          have h_unit_g₀ : IsUnit (m.leadingTerm g₀.val) := by
            rw [leadingTerm, h_deg_g₀]
            simp only [monomial_zero', isUnit_map_iff, isUnit_iff_ne_zero, ne_eq,
              leadingCoeff_eq_zero_iff]
            exact hG g₀.val hg₀_val_in_G
          have : Ideal.span ((fun g ↦ m.leadingTerm g) '' SetLike.coe G) = ⊤ := by
            apply Ideal.eq_top_of_isUnit_mem _ _ h_unit_g₀
            apply Ideal.subset_span
            exact Set.mem_image_of_mem (fun g ↦ m.leadingTerm g) hg₀_val_in_G
          rw [this]
          exact Submodule.mem_top
        -- Now, δ_syn_min > ⊥
        push_neg at h_min_le_bot
        by_cases h_const_ex : ∃ g ∈ G, m.degree g = 0
        · obtain ⟨g, ⟨hgG, hg_deg_zero⟩⟩ := h_const_ex
          have inI_top : Ideal.span (Finset.image (fun g ↦ m.leadingTerm g) G) = (⊤ : Ideal (MvPolynomial σ k)) := by
            have LTg_unit : IsUnit (m.leadingTerm g) := by
              rw [leadingTerm, hg_deg_zero, monomial_zero',isUnit_map_iff, isUnit_iff_ne_zero, ne_eq, leadingCoeff_eq_zero_iff]
              exact hG g hgG
            apply Ideal.eq_top_of_isUnit_mem _ _  LTg_unit
            apply Submodule.mem_span_of_mem
            simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe]
            use g
          simp only [SetLike.mem_coe]
          rw [Finset.coe_image] at inI_top
          rw [inI_top]
          exact trivial
        have h_const_non_ex:= h_const_ex; clear h_const_ex
        push_neg at h_const_non_ex
        -- If multideg(f) = δ equality occurs, then multideg(f) = multideg(hᵢgᵢ) for some i
        by_cases h_deg_eq_δ_syn : m.toSyn (m.degree f) = δ_syn_min
        · have h_sup_is_achieved : ∃ g ∈ G.attach, (m.toSyn (m.degree (h_min g * g.val))) = δ_syn_min := by
            by_contra h_not_achieved
            push_neg at h_not_achieved
            have h_g_lt_δ : ∀ g ∈ G.attach, m.toSyn (m.degree (h_min g * g.val)) < δ_syn_min  := by
              intro g hg
              apply lt_of_le_of_ne ?_ (h_not_achieved g hg)
              exact h_le g hg
            clear h_not_achieved
            rw [h_f_eq_min.symm] at h_deg_eq_δ_syn
            have h_deg_lt_δ : m.toSyn (m.degree (∑ g ∈ G.attach, h_min g * g.val)) < δ_syn_min := by
              apply LE.le.trans_lt m.degree_sum_le
              rw [@Finset.sup_lt_iff _ _ _ _ G.attach (fun i ↦ m.toSyn (m.degree (h_min i * i.val))) (δ_syn_min ) h_min_le_bot]
              exact h_g_lt_δ
            exact (Eq.not_lt h_deg_eq_δ_syn) h_deg_lt_δ
          obtain ⟨gᵢ,⟨hgᵢG, hgᵢ_δ_min_syn⟩⟩ := h_sup_is_achieved
          · -- have hgᵢ_δ_min : (m.degree (h_min gᵢ * gᵢ)) =  δ_min := by apply m.toSyn.injective; exact hgᵢ_δ_min_syn
            -- have h_deg_eq_δ : (m.degree f) = δ_min := by apply m.toSyn.injective; exact h_deg_eq_δ_syn
            have h_nzero_h_min_gᵢ : h_min gᵢ ≠ 0 := by
              by_contra h_zero_h_min_gᵢ
              rw [h_zero_h_min_gᵢ] at hgᵢ_δ_min_syn
              simp only [zero_mul, degree_zero, map_zero] at hgᵢ_δ_min_syn
              rw [←hgᵢ_δ_min_syn] at h_min_le_bot
              simp only [MonomialOrder.bot_eq_zero, lt_self_iff_false] at h_min_le_bot
            have : m.leadingTerm f = m.leadingTerm (h_min gᵢ * gᵢ.val) * C ((m.leadingCoeff f) * (m.leadingCoeff (h_min gᵢ * gᵢ.val))⁻¹):= by
              rw [leadingTerm, leadingTerm, mul_comm]
              rw [MvPolynomial.C_mul_monomial, mul_assoc]
              --nth_rw 2 [mul_comm]
              rw [leadingCoeff_mul h_nzero_h_min_gᵢ (hG gᵢ (Finset.coe_mem gᵢ)), mul_inv_rev, mul_assoc]
              nth_rw 3 [←mul_assoc]
              rw [inv_mul_cancel₀ (by exact leadingCoeff_ne_zero_iff.mpr h_nzero_h_min_gᵢ), one_mul]
              rw [inv_mul_cancel₀ (by exact leadingCoeff_ne_zero_iff.mpr (hG gᵢ (Finset.coe_mem gᵢ))), mul_one]
              have hgᵢ_δ_min : (m.degree (h_min gᵢ * gᵢ.val)) =  δ_min := by
                apply m.toSyn.injective; rw [AddEquiv.apply_symm_apply]; exact hgᵢ_δ_min_syn
              have h_deg_eq_δ : (m.degree f) = δ_min := by
                apply m.toSyn.injective; rw [AddEquiv.apply_symm_apply]; exact h_deg_eq_δ_syn
              rw [hgᵢ_δ_min, h_deg_eq_δ]
            rw [this]
            apply Ideal.mul_mem_right
            rw [leadingTerm_mul (h_nzero_h_min_gᵢ) (hG gᵢ (Finset.coe_mem gᵢ))]
            apply Ideal.mul_mem_left
            apply Submodule.mem_span_of_mem
            simp only [Set.mem_image, SetLike.mem_coe]
            exact ⟨gᵢ, ⟨Finset.coe_mem gᵢ, rfl⟩⟩
        · have f_deg_lt : m.toSyn (m.degree f) < δ_syn_min := by
            apply (LE.le.lt_iff_ne' f_deg_le).mpr (by exact fun a ↦ h_deg_eq_δ_syn (id (Eq.symm a)))
          clear f_deg_le; clear h_deg_eq_δ_syn
          /- We will use Rem(S(gi, gj), G) = 0 for i ̸= j to find
            a new expression for f that decreases δ.
            This will contradict the minimality of δ and complete the proof-/
          -- STEP 1: Decompose f into P₁, P₂, P₃
          let G_δ := G.attach.filter (fun g => m.toSyn (m.degree (h_min g * g.val)) = δ_syn_min)
          have h_f_split : f = (∑ g ∈ G_δ, h_min g * g) + (∑ g ∈ G.attach \ G_δ, h_min g * g) := by
            rw [h_f_eq_min.symm]
            have G_sep : G.attach = G_δ ∪ (G.attach \ G_δ) := by
              refine Eq.symm (Finset.union_sdiff_of_subset ?_)
              exact Finset.filter_subset (fun g ↦ m.toSyn (m.degree (h_min g * g.val)) = δ_syn_min) G.attach
            nth_rw 1 [G_sep]
            rw [Finset.sum_union (by exact Finset.disjoint_sdiff)]
          have h_sdiff : G.attach \ G_δ = G.attach.filter (fun g => m.toSyn (m.degree (h_min g * g.val)) < δ_syn_min) := by
            dsimp only [G_δ]
            -- We also know `m.degree (h_min g * g) ≼[m] δ_min` because δ_min is the maximum.
            have h_le : ∀ g ∈ G.attach, m.toSyn (m.degree (h_min g * g.val)) ≤ δ_syn_min := by
              intro g hg
              rw [←hδ_min]
              unfold δOf
              have hg_mem :
                m.toSyn (m.degree (h_min g * g.val))
                  ∈ (G.attach.image (m.toSyn ∘ fun g => m.degree (h_min g * g.val))) := by
                refine Finset.mem_image.2 ?_
                exact ⟨g, hg, rfl⟩
              exact @Finset.le_sup _ _ _ _ _ (m.toSyn ∘ fun g ↦ m.degree (h_min g * g.val)) _ (by simp only [Finset.mem_attach])
            ext g
            -- We use `Finset.mem_filter` and `Finset.mem_sdiff` to simplify the goal.
            simp only [Finset.mem_filter, Finset.mem_sdiff]
            constructor
            · -- Direction (→): Assume `g ∈ G \ G_δ`.
              intro h_left
              -- `h_left` is `⟨g ∈ G, g ∉ G_δ⟩`.
              -- We need to prove `g ∈ G` (which is `h_left.1`) and `m.toSyn (d g) < δ_syn_min`.
              refine ⟨h_left.1, ?_⟩
              -- We know `g ∉ G_δ`, which means `¬(m.toSyn (d g) = δ_syn_min)`.
              have h_ne : ¬ (m.toSyn (m.degree (h_min g * g.val)) = δ_syn_min) := by
                simp only [not_and] at h_left
                apply h_left.2 h_left.1
              -- `a ≤ b` and `a ≠ b` implies `a < b` for a linear order.
              exact lt_of_le_of_ne (h_le g h_left.1) h_ne
            · -- Direction (←): Assume `g ∈ G.filter (...)`.
              intro h_right
              -- `h_right` is `⟨g ∈ G, m.toSyn (d g) < δ_syn_min⟩`.
              -- We need to prove `g ∈ G \ G_δ`, which is `g ∈ G` and `g ∉ G_δ`.
              refine ⟨h_right.1, ?_⟩
              -- To show `g ∉ G_δ`, we need to show `¬(m.toSyn (d g) = δ_syn_min)`.
              -- This follows directly from `m.toSyn (d g) < δ_syn_min`.
              simp only [not_and]
              intro hg
              exact ne_of_lt h_right.2
          have h_h_min_decomp :
              ∀ g, h_min g = leadingTerm m (h_min g) + (h_min g - leadingTerm m (h_min g)) := by
            intro g
            exact (add_sub_cancel _ _).symm
          let P₁ := ∑ g ∈ G_δ, leadingTerm m (h_min g) * g
          let P₂ := ∑ g ∈ G_δ, (h_min g - leadingTerm m (h_min g)) * g
          let P₃ := ∑ g ∈ G.attach \ G_δ, h_min g * g
          have h_f_is_P123 : f = P₁ + P₂ + P₃ := by
            -- Start with the split sum for f.
            rw [h_f_split]
            unfold P₁ P₂ P₃
            -- The goal is now `(a + b) + c = a + b + c`, which is true by associativity.
            rw [add_left_inj]
            rw [←Finset.sum_add_distrib]
            apply Finset.sum_congr rfl
            intro x
            rw [sub_mul]
            exact fun a ↦ Eq.symm (add_sub_cancel (m.leadingTerm (h_min x) * x) (h_min x * x))
          have hG_δ_deg : ∀ g ∈ G_δ, m.toSyn (m.degree (h_min g * g.val)) = δ_syn_min := by
            intro g hg
            simp only [G_δ, Finset.mem_filter] at hg
            exact hg.2
          have h_P₃term_deg_lt :
              ∀ g ∈ G.attach \ G_δ, m.toSyn (m.degree (h_min g * g.val)) < δ_syn_min := by
            intro g hg_sdiff
            rw [h_sdiff] at hg_sdiff
            simp only [Finset.mem_filter] at hg_sdiff
            exact hg_sdiff.2
          have hP₃_deg_lt : m.toSyn (m.degree P₃) < δ_syn_min := by
            unfold P₃
            apply lt_of_le_of_lt m.degree_sum_le
            rw [Finset.sup_lt_iff h_min_le_bot]
            exact h_P₃term_deg_lt
          have h_P₂term_deg_lt :
              ∀ g ∈ G_δ, m.toSyn (m.degree ((h_min g - leadingTerm m (h_min g)) * g.val)) < δ_syn_min := by
            intro g hg_in_G_δ
            -- We need `h_min g` to be non-zero to use `degree_sub_LTerm_lt`.
            have h_h_min_g_ne_zero : h_min g ≠ 0 := by
              -- If `h_min g` were zero, deg(0*g)=0, so `δ_syn_min` would be 0, contradicting `h_min_le_bot`.
              intro h_h_zero
              have hg_prop := (Finset.mem_filter.mp hg_in_G_δ).2
              rw [h_h_zero, zero_mul, degree_zero, map_zero] at hg_prop
              exact not_le_of_gt h_min_le_bot (le_of_eq hg_prop.symm)
            -- We consider two cases for the degree of `h_min g`.
            by_cases h_deg_h_min_g_zero : m.degree (h_min g) = 0
            · -- Case 1: `deg(h_min g) = 0`.
              -- Then `h_min g` is a constant, so `h_min g = LT(h_min g)`.
              have : h_min g = leadingTerm m (h_min g) := by
                rw [eq_C_of_degree_eq_zero h_deg_h_min_g_zero, leadingTerm_C]
              rw [this]
              rw [sub_eq_zero_of_eq (congrArg m.leadingTerm this)]
              simp only [zero_mul, degree_zero, map_zero, gt_iff_lt]
              exact h_min_le_bot
            · -- Case 2: `deg(h_min g) ≠ 0`.
              -- Now we can use `degree_sub_LTerm_lt`.
              have h_sub_lt : m.degree (h_min g - leadingTerm m (h_min g)) ≺[m] m.degree (h_min g) :=
                degree_sub_LTerm_lt h_deg_h_min_g_zero
              by_cases h_sub_zero : (h_min g - leadingTerm m (h_min g)) = 0
              · rw [h_sub_zero, zero_mul, degree_zero, map_zero]
                exact h_min_le_bot
              · rw [←(hG_δ_deg g hg_in_G_δ)]
                rw [degree_mul h_sub_zero (hG g (by simp only [Finset.coe_mem]))]
                rw [degree_mul h_h_min_g_ne_zero (hG g (by simp only [Finset.coe_mem]))]
                simp only [map_add, add_lt_add_iff_right, gt_iff_lt]
                exact h_sub_lt
          have hP₂_deg_lt : m.toSyn (m.degree P₂) < δ_syn_min := by
            unfold P₂
            apply lt_of_le_of_lt m.degree_sum_le
            rw [Finset.sup_lt_iff h_min_le_bot]
            exact h_P₂term_deg_lt
          have hP₁_deg_lt : m.toSyn (m.degree P₁) < δ_syn_min := by
            have h_P1_eq_sub : P₁ = f - (P₂ + P₃) := by
              rw [h_f_is_P123, add_sub_add_right_eq_sub, add_sub_cancel_right]
            rw [h_P1_eq_sub]
            have hP₂' : m.toSyn (m.degree P₂) < m.toSyn δ_min := by
              simpa only [hδ_syn] using hP₂_deg_lt
            have hP₃' : m.toSyn (m.degree P₃) < m.toSyn δ_min := by
              simpa only [hδ_syn] using hP₃_deg_lt
            have hsum' : m.toSyn (m.degree (P₂ + P₃)) < m.toSyn δ_min :=
              m.degree_add_lt_of_le_lt (δ := δ_min) hP₂' hP₃'
            have h_deg_P₂_plus_P₃_lt : m.toSyn (m.degree (P₂ + P₃)) < δ_syn_min := by
              simpa only [hδ_syn] using hsum'
            apply lt_of_le_of_lt (m.degree_sub_le)
            rw [max_lt_iff]
            exact ⟨f_deg_lt, h_deg_P₂_plus_P₃_lt⟩
          -- STEP 2: Rewrite P₁ using the sPolynomial_decomposition Lemma.
          -- let ι := ↥G_δ
          have LT_hᵢi_ne_zero : ∀ i : G_δ, m.leadingTerm (h_min i.1) * i.1 ≠ 0 := by
            intro i
            apply mul_ne_zero
            · -- First goal: `leadingTerm m (h_min i.val) ≠ 0`.
              -- This is equivalent to `h_min i.val ≠ 0`.
              intro LT_h_min_i_ne_zero
              have : (h_min ↑i) = 0 := by rw [←leadingTerm_eq_zero_iff]; exact LT_h_min_i_ne_zero
              unfold Subtype.val at this
              have hi_in_G_δ : i.1 ∈ G_δ := by exact Finset.coe_mem i
              -- By definition of `G_δ`, `m.toSyn (m.degree (h_min i.val * i.val)) = δ_syn_min`.
              have h_deg_is_δ := (Finset.mem_filter.mp hi_in_G_δ).2
              -- Substitute `h_min i.val = 0` into this.
              rw [this, zero_mul, degree_zero, map_zero] at h_deg_is_δ
              -- Now we have `δ_syn_min = 0`.
              -- This contradicts `h_min_le_bot : ⊥ < δ_syn_min`.
              exact not_le_of_gt h_min_le_bot (le_of_eq h_deg_is_δ.symm)
            · -- Second goal: `i.val ≠ 0`.
              -- This is true because `i.val ∈ G_δ ⊆ G`.
              have hi_in_G : i.val ∈ G.attach := (Finset.mem_filter.mp i.property).1
              exact hG i.val (by simp only [Finset.coe_mem])
          let gδ : (↥G) → MvPolynomial σ k :=
            fun b => m.leadingTerm (h_min b) * (b : MvPolynomial σ k)
          -- have hP₁_eq_sum_gδ : P₁ = ∑ b ∈ G_δ, gδ b := by rfl
          have hd :
              ∀ b ∈ G_δ, (m.toSyn (m.degree (gδ b)) = δ_syn_min) ∨ gδ b = 0 := by
            intro b hb
            -- hb : b ∈ G_δ = filter ...
            have hbdeg :
                m.toSyn (m.degree (h_min b * (b : MvPolynomial σ k))) = δ_syn_min :=
              (Finset.mem_filter.mp hb).2
            left
            simpa only [gδ, degree_leadingTerm_mul] using hbdeg
          have hfd :
              (m.toSyn <| m.degree <| ∑ b ∈ G_δ, gδ b) < δ_syn_min := by
            simpa only [P₁, gδ] using hP₁_deg_lt
          rcases m.sPolynomial_decomposition' (R := k) (d := δ_syn_min)
              (B := G_δ) (g := gδ) hd hfd with ⟨c, hP₁_decomp⟩
          -- rewrite it as a statement about P₁
          -- have hP₁_decomp' :
          --     P₁ =
          --       ∑ b₁ ∈ G_δ, ∑ b₂ ∈ G_δ,
          --         (c b₁ b₂) • m.sPolynomial (gδ b₁) (gδ b₂) := by
          --   simpa only [P₁, gδ] using hP₁_decomp
          have hP₁_decomp_prod :
              P₁ =
                ∑ ij ∈ G_δ.product G_δ,
                  (c ij.1 ij.2) • m.sPolynomial (gδ ij.1) (gδ ij.2) := by
            simpa only [Finset.product_eq_sprod, Finset.sum_product] using hP₁_decomp
          let Pairs : Finset (↥G × ↥G) := G_δ.product G_δ
          let Sij (i j : ↥G) : MvPolynomial σ k :=
            m.sPolynomial (i : MvPolynomial σ k) (j : MvPolynomial σ k)
          -- mono_factor i j = μ_{ij}
          -- μ_{ij} = monomial( δ_min - (deg(i) ⊔ deg(j)), lc(h_min(i)) * lc(h_min(j)) )
          let mono_factor (i j : ↥G) : MvPolynomial σ k :=
            monomial (δ_min - (m.degree (i : MvPolynomial σ k) ⊔ m.degree (j : MvPolynomial σ k)))
              (m.leadingCoeff (h_min i) * m.leadingCoeff (h_min j))
          -- Aij i j = A_{ij}  (quotient coefficients from division algorithm)
          -- S_{ij} = ∑_{g∈G} A_{ij}(g) * g
          let Aij (i j : ↥G) : (↥G →₀ MvPolynomial σ k) :=
            quotients m hG (Sij i j)
          -- Bij i j = B_{ij}  (scaled coefficients)
          -- B_{ij}(g) = μ_{ij} * A_{ij}(g)
          -- so μ_{ij} * S_{ij} = ∑_{g∈G} B_{ij}(g) * g
          let Bij (i j : ↥G) : (↥G →₀ MvPolynomial σ k) :=
            (Aij i j).mapRange (fun p => mono_factor i j * p) (by simp only [mul_zero])
          have h_sPoly_gδ_eq
            (i j : ↥G) (hi : i ∈ G_δ) (hj : j ∈ G_δ) :
            m.sPolynomial (gδ i) (gδ j) = mono_factor i j * Sij i j := by
            -- (1) deg(h_min i * i) = δ_min, deg(h_min j * j) = δ_min
            have hdeg_prod_i : m.degree (h_min i * (i : MvPolynomial σ k)) = δ_min := by
              apply m.toSyn.injective
              rw [AddEquiv.apply_symm_apply]
              exact (Finset.mem_filter.mp hi).2
            have hdeg_prod_j : m.degree (h_min j * (j : MvPolynomial σ k)) = δ_min := by
              apply m.toSyn.injective
              rw [AddEquiv.apply_symm_apply]
              exact (Finset.mem_filter.mp hj).2
            -- (2) h_min i, h_min j ≠ 0
            have hhi : h_min i ≠ 0 := by
              intro h0
              have hδ := (Finset.mem_filter.mp hi).2
              have hδ0 : (δ_syn_min : m.syn) = 0 := by
                have : (0 : m.syn) = δ_syn_min := by
                  simpa only [h0, zero_mul, degree_zero, map_zero] using hδ
                simpa only using this.symm
              have : (δ_syn_min : m.syn) ≤ ⊥ := by
                simp only [hδ0, bot_eq_zero, le_refl]
              exact not_le_of_gt h_min_le_bot this
            have hhj : h_min j ≠ 0 := by
              intro h0
              have hδ := (Finset.mem_filter.mp hj).2
              have hδ0 : (δ_syn_min : m.syn) = 0 := by
                have : (0 : m.syn) = δ_syn_min := by
                  simpa only [h0, zero_mul, degree_zero, map_zero] using hδ
                simpa only using this.symm
              have : (δ_syn_min : m.syn) ≤ ⊥ := by
                simp only [hδ0, bot_eq_zero, le_refl]
              exact not_le_of_gt h_min_le_bot this
            -- (3) i, j ≠ 0
            have hi0 : (i : MvPolynomial σ k) ≠ 0 := hG _ i.property
            have hj0 : (j : MvPolynomial σ k) ≠ 0 := hG _ j.property
            have hdeg_prod_i : m.degree (h_min i * (i : MvPolynomial σ k)) = δ_min := by
              apply m.toSyn.injective
              rw [AddEquiv.apply_symm_apply]
              exact (Finset.mem_filter.mp hi).2
            have hdeg_prod_j : m.degree (h_min j * (j : MvPolynomial σ k)) = δ_min := by
              apply m.toSyn.injective
              rw [AddEquiv.apply_symm_apply]
              exact (Finset.mem_filter.mp hj).2
            have hdeg_add_i :
                m.degree (h_min i) + m.degree (i : MvPolynomial σ k) = δ_min := by
              have hm :
                  m.degree (h_min i * (i : MvPolynomial σ k)) =
                    m.degree (h_min i) + m.degree (i : MvPolynomial σ k) :=
                degree_mul hhi hi0
              simpa only [hdeg_prod_i] using hm.symm
            have hdeg_add_j :
                m.degree (h_min j) + m.degree (j : MvPolynomial σ k) = δ_min := by
              have hm :
                  m.degree (h_min j * (j : MvPolynomial σ k)) =
                    m.degree (h_min j) + m.degree (j : MvPolynomial σ k) :=
                degree_mul hhj hj0
              simpa only [hdeg_prod_j] using hm.symm
            have hsup :
                (m.degree (h_min i) + m.degree (i : MvPolynomial σ k)) ⊔
                (m.degree (h_min j) + m.degree (j : MvPolynomial σ k)) = δ_min := by
              simp only [hdeg_add_i, hdeg_add_j, le_refl, sup_of_le_left]
            calc
              m.sPolynomial (gδ i) (gδ j)
                  =
                monomial
                  (((m.degree (h_min i) + m.degree (i : MvPolynomial σ k)) ⊔
                    (m.degree (h_min j) + m.degree (j : MvPolynomial σ k)))
                    - (m.degree (i : MvPolynomial σ k) ⊔ m.degree (j : MvPolynomial σ k)))
                  (m.leadingCoeff (h_min i) * m.leadingCoeff (h_min j))
                * m.sPolynomial (i : MvPolynomial σ k) (j : MvPolynomial σ k) := by
                  -- gδ = leadingTerm * i, leadingTerm = monomial deg lc
                  dsimp [gδ]
                  simpa [leadingTerm, Sij] using
                    (sPolynomial_monomial_mul (m := m)
                      (p₁ := (i : MvPolynomial σ k)) (p₂ := (j : MvPolynomial σ k))
                      (d₁ := m.degree (h_min i)) (d₂ := m.degree (h_min j))
                      (c₁ := m.leadingCoeff (h_min i)) (c₂ := m.leadingCoeff (h_min j)))
              _ =
                monomial
                  (δ_min - (m.degree (i : MvPolynomial σ k) ⊔ m.degree (j : MvPolynomial σ k)))
                  (m.leadingCoeff (h_min i) * m.leadingCoeff (h_min j))
                * m.sPolynomial (i : MvPolynomial σ k) (j : MvPolynomial σ k) := by
                  rw [hsup]
              _ = mono_factor i j * Sij i j := by
                  rfl
          -- Step 2: Formalize (6) and (7) from the textbook.
          -- For any S-polynomial S(gᵢ,gⱼ), since its normal form is 0, the division algorithm
          -- gives us a representation with a good degree property.
          have h_S_poly_gᵢ_gⱼ_repr
              (i j : ↥G_δ) (h_ne : i.val ≠ j.val) :
              let gᵢ := i.val; let gⱼ := j.val
              let S_poly := m.sPolynomial gᵢ gⱼ
              let A := quotients m hG S_poly
              S_poly = A.sum (fun (g : ↥G) (q : MvPolynomial σ k) => q * g.val) ∧
              (∀ (gₗ : ↥G), m.degree (gₗ.val * A gₗ) ≼[m] m.degree S_poly) := by
            intro gᵢ gⱼ S_poly A
            have hgᵢ : (gᵢ : MvPolynomial σ k) ∈ G := by
              simpa only using i.val.property
            have hgⱼ : (gⱼ : MvPolynomial σ k) ∈ G := by
              simpa only using j.val.property
            specialize hS_poly gᵢ hgᵢ gⱼ hgⱼ (Subtype.coe_ne_coe.mpr h_ne)
            have h_spec := normalForm_spec m hG S_poly
            rw [hS_poly] at h_spec
            simp only [add_zero] at h_spec
            have h_repr_eq :
                S_poly = A.sum (fun (g : ↥G) (h : MvPolynomial σ k) => h * g.val) := by
              rw [h_spec.1]
              rfl
            exact ⟨h_repr_eq, h_spec.2.1⟩
          have γ_le_δ (i : G_δ) (j : G_δ)
            :
            let gᵢ := i.val; let gⱼ := j.val
            m.degree gᵢ.val ⊔ m.degree gⱼ.val ≤ δ_min:= by
            intro gᵢ gⱼ
            simp only [sup_le_iff]
            have h_deg_prod_i : m.degree (h_min i.val * i.val.val) = δ_min := by
              apply m.toSyn.injective
              rw [AddEquiv.apply_symm_apply]
              exact (Finset.mem_filter.mp i.property).2
            have h_deg_prod_j : m.degree (h_min j.val * j.val.val) = δ_min := by
              apply m.toSyn.injective
              rw [AddEquiv.apply_symm_apply]
              exact (Finset.mem_filter.mp j.property).2
            constructor
            · rw [←h_deg_prod_i, degree_mul]
              · exact le_add_self
              · intro h_h_min_i_zero
                have h_deg_is_δ := (Finset.mem_filter.mp i.property).2
                rw [h_h_min_i_zero, zero_mul, degree_zero, map_zero] at h_deg_is_δ
                exact not_le_of_gt h_min_le_bot (le_of_eq h_deg_is_δ.symm)
              · exact hG i.val (by simp only [Finset.coe_mem])
            · rw [←h_deg_prod_j, degree_mul]
              · exact le_add_self
              · intro h_h_min_j_zero
                have h_deg_is_δ := (Finset.mem_filter.mp j.property).2
                rw [h_h_min_j_zero, zero_mul, degree_zero, map_zero] at h_deg_is_δ
                exact not_le_of_gt h_min_le_bot (le_of_eq h_deg_is_δ.symm)
              · exact hG j.val ((by simp only [Finset.coe_mem]))
          -- Right inequality part of (9)
          -- We don't need (h_ne : ij.1.val ≠ ij.2.val) here
          have h_γ_S_poly_gᵢ_gⱼ_deg_lt (i : G_δ) (j : G_δ) :
            let gᵢ := i.val; let gⱼ := j.val
            let mono_factor := monomial (δ_min - (m.degree gᵢ.val ⊔ m.degree gⱼ.val)) 1
            let S_gij := m.sPolynomial gᵢ (gⱼ : MvPolynomial σ k)
            m.toSyn (m.degree (mono_factor * S_gij)) < δ_syn_min := by
              intro gᵢ gⱼ mono_factor S_gij
              let A_ij := quotients m hG S_gij
              by_cases S_poly_zero : S_gij = 0
              · dsimp only [Set.elem_mem, Lean.Elab.WF.paramLet, S_gij] at *
                rw [S_poly_zero]
                simp only [mul_zero, degree_zero, map_zero, gt_iff_lt]
                exact h_min_le_bot
              have S_poly_nezero : S_gij ≠ 0 := S_poly_zero
              clear S_poly_zero
              have h_mono_ne_zero : mono_factor ≠ 0 := by rw [Ne, MvPolynomial.monomial_eq_zero]; exact one_ne_zero
              apply lt_of_le_of_lt degree_mul_le
              have mon_deg_δ_min : m.degree ((monomial δ_min) (1:k) ) = δ_min := by
                rw [degree_monomial]
                simp only [one_ne_zero, ↓reduceIte]
              have h1 : m.degree ((monomial (δ_min - m.degree (i : MvPolynomial σ k) ⊔ m.degree (j : MvPolynomial σ k))) (1 : k))
                = m.degree ((monomial (δ_min)) (1 : k)) - m.degree (i : MvPolynomial σ k) ⊔ m.degree (j : MvPolynomial σ k) := by
                rw [mon_deg_δ_min]
                repeat rw [degree_monomial]
                repeat simp only [one_ne_zero, ↓reduceIte]
              rw [h1]
              rw [mon_deg_δ_min]
              rw [hδ_syn]
              have rw_δ_min : (δ_min - m.degree i.val.val ⊔ m.degree j.val.val) + m.degree i.val.val ⊔ m.degree j.val.val = δ_min := by
                rw [tsub_add_cancel_iff_le]
                exact γ_le_δ i j
              nth_rw 2 [←rw_δ_min]
              rw [map_add, map_add]
              simp only [add_lt_add_iff_left, gt_iff_lt]
              apply degree_sPolynomial_lt_sup_degree S_poly_nezero
          by_cases h_γ_zero :
              ∃ (i : ↥G_δ) (j : ↥G_δ),
                m.toSyn (m.degree i.val.val ⊔ m.degree j.val.val) = 0
          · rcases h_γ_zero with ⟨i, j, hij_γ_is_zero⟩
            have h_sup_is_zero : m.degree i.val.val ⊔ m.degree j.val.val = 0 := by
              apply m.toSyn.injective
              -- goal: m.toSyn(...) = m.toSyn 0
              simpa only [map_zero, EmbeddingLike.map_eq_zero_iff] using hij_γ_is_zero
            -- The sup of two multidegrees is 0 iff both are 0.
            have h_degs_are_zero : m.degree i.val.val = 0 ∧ m.degree j.val.val = 0 := by
              constructor
              · have h_le_sup := @le_sup_left _ _ (m.degree i.val.val) (m.degree j.val.val)
                rw [h_sup_is_zero] at h_le_sup
                exact le_bot_iff.mp h_le_sup
              · have h_le_sup := @le_sup_right _ _ (m.degree i.val.val) (m.degree j.val.val)
                rw [h_sup_is_zero] at h_le_sup
                exact le_bot_iff.mp h_le_sup
            have h_deg_i_is_zero : m.degree i.val.val = 0 := h_degs_are_zero.1
            have h_i_in_G : (i.val : MvPolynomial σ k) ∈ G := i.val.property
            exact False.elim (h_const_non_ex i.val h_i_in_G h_deg_i_is_zero)
          have hγ_nonzero := h_γ_zero; clear h_γ_zero; push_neg at hγ_nonzero
          have h_mono_mul_Sij_repr
              (i j : ↥G_δ)
              (h_ne : i.val ≠ j.val) :
              mono_factor i.val j.val * Sij i.val j.val =
                (Bij i.val j.val).sum (fun g q => q * g.val) := by
            have hrepr :
                Sij i.val j.val =
                  (Aij i.val j.val).sum (fun g q => q * g.val) :=
              (h_S_poly_gᵢ_gⱼ_repr i j h_ne).1
            calc
              mono_factor i.val j.val * Sij i.val j.val
                  =
                mono_factor i.val j.val *
                  (Aij i.val j.val).sum (fun g q => q * g.val) := by
                rw [hrepr]
              _ =
                (Aij i.val j.val).sum
                  (fun g q => mono_factor i.val j.val * (q * g.val)) := by
                rw [Finsupp.mul_sum]
              _ =
                (Aij i.val j.val).sum
                  (fun g q => (mono_factor i.val j.val * q) * g.val) := by
                simp [mul_assoc]
              _ =
                (Bij i.val j.val).sum (fun g q => q * g.val) := by
                simp [Bij, Finsupp.sum_mapRange_index, mul_assoc]
          have h_Blg_lt_δ
            (i j : ↥G_δ)
            (h_ne : i.val ≠ j.val)
            (hγ : m.toSyn (m.degree i.val.val ⊔ m.degree j.val.val) ≠ 0) :
            ∀ gₗ : ↥G, m.degree (gₗ.val * Bij i.val j.val gₗ) ≺[m] δ_min := by
            classical
            intro gₗ
            set iG : ↥G := i.val with hiG
            set jG : ↥G := j.val with hjG
            set S : MvPolynomial σ k := Sij iG jG with hSdef
            set mono : MvPolynomial σ k := mono_factor iG jG with hmonodef
            set A : ↥G →₀ MvPolynomial σ k := Aij iG jG with hAdef
            set B : ↥G →₀ MvPolynomial σ k := Bij iG jG with hBdef
            -- γ := deg(i) ⊔ deg(j)
            let γdeg : σ →₀ ℕ := m.degree (iG : MvPolynomial σ k) ⊔ m.degree (jG : MvPolynomial σ k)
            have hγle : γdeg ≤ δ_min := by
              -- γ_le_δ i j : m.degree i.val.val ⊔ m.degree j.val.val ≤ δ_min
              simpa only [hiG, hjG, sup_le_iff, γdeg] using γ_le_δ i j
            have hδ : (δ_min - γdeg) + γdeg = δ_min := by
              exact tsub_add_cancel_of_le hγle
            ------------------------------------------------------------------
            -- h_min iG ≠ 0, h_min jG ≠ 0  (Use i,j ∈ G_δ)
            ------------------------------------------------------------------
            have h_hmin_i : h_min iG ≠ 0 := by
              intro h0
              have hiδ :
                  m.toSyn (m.degree (h_min iG * (iG : MvPolynomial σ k))) = δ_syn_min := by
                simpa only [hiG] using (Finset.mem_filter.mp i.property).2
              have : (δ_syn_min : m.syn) ≤ ⊥ := by
                have : δ_syn_min = 0 := by
                  have : (0 : m.syn) = δ_syn_min := by
                    simpa only [h0, zero_mul, degree_zero, map_zero] using hiδ
                  exact this.symm
                simp only [this, bot_eq_zero, le_refl]
              exact not_le_of_gt h_min_le_bot this
            have h_hmin_j : h_min jG ≠ 0 := by
              intro h0
              have hjδ :
                  m.toSyn (m.degree (h_min jG * (jG : MvPolynomial σ k))) = δ_syn_min := by
                simpa only [hjG] using (Finset.mem_filter.mp j.property).2
              have : (δ_syn_min : m.syn) ≤ ⊥ := by
                have : δ_syn_min = 0 := by
                  have : (0 : m.syn) = δ_syn_min := by
                    simpa only [h0, zero_mul, degree_zero, map_zero] using hjδ
                  exact this.symm
                simp only [this, bot_eq_zero, le_refl]
              exact not_le_of_gt h_min_le_bot this
            have hcoeff :
                (m.leadingCoeff (h_min iG) * m.leadingCoeff (h_min jG)) ≠ (0 : k) := by
              have hi_lc : m.leadingCoeff (h_min iG) ≠ (0 : k) :=
                (leadingCoeff_eq_zero_iff).not.mpr h_hmin_i
              have hj_lc : m.leadingCoeff (h_min jG) ≠ (0 : k) :=
                (leadingCoeff_eq_zero_iff).not.mpr h_hmin_j
              exact mul_ne_zero hi_lc hj_lc
            have hmono : mono ≠ 0 := by
              -- mono = monomial(...) (lc(h_min iG)*lc(h_min jG))
              -- monomial=0 ↔ coeff=0
              simp only [ne_eq, monomial_eq_zero, hcoeff, not_false_eq_true, mono, mono_factor]
            have hdeg_mono : m.degree mono = δ_min - γdeg := by
              -- degree(monomial d c)=d if c≠0
              simp only [degree_monomial, hcoeff, ↓reduceIte, mono, mono_factor, γdeg]
            ------------------------------------------------------------------
            -- B g = mono * A g, and gₗ*B gₗ = mono*(gₗ*A gₗ)
            ------------------------------------------------------------------
            have hB_apply : B gₗ = mono * A gₗ := by
              simp only [Finsupp.mapRange_apply, B, Bij, mono_factor, Aij, mono, A]
            have hmul : gₗ.val * B gₗ = mono * (gₗ.val * A gₗ) := by
              -- gₗ * (mono*A) = mono*(gₗ*A) (comm/assoc)
              rw [hB_apply, mul_left_comm]
            ------------------------------------------------------------------
            -- division spec gives: deg(gₗ*A gₗ) ≤ deg(S)
            ------------------------------------------------------------------
            have hAdeg :
                m.degree (gₗ.val * A gₗ) ≼[m] m.degree S := by
              simpa only [hiG, hjG, Set.elem_mem, Finset.mem_val] using
                (h_S_poly_gᵢ_gⱼ_repr i j h_ne).2 gₗ
            ------------------------------------------------------------------
            -- Main split on S = 0 / S ≠ 0
            ------------------------------------------------------------------
            by_cases hS0 : S = 0
            · -- S = 0
              have hdeg_gA : m.degree (gₗ.val * A gₗ) = 0 := by
                -- hAdeg : deg(gₗ*A) ≼[m] deg(S)
                have hle_syn :
                    m.toSyn (m.degree (gₗ.val * A gₗ)) ≤ m.toSyn (m.degree S) := hAdeg
                have hle0 :
                    m.toSyn (m.degree (gₗ.val * A gₗ)) ≤ (0 : m.syn) := by
                  simpa only [hS0, degree_zero, map_zero] using hle_syn
                have heq0 :
                    m.toSyn (m.degree (gₗ.val * A gₗ)) = (0 : m.syn) :=
                  le_antisymm hle0 (MonomialOrder.zero_le (m := m) _)
                apply m.toSyn.injective
                -- toSyn(deg(...)) = toSyn(0)
                simpa only [map_zero, EmbeddingLike.map_eq_zero_iff] using heq0
              by_cases hglA0 : gₗ.val * A gₗ = 0
              · -- then gₗ*B gₗ = 0
                have ht : m.toSyn (m.degree (gₗ.val * B gₗ)) < m.toSyn δ_min := by
                  -- hmul : gₗ*B = mono*(gₗ*A)
                  simpa only [hmul, hglA0, mul_zero, degree_zero, map_zero, bot_eq_zero,
                    hδ_syn] using h_min_le_bot
                -- goal is ≺[m], unfold B
                simpa only [hiG, hjG, gt_iff_lt] using ht
              · -- nonzero: use degree_mul + γ≠0 ⇒ δ-γ < δ
                have hglA : gₗ.val * A gₗ ≠ 0 := hglA0
                have hdeg_mul :
                    m.toSyn (m.degree (gₗ.val * B gₗ)) =
                      m.toSyn (m.degree mono) + m.toSyn (m.degree (gₗ.val * A gₗ)) := by
                  rw [hmul]
                  rw [degree_mul hmono hglA]
                  simp [map_add]
                -- γ≠0 ⇒ 0 < toSyn γdeg
                have hγ_pos : (0 : m.syn) < m.toSyn γdeg :=
                  (MonomialOrder.toSyn_lt_iff_ne_zero (m := m)).2 hγ
                -- (δ-γ) < (δ-γ)+γ = δ
                have hmono_lt : m.toSyn (δ_min - γdeg) < m.toSyn δ_min := by
                  have htmp_add :
                      m.toSyn (δ_min - γdeg) + 0
                        < m.toSyn (δ_min - γdeg) + m.toSyn γdeg := by
                    simpa only [add_zero, lt_add_iff_pos_right, zero_add, lt_add_iff_pos_left] using
                      add_lt_add_left hγ_pos (m.toSyn (δ_min - γdeg))
                  calc
                    m.toSyn (δ_min - γdeg)
                        < m.toSyn (δ_min - γdeg) + m.toSyn γdeg := by
                          simpa only [lt_add_iff_pos_right, add_zero] using htmp_add
                    _ = m.toSyn ((δ_min - γdeg) + γdeg) := by
                          simpa only using (m.toSyn.map_add (δ_min - γdeg) γdeg).symm
                    _ = m.toSyn δ_min := by
                          rw [hδ]
                -- now identify deg(gₗ*B gₗ) = δ-γ (since deg(gₗ*A)=0)
                have hEq :
                    m.toSyn (m.degree (gₗ.val * B gₗ)) = m.toSyn (δ_min - γdeg) := by
                  calc
                    m.toSyn (m.degree (gₗ.val * B gₗ))
                        = m.toSyn (m.degree mono) + m.toSyn (m.degree (gₗ.val * A gₗ)) := hdeg_mul
                    _ = m.toSyn (m.degree mono) + 0 := by
                          rw [hdeg_gA, map_zero, add_zero]
                    _ = m.toSyn (m.degree mono) := by simp
                    _ = m.toSyn (δ_min - γdeg) := by
                          rw [hdeg_mono]
                have ht : m.toSyn (m.degree (gₗ.val * B gₗ)) < m.toSyn δ_min := by
                  -- rewrite LHS then apply hmono_lt
                  simpa only [hEq] using hmono_lt
                simpa only [hiG, hjG, gt_iff_lt] using ht
            · -- S ≠ 0
              have hS' : S ≠ 0 := hS0
              by_cases hglA0 : gₗ.val * A gₗ = 0
              · have ht : m.toSyn (m.degree (gₗ.val * B gₗ)) < m.toSyn δ_min := by
                  simpa only [hmul, hglA0, mul_zero, degree_zero, map_zero, bot_eq_zero,
                    hδ_syn] using h_min_le_bot
                simpa only [hiG, hjG, gt_iff_lt] using ht
              · have hglA : gₗ.val * A gₗ ≠ 0 := hglA0
                -- deg(gₗ*B) ≤ deg(mono*S)
                have hle :
                    m.toSyn (m.degree (gₗ.val * B gₗ)) ≤ m.toSyn (m.degree (mono * S)) := by
                  have hL :
                      m.toSyn (m.degree (gₗ.val * B gₗ)) =
                        m.toSyn (m.degree mono) + m.toSyn (m.degree (gₗ.val * A gₗ)) := by
                    rw [hmul]
                    rw [degree_mul hmono hglA]
                    rw [map_add]
                  have hR :
                      m.toSyn (m.degree (mono * S)) =
                        m.toSyn (m.degree mono) + m.toSyn (m.degree S) := by
                    rw [degree_mul hmono hS']
                    rw [map_add]
                  simpa only [hL, hR, add_le_add_iff_left, ge_iff_le, add_le_add_iff_right] using
                    add_le_add_left hAdeg (m.toSyn (m.degree mono))
                -- deg(S) < γdeg
                have hdegS_lt : m.toSyn (m.degree S) < m.toSyn γdeg := by
                  have hsPoly : m.sPolynomial (iG) (jG : MvPolynomial σ k) ≠ 0 := by
                    simpa only [ne_eq] using hS'
                  have hlt0 :
                      m.degree (m.sPolynomial (iG : MvPolynomial σ k) (jG : MvPolynomial σ k))
                        ≺[m] (m.degree (iG : MvPolynomial σ k) ⊔ m.degree (jG : MvPolynomial σ k)) :=
                    m.degree_sPolynomial_lt_sup_degree (f := (iG : MvPolynomial σ k)) (g := (jG : MvPolynomial σ k)) hsPoly
                  simpa only [gt_iff_lt] using hlt0
                have hlt : m.toSyn (m.degree (mono * S)) < m.toSyn δ_min := by
                  -- a := toSyn(δ-γ)
                  set a : m.syn := m.toSyn (δ_min - γdeg) with ha
                  -- toSyn(deg(mono*S)) = a + toSyn(deg S)
                  have hdeg_monoS :
                      m.toSyn (m.degree (mono * S)) = a + m.toSyn (m.degree S) := by
                    -- deg(mono*S)=deg mono + deg S
                    rw [degree_mul hmono hS']
                    -- push toSyn through +
                    have hdegmono_syn : m.toSyn (m.degree mono) = a := by
                      -- hdeg_mono : m.degree mono = δ_min - γdeg
                      simpa only [ha, EmbeddingLike.apply_eq_iff_eq] using
                        congrArg m.toSyn hdeg_mono
                    calc
                      m.toSyn (m.degree mono + m.degree S)
                          = m.toSyn (m.degree mono) + m.toSyn (m.degree S) := by
                              simpa only using (m.toSyn.map_add (m.degree mono) (m.degree S))
                      _ = a + m.toSyn (m.degree S) := by
                              rw [hdegmono_syn]
                  calc
                    m.toSyn (m.degree (mono * S))
                        = m.toSyn (m.degree S) + a := by
                            simpa only [add_comm] using hdeg_monoS
                    _ < m.toSyn γdeg + a := by
                            exact add_lt_add_left hdegS_lt a
                    _ = a + m.toSyn γdeg := by
                            rw [add_comm]
                    _ = m.toSyn δ_min := by
                            calc
                              a + m.toSyn γdeg
                                  = m.toSyn (δ_min - γdeg) + m.toSyn γdeg := by simp only [ha]
                              _ = m.toSyn ((δ_min - γdeg) + γdeg) := by
                                    simpa only using ((m.toSyn.map_add (δ_min - γdeg) γdeg).symm)
                              _ = m.toSyn δ_min := by
                                    rw [hδ]
                have ht : m.toSyn (m.degree (gₗ.val * B gₗ)) < m.toSyn δ_min :=
                  lt_of_le_of_lt hle hlt
                simpa only [hiG, hjG, gt_iff_lt] using ht
          --------------------------------------------------------------------
          -- 1) P₁ → sum of (offDiag)
          --------------------------------------------------------------------
          -- P₁ = ∑ ij ∈ G_δ, (c(i,j)) • m.sPolynomial (LT(hᵢ)gᵢ) (LT(hⱼ)gⱼ)
          have hP₁_decomp_offDiag1 :
              P₁ =
                ∑ ij ∈ G_δ.offDiag,
                  (c ij.1 ij.2) • m.sPolynomial (gδ ij.1) (gδ ij.2) := by
            rw [hP₁_decomp_prod]
            simpa only [Finset.product_eq_sprod] using
              (Finset.sum_product_eq_sum_offDiag_of_diag_zero (s := G_δ) (F := fun ij =>
                (c ij.1 ij.2) • m.sPolynomial (gδ ij.1) (gδ ij.2))
                (by
                  intro a ha
                  simp only [sPolynomial_self, smul_zero]))
          -- P₁ = ∑ ij ∈ G_δ, (c(i,j)) • (x^{δ - γ_ij} m.sPolynomial (LT(hᵢ)gᵢ) (LT(hⱼ)gⱼ))
          have hP₁_decomp_offDiag2 :
              P₁ =
                ∑ ij ∈ G_δ.offDiag,
                  (c ij.1 ij.2) •
                    ((mono_factor ij.1 ij.2) * m.sPolynomial ij.1 ij.2) := by
            rw [hP₁_decomp_offDiag1]
            refine Finset.sum_congr rfl ?_
            intro ij hij_off
            rcases (Finset.mem_offDiag.mp hij_off) with ⟨hi, hj, hne⟩
            simp [h_sPoly_gδ_eq (i := ij.1) (j := ij.2) hi hj]
            rfl
          --------------------------------------------------------------------
          -- 2) each offDiag term → mono_factor*Sij → Bij.sum
          --------------------------------------------------------------------
          have hP₁_rw3 :
              P₁ =
                ∑ ij ∈ G_δ.offDiag,
                  (c ij.1 ij.2) •
                    ( (Bij ij.1 ij.2).sum (fun g q => q * g.val) ) := by
            rw [hP₁_decomp_offDiag2]
            refine Finset.sum_congr rfl ?_
            intro ij hij_off
            rcases (Finset.mem_offDiag.mp hij_off) with ⟨hi, hj, hne⟩
            let iδ : ↥G_δ := ⟨ij.1, hi⟩
            let jδ : ↥G_δ := ⟨ij.2, hj⟩
            have hne' : iδ.val ≠ jδ.val := by
              simpa [iδ, jδ] using hne
            have hrepr :
                mono_factor ij.1 ij.2 * m.sPolynomial (ij.1) (ij.2 : MvPolynomial σ k)
                  =
                (Bij ij.1 ij.2).sum (fun g q => q * g.val) :=
                  (h_mono_mul_Sij_repr (i := iδ) (j := jδ) hne')
            rw [hrepr]
          --------------------------------------------------------------------
          -- 3) B_tilde definition + P₁ = B_tilde.sum(...)
          --------------------------------------------------------------------
          let B_tilde : ↥G →₀ MvPolynomial σ k :=
            ∑ ij ∈ G_δ.offDiag, (c ij.1 ij.2) • (Bij ij.1 ij.2)
          have h_P₁_rw4 :
              P₁ = B_tilde.sum (fun (g : ↥G) (q : MvPolynomial σ k) => q * g.val) := by
            rw [hP₁_rw3]
            unfold B_tilde
            rw [←Finsupp.sum_finset_sum_index (by simp)
              (by ring_nf; simp)]
            refine Finset.sum_congr rfl ?_
            intro ij hij
            rw [Finsupp.sum_smul_index']
            · rw [←C_mul', Finsupp.mul_sum]
              congr
              funext x y
              rw [C_mul']
              simp only [Algebra.smul_mul_assoc]
            · simp only [zero_mul, implies_true]
          --------------------------------------------------------------------
          -- 4) P₂, P₃ as finsupp and construct h_new
          --------------------------------------------------------------------
          let φ : ↥G → MvPolynomial σ k → MvPolynomial σ k :=
            fun g q => q * g.val

          have h_P₁_rw4' : P₁ = B_tilde.sum φ := by
            simpa [φ] using h_P₁_rw4
          let h_P₂_fun (g : ↥G) : MvPolynomial σ k :=
            if g ∈ G_δ then (h_min g - leadingTerm m (h_min g)) else 0
          let h_P₂_finsupp : ↥G →₀ MvPolynomial σ k :=
            (Finsupp.equivFunOnFinite).symm h_P₂_fun
          let h_P₃_fun (g : ↥G) : MvPolynomial σ k :=
            if g ∈ G.attach \ G_δ then h_min g else 0
          let h_P₃_finsupp : ↥G →₀ MvPolynomial σ k :=
            (Finsupp.equivFunOnFinite).symm h_P₃_fun
          let h_new : ↥G →₀ MvPolynomial σ k := B_tilde + h_P₂_finsupp + h_P₃_finsupp
          have h_f_eq_new : f = h_new.sum (fun g h => h * g.val) := by
            rw [h_f_is_P123, h_P₁_rw4]
            unfold h_new
            rw [Finsupp.sum_add_index, Finsupp.sum_add_index]
            · rw [add_assoc, add_assoc, add_left_cancel_iff]
              have G_sep : G.attach = G_δ ∪ (G.attach \ G_δ) := by
                refine Eq.symm (Finset.union_sdiff_of_subset ?_)
                apply Finset.filter_subset
              -- show P₂ + P₃ = (h_P₂_finsupp.sum fun g h ↦ h * ↑g) + h_P₃_finsupp.sum fun g h ↦ h * ↑g
              congr
              · -- P₂ = h_P₂_finsupp.sum fun g h ↦ h * ↑g
                unfold P₂
                -- Unfold the sum of the finsupp.
                -- `h_P₂_finsupp` was defined via `equivFunOnFinite`. Its sum can be rewritten.
                have h_rhs_eq_sum_univ :
                    h_P₂_finsupp.sum (fun g h => h * g.val)
                    = ∑ i ∈ (Finset.univ : Finset ↥G), h_P₂_fun i * i.val := by
                  dsimp only [h_P₂_finsupp]
                  rw [Finsupp.equivFunOnFinite_symm_eq_sum]
                  simp only [Finset.univ_eq_attach]
                  have h_sum_of_sum_single :
                    ((∑ a ∈ G.attach, Finsupp.single a (h_P₂_fun a))).sum (fun g h => h * g.val)
                    = ∑ a ∈ G.attach, (h_P₂_fun a) * a.val := by
                    -- Let `F g h := h * g.val` be the function inside the `Finsupp.sum`.
                    rw [←Finsupp.sum_finset_sum_index]
                    · congr
                      funext g
                      simp only [zero_mul, Finsupp.sum_single_index]
                    · simp only [zero_mul, implies_true]
                    · ring_nf; simp only [implies_true]
                  exact h_sum_of_sum_single
                rw [h_rhs_eq_sum_univ]
                unfold h_P₂_fun
                simp only [Finset.univ_eq_attach, ite_mul, zero_mul]
                rw [G_sep]
                rw [Finset.sum_union]
                · simp only [Finset.sum_ite_mem, Finset.inter_self, Finset.sdiff_inter_self,
                  Finset.sum_empty, add_zero]
                · exact Finset.disjoint_sdiff
              · -- show P₃ = h_P₃_finsupp.sum fun g h ↦ h * ↑g
                dsimp only [P₃, h_P₃_finsupp]
                rw [Finsupp.equivFunOnFinite_symm_eq_sum]
                simp only [Finset.univ_eq_attach]
                -- Step 1: Prove the helper lemma to simplify the `Finsupp.sum`.
                have h_sum_of_sum_single :
                    ((∑ a ∈ G.attach, Finsupp.single a (h_P₃_fun a))).sum (fun g h => h * g.val)
                    = ∑ a ∈ G.attach, (h_P₃_fun a) * a.val := by
                  rw [←Finsupp.sum_finset_sum_index]
                  · congr
                    funext g
                    rw [Finsupp.sum_single_index]
                    exact zero_mul g.val
                  · -- Side condition 1 for `sum_sum_index'`: `F 0 = 0`.
                    simp only [zero_mul, implies_true]
                  · -- Side condition 2 for `sum_sum_index'`: `F` is additive.
                    ring_nf; simp only [implies_true]
                rw [h_sum_of_sum_single]
                unfold h_P₃_fun
                simp only [Finset.mem_sdiff, Finset.mem_attach, true_and, ite_not, ite_mul,
                  zero_mul]
                symm
                simpa only [Finset.piecewise, Finset.sum_const_zero, zero_add] using
                  (Finset.sum_piecewise (s := G.attach) (t := G_δ) (f := fun _ : ↥G =>
                    (0 : MvPolynomial σ k)) (g := fun x : ↥G => h_min x * (x : MvPolynomial σ k)))
            · -- show ∀ a ∈ B_tilde.support ∪ h_P₂_finsupp.support, 0 * ↑a = 0
              intro a ha_in_union; exact zero_mul a.val
            · -- show ∀ a ∈ B_tilde.support ∪ h_P₂_finsupp.support, ∀ (b₁ b₂ : MvPolynomial σ k), (b₁ + b₂) * ↑a = b₁ * ↑a + b₂ * ↑a
              intro a ha_in_union b₁ b₂; exact add_mul b₁ b₂ a.val
            · -- show ∀ a ∈ (B_tilde + h_P₂_finsupp).support ∪ h_P₃_finsupp.support, 0 * ↑a = 0
              intro a ha_in_union; exact zero_mul a.val
            · -- show ∀ a ∈ (B_tilde + h_P₂_finsupp).support ∪ h_P₃_finsupp.support, ∀ (b₁ b₂ : MvPolynomial σ k), (b₁ + b₂) * ↑a = b₁ * ↑a + b₂ * ↑a
              intro a ha_in_union b₁ b₂; exact add_mul b₁ b₂ a.val
          --------------------------------------------------------------------
          -- 5) δ_new_min definition + δ_new_min < δ_syn_min
          --------------------------------------------------------------------
          let δ_new_min := (Finset.image (⇑m.toSyn ∘ fun g ↦ m.degree (h_new g * g.val)) G.attach).sup id
          have δ_new_min_lt_δ_syn_min : δ_new_min < δ_syn_min := by
            rw [Finset.sup_lt_iff h_min_le_bot]
            intro Hg Hg_mem
            simp only [id_eq]
            simp only [Finset.mem_image, Function.comp_apply] at Hg_mem
            obtain ⟨g, ⟨hg_mem_G, h_eq_Hg⟩⟩ := Hg_mem
            rw [←h_eq_Hg]; clear Hg h_eq_Hg
            unfold h_new
            simp only [Finsupp.coe_add, Pi.add_apply]
            rw [right_distrib, right_distrib]
            apply lt_of_le_of_lt MonomialOrder.degree_add_le
            apply max_lt
            · apply lt_of_le_of_lt MonomialOrder.degree_add_le
              apply max_lt
              · -- show m.toSyn (m.degree (B_tilde g * ↑g)) < δ_syn_min
                simp only [Finsupp.coe_finset_sum, Finsupp.coe_smul, Finset.sum_apply,
                  Pi.smul_apply, Finset.sum_mul, Algebra.smul_mul_assoc, B_tilde]
                refine lt_of_le_of_lt
                  (MonomialOrder.degree_sum_le (m := m) (s := G_δ.offDiag)
                    (f := fun ij => c ij.1 ij.2 • ((Bij ij.1 ij.2) g * g.val))) ?_
                rw [Finset.sup_lt_iff h_min_le_bot]
                --intro ij hij_mem_p_supp_offdiag
                intro ij hij_off
                -- hij_off : ij ∈ G_δ.offDiag
                -- mem_offDiag gives: ij.1 ∈ G_δ ∧ ij.2 ∈ G_δ ∧ ij.1 ≠ ij.2
                have hij' := Finset.mem_offDiag.mp hij_off
                -- hij' : ij.1 ∈ G_δ ∧ ij.2 ∈ G_δ ∧ ij.1 ≠ ij.2
                let i' : ↥G_δ := ⟨ij.1, hij'.1⟩
                let j' : ↥G_δ := ⟨ij.2, hij'.2.1⟩
                have hne : i'.val ≠ j'.val := by
                  simpa only [ne_eq] using hij'.2.2
                -- hγ_nonzero : ∀ i j : ↥G_δ, m.toSyn (deg i ⊔ deg j) ≠ 0
                have hγij :
                    m.toSyn (m.degree i'.val.val ⊔ m.degree j'.val.val) ≠ 0 := by
                  simpa only [ne_eq, EmbeddingLike.map_eq_zero_iff] using hγ_nonzero i' j'
                -- kk : deg(g * Bij(i,j) g) ≺ δ_min
                have kk :
                    m.degree (g.val * Bij i'.val j'.val g) ≺[m] δ_min :=
                  h_Blg_lt_δ i' j' hne hγij g
                have kk' :
                    m.toSyn (m.degree ((Bij ij.1 ij.2) g * g.val)) < δ_syn_min := by
                  have kk_syn :
                      m.toSyn (m.degree (g.val * Bij ij.1 ij.2 g)) < m.toSyn δ_min := by
                    simpa only using kk
                  simpa only [mul_comm, hδ_syn, gt_iff_lt] using kk_syn
                -- 이제 scalar smul 처리: c • q = C(c) * q, degree_mul_le로 끝
                rw [←MvPolynomial.C_mul']
                apply lt_of_le_of_lt MonomialOrder.degree_mul_le
                simpa only [degree_C, zero_add] using kk'
              · -- show m.toSyn (m.degree (h_P₂_finsupp g * ↑g)) < δ_syn_min
                unfold h_P₂_finsupp
                simp only [Finsupp.equivFunOnFinite_symm_apply_apply]
                unfold h_P₂_fun
                simp only [ite_mul, zero_mul]
                by_cases h : g ∈ G_δ
                · rw [ite_cond_eq_true ((h_min g - m.leadingTerm (h_min g)) * g.val) 0 (eq_true h)]
                  exact h_P₂term_deg_lt g h
                · rw [ite_cond_eq_false ((h_min g - m.leadingTerm (h_min g)) * g.val) 0 (eq_false h)]
                  simp only [degree_zero, map_zero]
                  exact h_min_le_bot
            · -- show m.toSyn (m.degree (h_P₃_finsupp g * ↑g)) < δ_syn_min
              unfold h_P₃_finsupp
              simp only [Finsupp.equivFunOnFinite_symm_apply_apply]
              unfold h_P₃_fun
              simp only [ite_mul, zero_mul]
              by_cases h : g ∈ G.attach \ G_δ
              · rw [ite_cond_eq_true ((h_min g) * g.val) 0 (eq_true h)]
                exact h_P₃term_deg_lt g h
              · rw [ite_cond_eq_false ((h_min g) * g.val) 0 (eq_false h)]
                simp only [degree_zero, map_zero]
                exact h_min_le_bot
          have h_new_in : δ_new_min ∈ RepDegrees := by
            refine ⟨h_new, ?_, ?_⟩
            -- h_new ∈ Rep
            · dsimp [Rep]
              -- (∑ g∈G.attach, h_new g * g.val) = f
              have h_sum_attach :
                  h_new.sum (fun g h ↦ h * g.val)
                    = ∑ g ∈ G.attach, h_new g * g.val := by
                rw [Finsupp.sum]
                have support_subset : h_new.support ⊆ G.attach := by
                  unfold h_new
                  apply Finset.Subset.trans Finsupp.support_add
                  apply Finset.union_subset <;> exact Finset.subset_univ _
                rw [Finset.sum_subset support_subset]
                intro g hg_in_G hg_not_in_h_new
                simp only [Finsupp.mem_support_iff, ne_eq, Decidable.not_not] at hg_not_in_h_new
                rw [hg_not_in_h_new, zero_mul]
              calc
                (∑ g ∈ G.attach, h_new g * g.val)
                    = h_new.sum (fun g h ↦ h * g.val) := by
                        simp only [h_sum_attach]
                _ = f := h_f_eq_new.symm
            · -- δOf h_new = δ_new_min
              classical
              -- φ g := m.toSyn (deg (h_new g * g))
              let φ : ↥G → m.syn := fun g => m.toSyn (m.degree (h_new g * g.val))
              have hsup :
                  (G.attach).sup φ = (G.attach.image φ).sup id := by
                apply le_antisymm
                · -- (⊆)  sup φ ≤ sup id on image
                  refine (Finset.sup_le_iff).2 ?_
                  intro g hg
                  have hx : φ g ∈ G.attach.image φ := Finset.mem_image_of_mem φ hg
                  -- id (φ g) ≤ sup id
                  simpa only [Finset.sup_image, CompTriple.comp_eq, ge_iff_le, id_eq] using
                    (Finset.le_sup (s := G.attach.image φ) (f := id) hx)
                · -- (⊇)  sup id on image ≤ sup φ
                  refine (Finset.sup_le_iff).2 ?_
                  intro x hx
                  rcases Finset.mem_image.mp hx with ⟨g, hg, rfl⟩
                  -- φ g ≤ sup φ
                  simpa only [id_eq] using (Finset.le_sup (s := G.attach) (f := φ) hg)
              simpa only
          have h_min_property :=
            WellFounded.not_lt_min wellFounded_lt RepDegrees hRepDegrees_nonempty h_new_in
          exact False.elim (h_min_property δ_new_min_lt_δ_syn_min)

end Field
end MonomialOrder
