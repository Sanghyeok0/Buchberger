import Mathlib.Algebra.MvPolynomial.Division
import Mathlib.RingTheory.MvPolynomial.Ideal
import Mathlib.RingTheory.MvPolynomial.MonomialOrder
import Mathlib.RingTheory.Finiteness.Defs

variable {σ R : Type*} [CommSemiring R] --[EmptyCollection σ]
variable {k : Type*} [Field k]
variable {m : MonomialOrder σ}

namespace MvPolynomial

def monomialIdeal' (s : Set (σ →₀ ℕ)) : Ideal (MvPolynomial σ R) :=
  Ideal.span ((fun s => monomial s (1 : R)) '' s)

variable (R) in
def monomialIdeal (s : Set (σ →₀ ℕ)) : Ideal (MvPolynomial σ R) :=
  Ideal.span ((fun s => monomial s (1 : R)) '' s)

variable (m) in
/-- the leading coefficient of a multivariate polynomial with respect
to a monomial ordering -/
noncomputable def leadingTerm (f : MvPolynomial σ R) : MvPolynomial σ R :=
  monomial (m.degree f) (m.leadingCoeff f)

variable (m) in
/-- The ideal generated by the leading terms of the nonzero elements of I. -/
def initialIdeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  Ideal.span { f : MvPolynomial σ R | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

/-
## TODO
* [Field k] 조건 완화 -/
theorem initialIDeal_is_monomial_ideal (I : Ideal (MvPolynomial σ k)) :
    initialIdeal m I = Ideal.span { f | ∃g ∈ I, g ≠ 0 ∧ monomial
(m.degree g) 1 = f } := by
  apply le_antisymm
  · -- Show span(LT) ⊆ span(LM)
    rw [initialIdeal, Ideal.span_le]
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_LT_eq⟩
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 :=
MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lt : leadingTerm m g = (MvPolynomial.C (m.leadingCoeff g))
* (monomial (m.degree g) (1 : k)) := by
      simp [leadingTerm, C_mul_monomial]
    rw [h_lt] at h_LT_eq
    rw [←h_LT_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq, Set.mem_setOf_eq, one_ne_zero,
not_false_eq_true, monomial_left_inj]
    apply Ideal.subset_span (by use g)
  · -- Show span(LM) ⊆ span(LT)
    rw [initialIdeal, Ideal.span_le]
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_lm_eq⟩
    let lt_g := leadingTerm m g
    let lc_g := m.leadingCoeff g
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 :=
MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lm : (monomial (m.degree g) (1 : k)) = C (m.leadingCoeff
g)⁻¹ * (leadingTerm m g):= by
      simp only [leadingTerm, C_mul_monomial, inv_mul_cancel₀ hlc_ne_zero]
    rw [h_lm] at h_lm_eq
    rw [←h_lm_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq, Set.mem_setOf_eq, one_ne_zero,
not_false_eq_true, monomial_left_inj]
    apply Ideal.subset_span (by use g)


variable (m) in
/-- The set of leading terms of nonzero polynomials in an ideal I. -/
def LT_set (I : Ideal (MvPolynomial σ R)) : Set (MvPolynomial σ R) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

variable (m) in
def LM_set (I : Ideal (MvPolynomial σ R)) : Set (σ →₀ ℕ) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = f }

/--
Lemma 2. Let I = ⟨x^α | α ∈ A⟩ be a monomial ideal. Then a monomial
x^β lies in I if and only if
x^β is divisible by some x^α for α in A, i.e. there exists α ∈ A such
that α ≤ β.
-/

lemma mem_monomialIdeal_iff_divisible {A : Set (σ →₀ ℕ)} {β : σ →₀ ℕ}
[DecidableEq R] [Nontrivial R] :
  (monomial β (1 : R)) ∈ monomialIdeal R A ↔ ∃ α ∈ A, α ≤ β := by
  constructor
  · intro h
    unfold monomialIdeal at h
    rw [mem_ideal_span_monomial_image] at h
    have supp_eq : (monomial β (1 : R)).support = {β} := by
      rw [MvPolynomial.support_monomial]
      have : 0 ≠ (1 : R) := by exact zero_ne_one' R
      exact if_neg (id (Ne.symm this))
    specialize h β (by simp [supp_eq])
    exact h
  · intro h
    unfold monomialIdeal
    rw [mem_ideal_span_monomial_image]
    have supp_eq : (monomial β (1 : R)).support = {β} := by
      rw [MvPolynomial.support_monomial]
      have : 0 ≠ (1 : R) := by exact zero_ne_one' R
      exact if_neg (id (Ne.symm this))
    intros xi hxi
    rw [supp_eq, Finset.mem_singleton] at hxi
    subst hxi
    exact h

/-
Theorem 5 (Dickson’s Lemma). Let
 I = ⟨ x^α | α ∈ A ⟩ ⊆ k[x₁, …, xₙ]
be a monomial ideal. Then there exists a finite subset s ⊆ A such that
 I = ⟨ x^α | α ∈ s ⟩.
In other words, every monomial ideal has a finite basis.
-/

-- variable [Fintype σ] in
-- theorem Dickson_lemma (A : Set (σ →₀ ℕ)) :
--   ∃ (b : Finset (σ →₀ ℕ)), b.toSet ⊆ A ∧ (monomialIdeal R A = monomialIdeal R ↑b ) := by sorry
-- --   by_cases h : Fintype.card σ = 0
-- --   · have dom_empty : IsEmpty σ := Fintype.card_eq_zero_iff.mp h
-- --     have this : A = ∅ := by apply?

-- --     use ∅
-- --     simp
-- --     ext p
-- --     rw [monomialIdeal, monomialIdeal]
-- --     simp
-- --     by_cases p_eq_zero : p = 0
-- --     · sorry
-- --     · simp
-- --     sorry
-- --   · -- Inductive step (Fintype.card σ > 0)
-- --     sorry

lemma Mvpoly_to_mono {I : Ideal (MvPolynomial σ R)} :
  { f | ∃ g ∈ I, g ≠ 0 ∧ monomial (m.degree g) (1 : R) = f } = (fun s
=> monomial s (1 : R)) '' LM_set m I := -- { d | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = d } :=
by
  ext f
  constructor
  · intro hmv
    simp at *
    obtain ⟨g, hg⟩ := hmv
    use m.degree g
    constructor
    · use g
      simp only [and_true]
      constructor
      · exact hg.1
      · exact hg.2.1
    · exact hg.2.2
  · intro hmn
    simp at *
    obtain ⟨x, ⟨g, hg⟩, hx⟩ := hmn
    use g
    constructor
    · exact hg.1
    · constructor
      · exact hg.2.1
      · rw [←hg.2.2] at hx
        exact hx
  -- ∃ (b : Finset (σ →₀ ℕ)), b.toSet ⊆ A ∧ (@monomialIdeal σ R _ A = monomialIdeal ↑b )

variable [Fintype σ] (R) in
theorem Dickson_lemma (s : Set (σ →₀ ℕ)) :
  (monomialIdeal R s).FG := by sorry
  --(Ideal.span {f | ∃ g ∈ I, g ≠ 0 ∧ (monomial (m.degree g)) (1 : R) = f}).FG := by sorry

-- variable [Fintype σ] in
-- theorem Dickson_lemma₉ (A : Set (σ →₀ ℕ)) :
--   ∃ (s : Finset (σ →₀ ℕ)), s.toSet ⊆ A ∧ (@monomialIdeal σ R _ A = monomialIdeal ↑s ) := by
--   induction (Fintype.card σ) using Nat.strongRecOn with
--   | ind n IH =>
--     obtain _ | n := n
--     · refine ⟨∅, by simp, ?_⟩
--       ext p
--       simp only [Finset.coe_empty]
--       constructor
--       · intro h
--         have : IsEmpty σ := by
--           have h : Fintype.card (PLift σ) = 0 := by rfl -- simp_all does not finish the proof
--           exact instIsEmpty (PLift σ)
--         have : A = ∅ ∨ A = {0} := by
--           apply Set.eq_empty_or_singleton_of_isEmpty
--           intro x
--           apply Finsupp.ext
--           intro a
--           exact IsEmpty.elim this a
--         cases this with
--         | inl h => simp [h]
--         | inr h =>
--           simp only [h, monomialIdeal, Set.image_singleton, Ideal.span_singleton_one, eq_true_iff,
--             Submodule.top_eq_top, and_true]
--           exact trivial
--       · intro h
--         rw [monomialIdeal] at h
--         simp only [Set.image_empty, Ideal.span_empty, Ideal.mem_bot] at h
--         rw [h, monomialIdeal]
--         exact Submodule.zero_mem (Ideal.span ((fun s => (monomial s) 1) '' A))
--     · sorry

-- variable [Fintype σ] in
-- theorem Dickson_lemma₀ (A : Set (σ →₀ ℕ)) :
--   ∃ (s : Finset (σ →₀ ℕ)), s.toSet ⊆ A ∧ (@monomialIdeal σ R _ A = monomialIdeal ↑s ) := by
--   let n := Fintype.card σ
--   induction' n with n ih
--   · have : n = 0 := by apply?
--   · done
--   | zero =>
--     have : n = 0 := by apply?
--     refine ⟨∅, by simp, ?_⟩
--     have : Fintype.card σ = 0 := by apply?
--     have : IsEmpty σ := by assumption
--     have : A = ∅ := by sorry
--     simp_all
--   | succ n IH => sorry

-- variable [Fintype σ] in
-- theorem Dickson_lemma₁ (A : Set (σ →₀ ℕ)) :
--   ∃ (s : Finset (σ →₀ ℕ)), s.toSet ⊆ A ∧ (@monomialIdeal σ R _ A = monomialIdeal ↑s ) := by
--   let n := Fintype.card σ
--   induction n with
--   | zero =>
--     have : Fintype.card σ = 0 := by sorry
--     refine ⟨∅, by simp, ?_⟩
--     have : Fintype.card σ = 0 := by sorry
--     have : IsEmpty σ := by assumption
--     have : A = ∅ := by sorry
--     simp_all
--   | succ n IH => sorry

variable [Fintype σ] in
theorem Dickson_lemma₂ (A : Set (σ →₀ ℕ)) :
  ∃ (s : Finset (σ →₀ ℕ)), s.toSet ⊆ A ∧ (monomialIdeal R A = monomialIdeal R ↑s ) := by
  let n := Fintype.card σ
  let S : Finset σ := Finset.univ
  -- induction' n using Nat.strong_induction_on with n ih
  induction S using Finset.induction with
  | empty => sorry
  | insert _ _ => sorry
  sorry

-- variable [Fintype σ] in
-- theorem Dickson_lemma₃ (A : Set (σ →₀ ℕ)) :
--   ∃ (s : Finset (σ →₀ ℕ)), s.toSet ⊆ A ∧ (@monomialIdeal σ R _ A = monomialIdeal ↑s ) := by
--   induction (Fintype.card σ) using Nat.strongRecOn with
--   | ind n IH =>
--     obtain hn | hn := Nat.eq_zero_or_pos n
--     · -- Base case: n = 0 (card σ = 0)
--       refine ⟨∅, by simp, ?_⟩
--       have : IsEmpty σ := by
--         have h : Fintype.card (PLift σ) = 0 := by simp_all;
--       have : A = ∅ ∨ A = {0} := by
--         apply Set.eq_empty_or_singleton_of_isEmpty
--         intro x
--         apply Finsupp.ext
--         intro a
--         exact IsEmpty.elim this a
--       cases this with
--       | inl h => simp [h]
--       | inr h =>
--         simp only [h, monomialIdeal, Set.image_singleton, Ideal.span_singleton_one,
--           eq_true_iff, Submodule.top_eq_top, and_true]
