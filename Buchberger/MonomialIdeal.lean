import Mathlib.Algebra.MvPolynomial.Division
import Mathlib.RingTheory.MvPolynomial.Ideal
import Mathlib.RingTheory.MvPolynomial.MonomialOrder
import Mathlib.RingTheory.Finiteness.Defs
import Mathlib.Order.Basic
import Mathlib.Data.Fin.SuccPred
import Mathlib.Order.Fin.Tuple
import Mathlib.Data.Finsupp.PWO
import Buchberger.Order

variable {σ R : Type*} [CommSemiring R] --[EmptyCollection σ]
variable {k : Type*} [Field k]
variable {m : MonomialOrder σ}

namespace MvPolynomial

variable (R) in
def monomialIdeal (s : Set (σ →₀ ℕ)) : Ideal (MvPolynomial σ R) :=
  Ideal.span ((fun s => monomial s (1 : R)) '' s)

end MvPolynomial

namespace MonomialOrder
open MvPolynomial

variable (m) in
lemma degree_le_degree_mul (p q : MvPolynomial σ k) (hq_ne_zero : q ≠ 0) :
  m.degree p ≼[m] m.degree (p * q) := by
  by_cases hp_ne_zero : p = 0
  · rw [hp_ne_zero, degree_zero, map_zero, zero_mul, degree_zero, map_zero]
  · rw [m.degree_mul hp_ne_zero hq_ne_zero, map_add]
    exact le_add_of_nonneg_right (bot_le)

variable (m) in
/-- the leading coefficient of a multivariate polynomial with respect
to a monomial ordering -/
noncomputable def leadingTerm (f : MvPolynomial σ R) : MvPolynomial σ R :=
  monomial (m.degree f) (m.leadingCoeff f)

/-- Multiplicativity of leading terms -/
theorem leadingTerm_mul [IsCancelMulZero R] {f g : MvPolynomial σ R} (hf : f ≠ 0) (hg : g ≠ 0) :
    m.leadingTerm (f * g) = m.leadingTerm f * m.leadingTerm g := by
  repeat rw [leadingTerm]
  rw [degree_mul hf hg, leadingCoeff_mul hf hg]
  rw [MvPolynomial.monomial_mul]

/-- The multidegree of the leading term `LT(f)` is equal to the degree of `f`. -/
@[simp]
lemma degree_leadingTerm (f : MvPolynomial σ R) :
    m.degree (leadingTerm m f) = m.degree f := by
  have : Decidable (m.leadingCoeff f = 0) := by exact Classical.propDecidable (m.leadingCoeff f = 0)
  rw [leadingTerm, m.degree_monomial]
  split_ifs with h_coeff_zero
  · rw [m.leadingCoeff_eq_zero_iff] at h_coeff_zero
    rw [h_coeff_zero, m.degree_zero]
  · rfl

variable (m) in
lemma leadingTerm_eq_zero_imp_eq_zero
  {f : MvPolynomial σ R} (h_lt_zero : m.leadingTerm f = 0 ):
    f = 0 := by
  rw [leadingTerm] at h_lt_zero
  have h_lc_zero : m.leadingCoeff f = 0 := by
    exact MvPolynomial.monomial_eq_zero.mp h_lt_zero
  exact m.leadingCoeff_eq_zero_iff.mp h_lc_zero

variable (m) in
@[simp]
lemma leadingTerm_zero : m.leadingTerm (0 : MvPolynomial σ k) = 0 := by
  rw [leadingTerm, degree_zero, leadingCoeff_zero, monomial_zero]

variable (m) in
@[simp]
lemma leadingTerm_ne_zero_iff {f : MvPolynomial σ k} :
    m.leadingTerm f ≠ 0 ↔ f ≠ 0 := by
  -- An iff is proven by splitting it into two implications.
  constructor

  · -- Direction 1: `m.leadingTerm f ≠ 0 → f ≠ 0`
    -- We prove the contrapositive: `f = 0 → m.leadingTerm f = 0`.
    intro h_lt_ne_zero
    contrapose! h_lt_ne_zero
    -- Now the goal is `m.leadingTerm f = 0`, with the hypothesis `f = 0`.
    rw [h_lt_ne_zero, leadingTerm_zero] -- We need a `leadingTerm_zero` helper.

  · -- Direction 2: `f ≠ 0 → m.leadingTerm f ≠ 0`
    -- We prove the contrapositive: `m.leadingTerm f = 0 → f = 0`.
    intro h_f_ne_zero
    contrapose! h_f_ne_zero
    -- The goal is now `f = 0` with hypothesis `m.leadingTerm f = 0`.
    -- This is exactly your existing lemma.
    exact m.leadingTerm_eq_zero_imp_eq_zero h_f_ne_zero

variable (m) in
lemma eq_leadingTerm_of_degree_zero
  {f : MvPolynomial σ R} (h_deg : m.degree f = 0 ) :
    f = m.leadingTerm f := by
  -- `m.degree f = 0` implies `f` is a constant.
  have h_f_is_const : f = C (m.leadingCoeff f) := by
    apply eq_C_of_degree_eq_zero h_deg

  -- The leading term of `f` is also this constant.
  have h_lt_is_const : m.leadingTerm f = C (m.leadingCoeff f) := by
    rw [leadingTerm, h_deg, monomial_zero']

  nth_rw 1 [h_f_is_const]; rw [h_lt_is_const]

variable (m) in
/-- The ideal generated by the leading terms of the nonzero elements of I. -/
def initialIdeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  Ideal.span { f : MvPolynomial σ R | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

/-
## TODO
* [Field k] 조건 완화 -/
lemma initialIdeal_is_monomial_ideal' (I : Ideal (MvPolynomial σ k)) :
    initialIdeal m I = Ideal.span { f | ∃ g ∈ I, g ≠ 0 ∧ monomial (m.degree g) 1 = f } := by
  apply le_antisymm
  · -- Show span(LT) ⊆ span(LM)
    rw [initialIdeal, Ideal.span_le]
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_LT_eq⟩
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 := MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lt : leadingTerm m g = (MvPolynomial.C (m.leadingCoeff g)) * (monomial (m.degree g) (1 : k)) := by
      simp [leadingTerm, C_mul_monomial]
    rw [h_lt] at h_LT_eq
    rw [←h_LT_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq] -- , Set.mem_setOf_eq, one_ne_zero, not_false_eq_true, monomial_left_inj
    apply Ideal.subset_span (by use g)
  · -- Show span(LM) ⊆ span(LT)
    rw [initialIdeal, Ideal.span_le]
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_lm_eq⟩
    let lt_g := leadingTerm m g
    let lc_g := m.leadingCoeff g
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 := MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lm : (monomial (m.degree g) (1 : k)) = C (m.leadingCoeff g)⁻¹ * (leadingTerm m g):= by
      simp only [leadingTerm, C_mul_monomial, inv_mul_cancel₀ hlc_ne_zero]
    rw [h_lm] at h_lm_eq
    rw [←h_lm_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq]
    apply Ideal.subset_span (by use g)


variable (m) in
/-- The set of leading terms of nonzero polynomials in an ideal I. -/
def LT_set (I : Ideal (MvPolynomial σ R)) : Set (MvPolynomial σ R) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

variable (m) in
def LM_set (I : Ideal (MvPolynomial σ R)) : Set (σ →₀ ℕ) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = f }

theorem initialIdeal_is_monomial_ideal (I : Ideal (MvPolynomial σ k)) :
  initialIdeal m I = monomialIdeal k (LM_set m I) := by
  dsimp [monomialIdeal, LM_set]
  have : { f | ∃ g ∈ I, g ≠ 0 ∧ monomial (m.degree g) 1 = f } = (fun α => monomial α (1 : k)) '' LM_set m I := by
    ext f
    constructor
    · rintro ⟨g, hgI, h0, rfl⟩
      use m.degree g
      constructor
      · exact ⟨g, hgI, h0, rfl⟩
      · rfl
    · rintro ⟨α, ⟨g, hgI, h0, hdeg⟩, hαf⟩
      use g; -- simp [hdeg] at hαf;
      rw [hdeg]
      exact ⟨hgI, h0, hαf⟩
  simp [LM_set] at this
  rw [←this]
  apply initialIdeal_is_monomial_ideal'

/--
Lemma 2. Let I = ⟨x^α | α ∈ A⟩ be a monomial ideal. Then a monomial
x^β lies in I if and only if
x^β is divisible by some x^α for α in A, i.e. there exists α ∈ A such
that α ≤ β.
-/
lemma mem_monomialIdeal_iff_divisible {A : Set (σ →₀ ℕ)} {β : σ →₀ ℕ}
[DecidableEq R] [Nontrivial R] :
  (monomial β (1 : R)) ∈ monomialIdeal R A ↔ ∃ α ∈ A, α ≤ β := by
  constructor
  · intro h
    unfold monomialIdeal at h
    rw [mem_ideal_span_monomial_image] at h
    have supp_eq : (monomial β (1 : R)).support = {β} := by
      rw [MvPolynomial.support_monomial]
      have : 0 ≠ (1 : R) := by exact zero_ne_one' R
      exact if_neg (id (Ne.symm this))
    specialize h β (by simp [supp_eq])
    exact h
  · intro h
    unfold monomialIdeal
    rw [mem_ideal_span_monomial_image]
    have supp_eq : (monomial β (1 : R)).support = {β} := by
      rw [MvPolynomial.support_monomial]
      have : 0 ≠ (1 : R) := by exact zero_ne_one' R
      exact if_neg (id (Ne.symm this))
    intros xi hxi
    rw [supp_eq, Finset.mem_singleton] at hxi
    subst hxi
    exact h

/-이름 수정 필요-/ -- image_leading_monomial_eq_leading_monomial_image
lemma Mvpoly_to_mono {I : Ideal (MvPolynomial σ R)} :
  { f | ∃ g ∈ I, g ≠ 0 ∧ monomial (m.degree g) (1 : R) = f } = (fun s
=> monomial s (1 : R)) '' LM_set m I := -- { d | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = d } :=
by
  ext f
  constructor
  · intro hmv
    simp at *
    obtain ⟨g, hg⟩ := hmv
    use m.degree g
    constructor
    · use g
      simp only [and_true]
      constructor
      · exact hg.1
      · exact hg.2.1
    · exact hg.2.2
  · intro hmn
    simp at *
    obtain ⟨x, ⟨g, hg⟩, hx⟩ := hmn
    use g
    constructor
    · exact hg.1
    · constructor
      · exact hg.2.1
      · rw [←hg.2.2] at hx
        exact hx
  -- ∃ (b : Finset (σ →₀ ℕ)), b.toSet ⊆ A ∧ (@monomialIdeal σ R _ A = monomialIdeal ↑b )

open Set

theorem Dickson_lemma {σ : Type*} [Fintype σ] :
  HasDicksonProperty (σ →₀ ℕ) := by
  have hPWO : (Set.univ : Set (σ →₀ ℕ)).IsPWO := Finsupp.isPWO (S := Set.univ)
  apply HasDicksonProperty_iff_WellQuasiOrderedLE.mpr
  refine (wellQuasiOrderedLE_def (σ →₀ ℕ)).mpr ?_
  -- Given any sequence f : ℕ → σ →₀ ℕ, PWO gives a monotone subsequence
  intro f
  obtain ⟨g, hg_mono⟩ := @hPWO.exists_monotone_subseq _ _ _ f (fun _ => mem_univ _)
  -- Take the first two indices i := g 0, j := g 1
  let i := g 0
  let j := g 1
  -- Strict‐mono of g turns 0 < 1 into i < j
  have hij : i < j := g.strictMono (Nat.zero_lt_succ 0)
  -- Monotonicity of f ∘ g at 0 ≤ 1 gives f i ≤ f j
  have hle : f i ≤ f j := by
    rw [Monotone] at hg_mono
    refine hg_mono ?_
    exact Nat.zero_le 1
  exact ⟨i, j, hij, hle⟩


variable [Fintype σ] (R) [DecidableEq σ] [DecidableEq R] in
/--
Theorem 5 (Dickson’s Lemma). Let
 I = ⟨ x^α | α ∈ A ⟩ ⊆ k[x₁, …, xₙ]
be a monomial ideal. Then there exists a finite subset s ⊆ A such that
 I = ⟨ x^α | α ∈ s ⟩.
In other words, every monomial ideal has a finite basis.
-/
theorem Dickson_lemma_MV (S : Set (σ →₀ ℕ)) :
  (monomialIdeal R S).FG := by
  rw [monomialIdeal, Ideal.FG]
  obtain ⟨B', hB'fin, ⟨hB'sub, hB'basis⟩⟩ := Dickson_lemma S
  let B := @Set.toFinset (σ →₀ ℕ) B' (by exact hB'fin.fintype)
  use Finset.image (fun x ↦ (monomial x) (1:R) ) B
  have hBsub : B.toSet ⊆ S := by
    rw [Set.coe_toFinset]
    exact hB'sub
  have hBbasis : ∀ a ∈ S, ∃ b ∈ B, b ≤ a := by
    intro a ha
    obtain ⟨b₀, hb₀B', hb₀a⟩ := hB'basis a ha
    use b₀
    constructor
    · simp [B]
      exact hb₀B'
    · exact hb₀a
  simp only [Finset.coe_image]
  apply le_antisymm
  · apply Ideal.span_mono
    refine Set.image_mono ?_
    exact hBsub
  · refine Ideal.span_le.mpr ?_
    rw [Set.subset_def]
    intro d hS
    rw [Set.mem_image] at hS
    obtain ⟨x, hxd⟩ := hS
    have hy : ∃ y ∈ B, ∀ (i : σ), y i ≤ x i := by apply hBbasis x hxd.1
    obtain ⟨y, hyx⟩ := hy
    simp only [SetLike.mem_coe]
    let j : σ → ℕ := fun (i : σ) ↦ (x i - y i)
    refine mem_ideal_span_monomial_image.mpr ?_
    have : Decidable ((1:R) = 0) := by exact Classical.propDecidable (1 = 0) -- 괜찮?
    rw [←hxd.2, MvPolynomial.support_monomial]
    by_cases h_triv : (1:R) = 0
    · rw [ite_cond_eq_true]
      simp only [Finset.notMem_empty, Finset.mem_coe, IsEmpty.forall_iff, implies_true]
      exact eq_true h_triv
    · intro xi hxi
      rw [ite_cond_eq_false] at hxi
      simp only [Finset.mem_singleton] at hxi
      rw [hxi]
      use y
      simp only [Finset.mem_coe]
      exact hyx
      exact eq_false h_triv


variable [Fintype σ] [DecidableEq σ] [DecidableEq k] in
/-- **Proposition 3 (Cox, Little, O'Shea, Ch 2, §5, Proposition 3)**.
Initial Ideal is finitely generated.-/
theorem initialIdeal_is_FG (I : Ideal (MvPolynomial σ k)) : (initialIdeal m I).FG := by
  -- 1. Show initialIdeal m I is spanned by monomials with coefficient 1
  rw [initialIdeal_is_monomial_ideal' I]
  rw [Ideal.FG]
  rw [Mvpoly_to_mono]
  have h_fg : (monomialIdeal k (LM_set m I)).FG := Dickson_lemma_MV k (LM_set m I)
  obtain ⟨b, h_span⟩ := h_fg
  use b
  exact h_span

/-
## TODO

* Authors: Antoine Chambert-Loir

* Prove that under `Field F`, `IsUnit (m.leadingCoeff (b i))` is
equivalent to `b i ≠ 0`.

* https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/MvPolynomial/Groebner.html
-/
theorem isUnit_leadingCoeff_iff_nonzero
  (m : MonomialOrder σ) (b : MvPolynomial σ k) :
  IsUnit (m.leadingCoeff b) ↔ b ≠ 0 := by
  constructor
  · intro h
    contrapose! h
    rw [h, m.leadingCoeff_zero]
    exact not_isUnit_zero
  · intro hb
    have h₁ : m.leadingCoeff b ≠ 0 := by exact MonomialOrder.leadingCoeff_ne_zero_iff.mpr hb
    exact isUnit_iff_ne_zero.mpr h₁

end MonomialOrder
