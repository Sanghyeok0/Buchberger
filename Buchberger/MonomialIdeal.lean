import Mathlib.Algebra.MvPolynomial.Division
import Mathlib.RingTheory.MvPolynomial.Ideal
import Mathlib.RingTheory.MvPolynomial.MonomialOrder
import Mathlib.RingTheory.Finiteness.Defs
import Mathlib.Order.Basic
import Mathlib.Data.Fin.SuccPred
import Mathlib.Order.Fin.Tuple
import Buchberger.Order

variable {σ R : Type*} [CommSemiring R] --[EmptyCollection σ]
variable {k : Type*} [Field k]
variable {m : MonomialOrder σ}

namespace MvPolynomial

def monomialIdeal' (s : Set (σ →₀ ℕ)) : Ideal (MvPolynomial σ R) :=
  Ideal.span ((fun s => monomial s (1 : R)) '' s)

variable (R) in
def monomialIdeal (s : Set (σ →₀ ℕ)) : Ideal (MvPolynomial σ R) :=
  Ideal.span ((fun s => monomial s (1 : R)) '' s)

variable (m) in
/-- the leading coefficient of a multivariate polynomial with respect
to a monomial ordering -/
noncomputable def leadingTerm (f : MvPolynomial σ R) : MvPolynomial σ R :=
  monomial (m.degree f) (m.leadingCoeff f)

variable (m) in
/-- The ideal generated by the leading terms of the nonzero elements of I. -/
def initialIdeal (I : Ideal (MvPolynomial σ R)) : Ideal (MvPolynomial σ R) :=
  Ideal.span { f : MvPolynomial σ R | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

/-
## TODO
* [Field k] 조건 완화 -/
theorem initialIdeal_is_monomial_ideal (I : Ideal (MvPolynomial σ k)) :
    initialIdeal m I = Ideal.span { f | ∃g ∈ I, g ≠ 0 ∧ monomial (m.degree g) 1 = f } := by
  apply le_antisymm
  · -- Show span(LT) ⊆ span(LM)
    rw [initialIdeal, Ideal.span_le]
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_LT_eq⟩
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 := MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lt : leadingTerm m g = (MvPolynomial.C (m.leadingCoeff g)) * (monomial (m.degree g) (1 : k)) := by
      simp [leadingTerm, C_mul_monomial]
    rw [h_lt] at h_LT_eq
    rw [←h_LT_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq, Set.mem_setOf_eq, one_ne_zero, not_false_eq_true, monomial_left_inj]
    apply Ideal.subset_span (by use g)
  · -- Show span(LM) ⊆ span(LT)
    rw [initialIdeal, Ideal.span_le]
    intro f hf_in
    rcases hf_in with ⟨g, hg_mem, hg_ne_zero, h_lm_eq⟩
    let lt_g := leadingTerm m g
    let lc_g := m.leadingCoeff g
    have hlc_ne_zero : m.leadingCoeff g ≠ 0 := MonomialOrder.leadingCoeff_ne_zero_iff.mpr hg_ne_zero
    have h_lm : (monomial (m.degree g) (1 : k)) = C (m.leadingCoeff g)⁻¹ * (leadingTerm m g):= by
      simp only [leadingTerm, C_mul_monomial, inv_mul_cancel₀ hlc_ne_zero]
    rw [h_lm] at h_lm_eq
    rw [←h_lm_eq]
    apply Ideal.mul_mem_left
    simp only [ne_eq, Set.mem_setOf_eq, one_ne_zero, not_false_eq_true, monomial_left_inj]
    apply Ideal.subset_span (by use g)


variable (m) in
/-- The set of leading terms of nonzero polynomials in an ideal I. -/
def LT_set (I : Ideal (MvPolynomial σ R)) : Set (MvPolynomial σ R) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ leadingTerm m g = f }

variable (m) in
def LM_set (I : Ideal (MvPolynomial σ R)) : Set (σ →₀ ℕ) :=
  { f | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = f }

/--
Lemma 2. Let I = ⟨x^α | α ∈ A⟩ be a monomial ideal. Then a monomial
x^β lies in I if and only if
x^β is divisible by some x^α for α in A, i.e. there exists α ∈ A such
that α ≤ β.
-/

lemma mem_monomialIdeal_iff_divisible {A : Set (σ →₀ ℕ)} {β : σ →₀ ℕ}
[DecidableEq R] [Nontrivial R] :
  (monomial β (1 : R)) ∈ monomialIdeal R A ↔ ∃ α ∈ A, α ≤ β := by
  constructor
  · intro h
    unfold monomialIdeal at h
    rw [mem_ideal_span_monomial_image] at h
    have supp_eq : (monomial β (1 : R)).support = {β} := by
      rw [MvPolynomial.support_monomial]
      have : 0 ≠ (1 : R) := by exact zero_ne_one' R
      exact if_neg (id (Ne.symm this))
    specialize h β (by simp [supp_eq])
    exact h
  · intro h
    unfold monomialIdeal
    rw [mem_ideal_span_monomial_image]
    have supp_eq : (monomial β (1 : R)).support = {β} := by
      rw [MvPolynomial.support_monomial]
      have : 0 ≠ (1 : R) := by exact zero_ne_one' R
      exact if_neg (id (Ne.symm this))
    intros xi hxi
    rw [supp_eq, Finset.mem_singleton] at hxi
    subst hxi
    exact h

/-이름 수정 필요-/
lemma Mvpoly_to_mono {I : Ideal (MvPolynomial σ R)} :
  { f | ∃ g ∈ I, g ≠ 0 ∧ monomial (m.degree g) (1 : R) = f } = (fun s
=> monomial s (1 : R)) '' LM_set m I := -- { d | ∃ g ∈ I, g ≠ 0 ∧ m.degree g = d } :=
by
  ext f
  constructor
  · intro hmv
    simp at *
    obtain ⟨g, hg⟩ := hmv
    use m.degree g
    constructor
    · use g
      simp only [and_true]
      constructor
      · exact hg.1
      · exact hg.2.1
    · exact hg.2.2
  · intro hmn
    simp at *
    obtain ⟨x, ⟨g, hg⟩, hx⟩ := hmn
    use g
    constructor
    · exact hg.1
    · constructor
      · exact hg.2.1
      · rw [←hg.2.2] at hx
        exact hx
  -- ∃ (b : Finset (σ →₀ ℕ)), b.toSet ⊆ A ∧ (@monomialIdeal σ R _ A = monomialIdeal ↑b )

/-
Theorem 5 (Dickson’s Lemma). Let
 I = ⟨ x^α | α ∈ A ⟩ ⊆ k[x₁, …, xₙ]
be a monomial ideal. Then there exists a finite subset s ⊆ A such that
 I = ⟨ x^α | α ∈ s ⟩.
In other words, every monomial ideal has a finite basis.
-/
-- Need Preorder instance for Finsupp (pointwise order)
--instance {σ : Type*} : Preorder (σ →₀ ℕ) := by exact Finsupp.preorder

/--
Dickson's lemma for `ℕ^n` (functions `Fin n → ℕ`).
We split each function into its head coordinate and its tail via `succOrderEmb`.
-/
theorem Dickson_lemma_Fin : ∀ n, HasDicksonProperty (Fin n → ℕ) := by
  intro n
  induction n with
  | zero =>
    -- `Fin 0 → ℕ` is a singleton function space
    apply HasDicksonProperty_iff_WellQuasiOrderedLE.mpr
    refine (wellQuasiOrderedLE_def (Fin 0 → ℕ)).mpr fun f => ⟨0,1,by simp, by simp⟩
  | succ n ih =>
    apply HasDicksonProperty_iff_WellQuasiOrderedLE.mpr
    refine (wellQuasiOrderedLE_def (Fin (n+1) → ℕ)).mpr fun f => by
      -- 1) extract head sequence `ℕ → ℕ`
      let f_headSeq : ℕ → ℕ := fun k => f k 0
      -- ℕ is WQO since it's linear and well-founded
      have wq_nat : @WellQuasiOrdered ℕ (· ≤ ·) := by
        refine (wellQuasiOrderedLE_def ℕ).mp ?_
        refine wellQuasiOrderedLE_iff_wellFoundedLT.mpr ?_
        exact instWellFoundedLTNat
      obtain ⟨g₁, hg₁⟩ := wq_nat.exists_monotone_subseq f_headSeq

      -- 2) build tail sequence on `Fin n → ℕ` by composing with `succOrderEmb`
      let emb := Fin.succOrderEmb n -- Fin n ↪o Fin (n+1)
      let f_tailSeq : ℕ → Fin n → ℕ := fun k => (f (g₁ k)) ∘ emb

      -- WQO for the tail by IH
      have wq_tail : @WellQuasiOrdered (Fin n → ℕ) (· ≤ ·) := by
        rw [HasDicksonProperty_iff_WellQuasiOrderedLE] at ih
        exact (wellQuasiOrderedLE_def (Fin n → ℕ)).mp ih
      obtain ⟨g₂, hg₂⟩ := wq_tail.exists_monotone_subseq f_tailSeq

      -- 3) combine the two subsequences
      let i := g₁ (g₂ 0)
      let j := g₁ (g₂ 1)
      have hij : g₁ (g₂ 0) < g₁ (g₂ 1) := by
        refine (OrderEmbedding.lt_iff_lt g₁).mpr ?_
        refine (OrderEmbedding.lt_iff_lt g₂).mpr ?_
        exact Nat.one_pos
      have : i < j := by exact hij
      use i, j, this
      -- show `f i ≤ f j` pointwise
      intro a
      by_cases ha : a = 0
      · -- at head index 0
        subst ha; simp; apply hg₁; refine (OrderEmbedding.le_iff_le g₂).mpr ?_; exact
          Nat.zero_le 1
      · -- at tail indices >0
        obtain ⟨k, rfl⟩ := Fin.eq_succ_of_ne_zero ha
        simp only [Function.comp_apply]
        apply hg₂ 0 1 (by decide)

/-- Dickson's lemma for `ℕ^n` (finitely supported functions on `Fin n`). -/
theorem Dickson_lemma_Finsupp {n : ℕ} : HasDicksonProperty (Fin n →₀ ℕ) := by
  have hF : HasDicksonProperty (Fin n → ℕ) := by exact Dickson_lemma_Fin n
  simp only [HasDicksonProperty] at *
  intro (N₀ : Set (Fin n →₀ ℕ))
  let e := @Finsupp.equivFunOnFinite (Fin n) ℕ
  let N  : Set (Fin n → ℕ) := e.toFun '' N₀
  obtain ⟨B, hBfin, hBbasis⟩ := hF N
  let B₀ : Set (Fin n →₀ ℕ) := e.invFun '' B
  have hB₀fin : (B₀ : Set (Fin n →₀ ℕ)).Finite := by exact Set.Finite.image e.invFun hBfin
  have hB₀N₀ : B₀ ⊆ N₀ := by
    rintro b₀ ⟨b, hbB⟩
    rw [←hbB.2]
    have hbN : b ∈ N := hBbasis.1 hbB.1
    rcases (Set.mem_image _ _ _).1 hbN with ⟨a, ha₀, rfl⟩
    simp only [Equiv.toFun_as_coe, Equiv.invFun_as_coe, Equiv.symm_apply_apply, ha₀]
  refine ⟨B₀, hB₀fin, ⟨hB₀N₀, fun a₀ ha₀ => ?_⟩⟩
  have : ∃ b ∈ B, b ≤ e.toFun a₀ := by apply hBbasis.2 _ (Set.mem_image_of_mem _ ha₀)
  obtain ⟨b, hbB, hb⟩ := this
  use e.invFun b, Set.mem_image_of_mem _ hbB
  exact hb

-- /--
-- Dickson's lemma for `ℕ^n` (functions `Fin n → ℕ`).
-- We split off the head and tail using a single order isomorphism `Fin.consOrderIso`.
-- -/
-- theorem Dickson_lemma_n₂ : ∀ n, HasDicksonProperty (Fin n → ℕ) := by
--   intro n
--   apply HasDicksonProperty_iff_WellQuasiOrderedLE.mpr
--   -- reduce to the raw WQO goal
--   refine (wellQuasiOrderedLE_def (Fin n → ℕ)).mpr ?_
--   -- proceed by induction on n
--   induction n with
--   | zero =>
--     -- `Fin 0 → ℕ` is a singleton, any two indices work
--     intro f; use 0, 1; simp
--   | succ n ih =>
--     -- use the order isomorphism between `Fin (n+1) → ℕ` and `ℕ × (Fin n → ℕ)`
--     let iso := (Fin.consOrderIso fun _ => ℕ).symm.toOrderIso
--     -- apply product WQO to the factors
--     have h₁ : WellQuasiOrdered (· ≤ ·) :=
--       (wellQuasiOrderedLE_iff_wellFoundedLT ℕ).mp instWellFoundedLTNat
--     have h₂ : WellQuasiOrdered (· ≤ ·) := by simpa using ih
--     exact iso.symm.wellQuasiOrdered_of (WellQuasiOrdered.prod h₁ h₂)

-- variable [Fintype σ] in
-- theorem Dickson_lemma : HasDicksonProperty (σ →₀ ℕ) := by
--   have : HasDicksonProperty (σ →₀ ℕ) ↔ HasDicksonProperty (Fin (Fintype.card σ) →₀ ℕ) := by sorry
--   sorry

theorem Dickson_lemma {σ : Type*} [Fintype σ] : HasDicksonProperty (σ →₀ ℕ) := by
  let n := Fintype.card σ
  have hFin : HasDicksonProperty (Fin n →₀ ℕ) := Dickson_lemma_Finsupp
  have hFun : HasDicksonProperty (σ →₀ ℕ) := by
    simp only [HasDicksonProperty] at *
    intro (Ns : Set (σ →₀ ℕ))
    sorry
  sorry

variable [Fintype σ] (R) [DecidableEq (MvPolynomial σ R)] in
theorem Dickson_lemma_MV (S : Set (σ →₀ ℕ)) :
  (monomialIdeal R S).FG := by
  rw [monomialIdeal, Ideal.FG]
  obtain ⟨B', hB'fin, ⟨hB'sub, hB'basis⟩⟩ := Dickson_lemma S
  let B := @Set.toFinset (σ →₀ ℕ) B' (by exact hB'fin.fintype)
  use Finset.image (fun x ↦ (monomial x) (1:R) ) B
  have hBsub : B.toSet ⊆ S := by
    rw [Set.coe_toFinset]
    exact hB'sub
  have hBbasis : ∀ a ∈ S, ∃ b ∈ B, b ≤ a := by
    intro a ha
    obtain ⟨b₀, hb₀B', hb₀a⟩ := hB'basis a ha
    use b₀
    constructor
    · simp [B]
      exact hb₀B'
    · exact hb₀a
  simp only [Finset.coe_image]
  apply le_antisymm
  · apply Ideal.span_mono
    refine Set.image_mono ?_
    exact hBsub
  · refine Ideal.span_le.mpr ?_
    rw [Set.subset_def]
    intro d hS
    rw [Set.mem_image] at hS
    obtain ⟨x, hxd⟩ := hS
    have hy : ∃ y ∈ B, ∀ (i : σ), y i ≤ x i := by apply hBbasis x hxd.1
    obtain ⟨y, hyx⟩ := hy
    simp only [SetLike.mem_coe]
    let j : σ → ℕ := fun (i : σ) ↦ (x i - y i)
    refine mem_ideal_span_monomial_image.mpr ?_
    have : Decidable ((1:R) = 0) := by exact Classical.propDecidable (1 = 0) -- 괜찮?
    rw [←hxd.2, MvPolynomial.support_monomial]
    by_cases h_triv : (1:R) = 0
    · rw [ite_cond_eq_true]
      simp only [Finset.not_mem_empty, Finset.mem_coe, IsEmpty.forall_iff, implies_true]
      exact eq_true h_triv
    · intro xi hxi
      rw [ite_cond_eq_false] at hxi
      simp only [Finset.mem_singleton] at hxi
      rw [hxi]
      use y
      simp only [Finset.mem_coe]
      exact hyx
      exact eq_false h_triv

/-Dickson lemma 구버전-/

-- variable [Fintype σ] in
-- theorem Dickson_lemma₀ (S : Set (σ →₀ ℕ)) :
--   ∃ B : Finset (σ →₀ ℕ), B.toSet ⊆ S ∧ (∀ x ∈ S, ∃ y ∈ B, y ≤ x) := by sorry

-- --(Ideal.span {f | ∃ g ∈ I, g ≠ 0 ∧ (monomial (m.degree g)) (1 : R) = f}).FG := by sorry
-- variable [Fintype σ] (R) [DecidableEq (MvPolynomial σ R)] in
-- theorem Dickson_lemma_MV' (S : Set (σ →₀ ℕ)) :
--   (monomialIdeal R S).FG := by
--   rw [monomialIdeal, Ideal.FG]
--   obtain ⟨B, hBfin, ⟨hBsub, hBbasis⟩⟩ := Dickson_lemma S
--   let B' := @Set.toFinset (σ →₀ ℕ) B (by exact hBfin.fintype)
--   --B : Finset (σ →₀ ℕ)
--   --hB : ↑B ⊆ S ∧ ∀ x ∈ S, ∃ y ∈ B, y ≤ x
--   obtain ⟨B, hB⟩ := Dickson_lemma₀ S
--   use Finset.image (fun x ↦ (monomial x) 1 ) B
--   simp only [Finset.coe_image]
--   apply le_antisymm
--   · apply Ideal.span_mono
--     refine Set.image_mono ?_
--     exact hB.1
--   · refine Ideal.span_le.mpr ?_
--     rw [Set.subset_def]
--     intro d hS
--     rw [Set.mem_image] at hS
--     obtain ⟨x, hxd⟩ := hS
--     have hy : ∃ y ∈ B, ∀ (i : σ), y i ≤ x i := by apply hB.2 x hxd.1
--     obtain ⟨y, hyx⟩ := hy
--     simp only [SetLike.mem_coe]
--     let j : σ → ℕ := fun (i : σ) ↦ (x i - y i)
--     refine mem_ideal_span_monomial_image.mpr ?_
--     have : Decidable ((1:R) = 0) := by exact Classical.propDecidable (1 = 0) -- 괜찮?
--     rw [←hxd.2, MvPolynomial.support_monomial]
--     by_cases h_triv : (1:R) = 0
--     · rw [ite_cond_eq_true]
--       simp only [Finset.not_mem_empty, Finset.mem_coe, IsEmpty.forall_iff, implies_true]
--       exact eq_true h_triv
--     · intro xi hxi
--       rw [ite_cond_eq_false] at hxi
--       simp only [Finset.mem_singleton] at hxi
--       rw [hxi]
--       use y
--       simp only [Finset.mem_coe]
--       exact hyx
--       exact eq_false h_triv
