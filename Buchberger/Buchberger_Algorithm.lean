import Buchberger.GroebnerBases



variable {σ : Type*}
variable {m : MonomialOrder σ}

section Field

variable {k : Type*} [Field k] [DecidableEq k]

instance Field.isNoetherianRing :
    IsNoetherianRing k := by
  refine isNoetherian_iff'.mpr ?_
  exact Finite.to_wellFoundedGT

namespace MvPolynomial

set_option maxHeartbeats 0

open MonomialOrder MvPolynomial Finset

variable [Fintype σ] in
def reduces_to_zero (G : Finset (MvPolynomial σ k)) (f : MvPolynomial σ k) : Prop :=
∃ (A : MvPolynomial σ k → MvPolynomial σ k),
  (f = ∑ g ∈ G, (A g) * g) ∧ ∀ g ∈ G, (A g) * g ≠ 0 → m.degree ((A g) * g) ≼[m] m.degree f

variable (m) [DecidableEq σ] in
noncomputable def buchberger_step (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
  -- We need a proof that G' contains no zeros to call normalForm.
  if hG : ∀ g ∈ G, g ≠ 0 then
    -- 1. FOR each pair {p, q}
    let pairs := G.offDiag
    -- 2. r := S(p,q) mod G'
    let remainders : Finset (MvPolynomial σ k) := pairs.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))
    -- 3. Filter for the non-zero ones.
    remainders.filter (· ≠ 0)
  else
    -- If the input basis contains zero, it's an invalid state, but we must return something.
    -- Returning the empty set is a safe default.
    ∅
lemma normalForm_not_divisible_by_basis
  (G : Finset (MvPolynomial σ k)) (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k)
  (d : σ →₀ ℕ) (hd_in_support : d ∈ (normalForm m hG p).support) :
  ∀ b ∈ G, ¬ (m.degree b ≤ d) := by
  have h_remainder_prop := (normalForm_spec' m hG p).2.2

  specialize h_remainder_prop d hd_in_support

  intro b hb_in_G
  specialize h_remainder_prop b hb_in_G
  exact h_remainder_prop

lemma leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
  (G : Finset (MvPolynomial σ k))
  (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k) (h_rem_ne_zero : normalForm m hG p ≠ 0) :
  m.leadingTerm (normalForm m hG p) ∉ Ideal.span ((fun g => m.leadingTerm g) '' G.toSet) := by

    -- Let `r` be the remainder.
    let r := normalForm m hG p

    -- Let `I_G` be the ideal generated by the basis `G`.
    let I_G := Ideal.span (G : Set (MvPolynomial σ k))

    -- The ideal `<LT(G)>` is the initial ideal of the ideal generated by `G`.
    have h_span_LT_eq_initialIdeal :
      Ideal.span ((fun g => m.leadingTerm g) '' G.toSet) = initialIdeal m I_G := by sorry

    rw [h_span_LT_eq_initialIdeal, initialIdeal_is_monomial_ideal]
    intro h_lt_r_in_ideal
    have h_lm_r_in_ideal : monomial (m.degree r) 1 ∈ monomialIdeal k (LM_set m I_G) := by
      let lc_r := m.leadingCoeff r
      have hlc_ne_zero : lc_r ≠ 0 := m.leadingCoeff_ne_zero_iff.mpr h_rem_ne_zero
      rw [show monomial (m.degree r) 1 = C (lc_r⁻¹) * m.leadingTerm r by {
        rw [leadingTerm, C_mul_monomial, inv_mul_cancel₀ hlc_ne_zero] }]
      exact Ideal.mul_mem_left _ _ h_lt_r_in_ideal

    rw [mem_monomialIdeal_iff_divisible] at h_lm_r_in_ideal

    -- This gives `∃ α ∈ (G.image m.degree).toSet, α ≤ m.degree r`.
    -- Unpacking the image, this means `∃ g ∈ G, m.degree g ≤ m.degree r`.
    obtain ⟨LMg, ⟨g, ⟨hg_in_I_G, hg_nezero, rfl⟩⟩, h_deg_le⟩ := h_lm_r_in_ideal

    have h_remainder_prop := (normalForm_spec m hG p).2.2
    have h_deg_in_support : m.degree r ∈ r.support :=
      MonomialOrder.degree_mem_support h_rem_ne_zero
    specialize h_remainder_prop (m.degree r) h_deg_in_support
    have : ∀ b ∈ G, ¬m.degree b ≤ m.degree r := by exact fun b a ↦ h_remainder_prop b a

    sorry

-- variable [DecidableEq σ] in
-- -- Define the recursive helper first as a private function.
-- noncomputable def buchberger_aux [Finite σ] (m : MonomialOrder σ)
--   (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
--     let R := buchberger_step m G
--     if h_R_ne : R = ∅ then
--       G
--     else
--       buchberger_aux m (G ∪ R)
--   -- Termination proof for buchberger_aux goes here.
--   termination_by WellFounded.wrap (IsNoetherian.wf _) (Ideal.span ((fun g => m.leadingTerm g) '' G.toSet))
--   decreasing_by
--     simp only [coe_union, gt_iff_lt, Subtype.coe_lt_coe]
--     classical
--     by_cases hG : ∀ g ∈ G, g ≠ 0
--     · -- 1) Monotonicity: ⟨LT(G)⟩ ≤ ⟨LT(G ∪ R)⟩.
--       have hsubset :
--         ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k)))
--           ⊆ ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set (MvPolynomial σ k))) := by
--         intro t ht
--         rcases ht with ⟨g, hgG, rfl⟩
--         simp only [coe_union, Set.mem_image, Set.mem_union, mem_coe]
--         exact ⟨g, by
--           have : (g ∈ (G : Set _)) := hgG
--           exact Or.inl this, rfl⟩
--       have hle :
--         Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _))
--           ≤ Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Set (MvPolynomial σ k)) : Set _)) := by
--           rw [←Finset.coe_union]
--           exact Ideal.span_mono hsubset

--       -- 2) Strictness: pick r ∈ R with LT(r) ∉ ⟨LT(G)⟩, but of course LT(r) ∈ ⟨LT(G ∪ R)⟩.
--       obtain ⟨r, hrR⟩ : ∃ r, r ∈ R := by
--         classical
--         refine Nonempty.exists_mem ?_
--         exact nonempty_iff_ne_empty.mpr h_R_ne
--       have hlt_r_notin :
--       m.leadingTerm r ∉ Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) := by
--       -- apply lemma with `p := S_polynomial m p q`
--         dsimp [R, buchberger_step] at hrR
--         rw [dif_pos hG] at hrR
--         simp only [Finset.mem_filter, Finset.mem_image] at hrR
--         obtain ⟨pq, hpq_in_pairs, hr_eq_normalForm⟩ := hrR.1
--         rw [←hr_eq_normalForm]
--         apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
--         rw [hr_eq_normalForm]
--         exact hrR.2
--       apply lt_of_le_of_ne hle
--       intro h_ideals_eq
--       have h_lt_r_in_old_ideal : m.leadingTerm r ∈ Ideal.span ((fun g ↦ m.leadingTerm g) '' ↑G) := by
--         rw [h_ideals_eq]
--         apply Ideal.subset_span
--         simp only [Set.mem_image, ←coe_union]
--         use r
--         exact ⟨mem_union_right G hrR, rfl⟩
--       exact hlt_r_notin h_lt_r_in_old_ideal
--     · have : R = ∅ := by dsimp [R, buchberger_step]; rw [dif_neg hG]
--       refine False.elim (h_R_ne this)

    -- apply lt_iff_le_and_ne.mpr
    -- · constructor
    --   · show ⋯.wrap (Ideal.span ((fun g ↦ m.leadingTerm g) '' ↑G)) ≤ ⋯.wrap (Ideal.span ((fun g ↦ m.leadingTerm g) '' (↑G ∪ ↑(buchberger_step m G))))
    --     sorry
    --   · show ⋯.wrap (Ideal.span ((fun g ↦ m.leadingTerm g) '' ↑G)) ≠ ⋯.wrap (Ideal.span ((fun g ↦ m.leadingTerm g) '' (↑G ∪ ↑(buchberger_step m G))))
    --     sorry

    -- · intro σ k hFk hDk hDσ hFσ m G
    --   exact isNoetherianRing








---------------------------------------------------------------------------------------

/-- One Buchberger pass: for an existing finite set `G`, compute all S-pairs,
reduce them by `G`, and adjoin the *nonzero* remainders. -/
noncomputable def buchbergerStep (G : Finset (MvPolynomial σ k)) :
    Finset (MvPolynomial σ k) := by
  classical
  -- Zeros in `G` are irrelevant for reduction; remove them to build the witness `hG`.
  let G' : Finset (MvPolynomial σ k) := G.filter (· ≠ 0)
  have hG' : ∀ g ∈ G', g ≠ 0 := by
    intro g hg
    rcases Finset.mem_filter.mp hg with ⟨_, hg0⟩; exact hg0
  -- All ordered distinct pairs (p,q) with p,q ∈ G'.
  let pairs := G'.offDiag           -- : Finset (MvPolynomial σ k × MvPolynomial σ k)
  -- Remainders of S-polynomials modulo the *current* reducers `G'`.
  let rems := pairs.image (fun pq => normalForm (m:=m) hG' (S_polynomial (m:=m) pq.1 pq.2))
  -- Keep only the nonzero ones; these are the new candidates to adjoin.
  exact rems.filter (· ≠ 0)

-- /-- The invariant: `span` is monotone and stays inside `I` if it started inside. -/
-- lemma span_mono (I : Ideal (MvPolynomial σ k)) (G : Finset (MvPolynomial σ k))
--   (hF : G.toSet ⊆ I) :
--   Ideal.span (buchbergerStep (m:=m) G : Set _) ≤ I := by
--   classical
--   -- Show every new remainder is in `I` using the textbook argument:
--   -- `S(p,q)` is in `I` and dividing by `G ⊆ I` keeps the remainder in `I`.
--   -- Then `span` of the union stays in `I`.
--   sorry

-- /-- If the step adds a new nonzero remainder, the initial ideal strictly gets
-- smaller (the leading term of the new remainder is not divisible by any leading
-- term in the old set). This is the key (1) in the book. -/
-- lemma lt_on_initialIdeal
--   {G : Finset (MvPolynomial σ k)}
--   (hAdd : buchbergerStep (m:=m) G ≠ G) :
--   m.initialIdeal (Ideal.span (buchbergerStep (m:=m) G : Set _))
--     < m.initialIdeal (Ideal.span (G : Set (MvPolynomial σ k))) := by
--   classical
--   -- Expand `hAdd` to extract a specific `r ≠ 0` that was adjoined.
--   -- Use your lemma "LT(r) ∈ ⟨LT(G ∪ {r})⟩ \ ⟨LT(G)⟩" (CLoS Lemma 2 of §4) to get strictness.
--   sorry

-- /-- Stabilization iff all S-pairs reduce to 0. -/
-- lemma stop_iff_all_Spair_reduce
--   {G : Finset (MvPolynomial σ k)}
--   : buchbergerStep (m:=m) G = G ↔
--     (∀ g₁ g₂ ∈ G, g₁ ≠ g₂ →
--       normalForm (m:=m) (by intro g hg; exact by decide) (S_polynomial g₁ g₂) = 0) := by
--   classical
--   -- Unfold `buchbergerStep`; the only way it equals `G` is if there is no nonzero
--   -- remainder among all S-pairs, i.e. all reduce to 0.
--   sorry

-- /-- Well-foundedness on initial ideals yields termination. -/
-- lemma terminates :
--   WellFounded (fun G₁ G₂ : Finset (MvPolynomial σ k) =>
--     initialIdeal (Ideal.span (G₁ : Set _)) < initialIdeal (Ideal.span (G₂ : Set _))) := by
--   classical
--   -- Use that `MvPolynomial σ k` is Noetherian → ACC on ideals → ACC on their images
--   -- under `initialIdeal` (monotone). Then pull back to the well-founded relation.
--   have inst : IsNoetherianRing (MvPolynomial σ k) := by
--     -- from mathlib (Hilbert basis theorem for mv-polynomials).
--     exact inferInstance
--   -- Convert ACC on ideals to `WellFounded` of `<`.
--   -- Use `Ideal.isWellFounded_lt` if available, or build from `IsNoetherian`.
--   sorry

-- /-- The actual recursive algorithm: repeatedly apply `buchbergerStep` until the
-- initial ideal stops decreasing; correctness + termination are proved below. -/
-- noncomputable def buchberger :
--     Finset (MvPolynomial σ k) := by
--   classical
--   -- Use well-founded recursion on the measure `initialIdeal (span G)`.
--   refine
--     (terminates (m:=m) (initialIdeal:=initialIdeal)).fix
--       (C := fun _ => Finset (MvPolynomial σ k))
--       (f := fun G rec =>
--         if h : buchbergerStep (m:=m) G = G then G else rec _ ?hrel) ?start
--   · -- relation proof when the step makes progress
--     intro G h
--     have hlt := lt_on_initialIdeal (m:=m) (initialIdeal:=initialIdeal) (G:=G) (by
--       -- `h` is negation of equality, so step adds something
--       have : buchbergerStep (m:=m) G ≠ G := by exact by exact fun heq => by cases h ▸ rfl
--       exact this)
--     exact hlt
--   · -- start from the given input `F`; you’ll pass it as an argument at use-site
--     exact (∅ : Finset (MvPolynomial σ k))

-- /-- Correctness: the output is a Gröbner basis of the ideal generated by the input.
-- This mirrors the textbook proof: invariants + `stop_iff_all_Spair_reduce` +
-- Buchberger criterion. -/
-- lemma buchberger_spec (F : Finset (MvPolynomial σ k))
--   (I : Ideal (MvPolynomial σ k)) (hFI : (F : Set _) ⊆ I) (hI : I ≠ ⊥ := by decide)
--   (hG0 : ∀ g ∈ F, g ≠ 0 := by intro; decide)
--   :
--   let G := buchberger (m:=m) (initialIdeal:=initialIdeal)
--   in IsGroebnerBasis m I G ∧ Ideal.span (G : Set _) = I := by
--   classical
--   -- 1) `span_mono` keeps `span G ⊆ I`; combined with `F ⊆ G` gives `span G = I`.
--   -- 2) By construction of `buchberger`, the loop ends exactly when
--   --    `buchbergerStep G = G`.
--   -- 3) Apply `stop_iff_all_Spair_reduce` + Buchberger criterion equivalence.
--   -- Fill in rewrites with your existing API lemmas.
--   sorry

-- end BuchbergerAlgorithm

-- /-- ### Helper: characterize membership in `buchbergerStep` when `G` has no zeros. -/
-- lemma mem_buchbergerStep_iff
--   (m : MonomialOrder σ) {G : Finset (MvPolynomial σ k)} (hG : ∀ g ∈ G, g ≠ 0)
--   {r : MvPolynomial σ k} :
--   r ∈ buchbergerStep (m:=m) G ↔
--     ∃ p q, p ∈ G ∧ q ∈ G ∧ p ≠ q ∧ r = normalForm (m:=m) hG (S_polynomial (m:=m) p q) ∧ r ≠ 0 := by
--   classical
--   unfold buchbergerStep
--   -- only the `if hG` branch remains
--   simp [hG, Finset.mem_filter, Finset.mem_image, Finset.mem_offDiag,
--         and_left_comm, and_assoc, exists_prop, Prod.exists, eq_comm]

-- /-- A cleaned-up version of the recursive helper with a `decreasing_by` that closes. -/
-- noncomputable def buchberger_aux_fixed [Finite σ] (m : MonomialOrder σ)
--   (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
--     let R := buchbergerStep (m:=m) G
--     if hR : R = ∅ then G else buchberger_aux_fixed m (G ∪ R)
--   termination_by WellFounded.wrap (IsNoetherian.wf _) (Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)))
--   decreasing_by
--     classical
--     -- expose the recursive branch and grab `hRne : R ≠ ∅`
--     simp [buchberger_aux_fixed]  -- introduces `hRne : buchbergerStep m G ≠ ∅`
--     set R := buchbergerStep (m:=m) G with hRdef
--     have hRne : R ≠ ∅ := by simpa [hRdef] using hRne

--     -- (i) monotonicity of span
--     have hsubset :
--       ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))) ⊆
--       ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set (MvPolynomial σ k))) := by
--       intro t ht; rcases ht with ⟨g, hg, rfl⟩; exact ⟨g, Or.inl hg, rfl⟩
--     have hle :
--       Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) ≤
--       Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set _)) :=
--       Ideal.span_mono (by simpa [← Finset.coe_union])

--     -- (ii) strictness via a witness from `R`
--     obtain ⟨r, hrR⟩ := Finset.exists_mem_of_ne_empty hRne

--     -- show that `¬ (∀ g ∈ G, g ≠ 0)` would force `R = ∅` (contradiction), so we have `hG`.
--     have hG : ∀ g ∈ G, g ≠ 0 := by
--       unfold buchbergerStep at hRdef
--       by_cases h : ∀ g ∈ G, g ≠ 0
--       · exact h
--       · simp [h] at hRdef; exact (hRne (by simpa [hRdef]))

--     -- shape of `r`
--     rcases (mem_buchbergerStep_iff (σ:=σ) (k:=k) (m:=m) hG).1 (by simpa [hRdef] using hrR) with
--       ⟨p, q, hpG, hqG, hpq, hr, hr0⟩

--     -- LT(r) is outside `⟨LT(G)⟩` by your NF lemma
--     have hLT_notin :
--       m.leadingTerm r ∉ Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) := by
--       have := leadingTerm_normalForm_not_mem_ideal_span_leadingTerm (m:=m) G hG (S_polynomial (m:=m) p q) (by simpa [hr])
--       simpa [hr] using this

--     -- but in the larger span
--     have hLT_in :
--       m.leadingTerm r ∈ Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set _)) := by
--       apply Ideal.subset_span
--       exact ⟨r, Or.inr (by simpa [Finset.mem_coe, hRdef] using hrR), rfl⟩

--     -- hence spans are unequal
--     have hne :
--       Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) ≠
--       Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set _)) := by
--       intro heq; exact hLT_notin (heq ▸ hLT_in)

--     -- combine ≤ and ≠ to get `<` on the wrapped order
--     exact lt_of_le_of_ne hle hne






-- ---------------------------------------------------------------------------------------










-- variable [DecidableEq σ] in
-- noncomputable def buchberger (F : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
--   buchberger_aux m (F.filter (· ≠ 0))


--   -- The algorithm starts with G := F.
--   -- We must first filter out any zeros from the initial set, as our algorithm requires it.
--   buchberger_aux (F.filter (· ≠ 0))

-- variable [DecidableEq σ] in
-- /--
-- Buchberger's algorithm: Given a finite generating set `F` for a polynomial ideal `I`,
-- constructs a Gröbner basis for `I`.
-- -/
-- partial def buchberger'
--     (F : Finset (MvPolynomial σ k))
--     (terminate : (Finset (MvPolynomial σ k)) → Bool := fun _ ↦ false) :
--     Finset (MvPolynomial σ k) :=
--   let rec loop (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
--     let pairs := (G.product G).filter (fun ⟨p, q⟩ ↦ p ≠ q)
--     let G' := G
--     let newElems :=
--       pairs.foldl (fun acc ⟨p, q⟩ =>
--         let r := (SPolynomial p q).reduceWith G'
--         if r ≠ 0 then acc ∪ {r} else acc
--       ) ∅
--     let Gnext := G ∪ newElems
--     if Gnext = G then G else loop Gnext
--   loop F

-- variable [DecidableEq σ] in
-- /--
-- **Buchberger's theorem**:
-- If `I = ⟨F⟩` is a nonzero polynomial ideal, then `buchberger F`
-- terminates in finitely many steps and returns a Gröbner basis of `I`.
-- -/
-- theorem Buchberger_Algorithm
--     (F : Finset (MvPolynomial σ k)) :
--     ∃ G, F ⊆ G ∧ IsGroebnerBasis m (Ideal.span F) G := by sorry

-- variable [DecidableEq σ] in
-- lemma grobner_basis_remove_redundant
--   {I : Ideal _} {G : Finset _} {p : MvPolynomial σ k}
--   (hG : IsGroebnerBasis m I G)
--   (hpG : p ∈ G)
--   (hLT : leadingTerm m p ∈ Ideal.span ((G.erase p).image (fun g ↦ leadingTerm m g))) :
--   IsGroebnerBasis m I (G.erase p) := by sorry

-- def countdown (n : Nat) : List Nat :=
--   match n with
--   | 0 => []
--   | n' + 1 => n' :: countdown n'

-- def countdown' (n : Nat) : List Nat :=
--   if n == 0 then []
--   else
--     let n' := n - 1
--     n' :: countdown' n'

-- def countdown'' (n : Nat) : List Nat :=
--   if n = 0 then []
--   else
--     let n' := n - 1
--     n' :: countdown' n'
