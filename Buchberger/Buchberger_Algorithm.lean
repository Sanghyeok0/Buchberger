import Buchberger.GroebnerBases



variable {σ : Type*}
variable {m : MonomialOrder σ}

section Field

variable {k : Type*} [Field k] [DecidableEq k]

instance Field.isNoetherianRing :
    IsNoetherianRing k := by
  refine isNoetherian_iff'.mpr ?_
  exact Finite.to_wellFoundedGT

namespace MvPolynomial

set_option maxHeartbeats 0

open MonomialOrder MvPolynomial Finset

variable [Fintype σ] in
def reduces_to_zero (G : Finset (MvPolynomial σ k)) (f : MvPolynomial σ k) : Prop :=
∃ (A : MvPolynomial σ k → MvPolynomial σ k),
  (f = ∑ g ∈ G, (A g) * g) ∧ ∀ g ∈ G, (A g) * g ≠ 0 → m.degree ((A g) * g) ≼[m] m.degree f

variable (m) [DecidableEq σ] in
noncomputable def buchberger_step_old (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
  -- We need a proof that G' contains no zeros to call normalForm.
  if hG : ∀ g ∈ G, g ≠ 0 then
    -- 1. FOR each pair {p, q}
    let pairs := G.offDiag
    -- 2. r := S(p,q) mod G'
    let remainders : Finset (MvPolynomial σ k) := pairs.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))
    -- 3. Filter for the non-zero ones.
    remainders.filter (· ≠ 0)
  else
    -- If the input basis contains zero, it's an invalid state, but we must return something.
    -- Returning the empty set is a safe default.
    ∅

omit [DecidableEq k] in
lemma normalForm_not_divisible_by_basis
  (G : Finset (MvPolynomial σ k)) (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k)
  (d : σ →₀ ℕ) (hd_in_support : d ∈ (normalForm m hG p).support) :
  ∀ b ∈ G, ¬ (m.degree b ≤ d) := by
  have h_remainder_prop := (normalForm_spec' m hG p).2.2

  specialize h_remainder_prop d hd_in_support

  intro b hb_in_G
  specialize h_remainder_prop b hb_in_G
  exact h_remainder_prop

-- variable [DecidableEq σ] in
-- lemma leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
--   (G : Finset (MvPolynomial σ k))
--   (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k) (h_rem_ne_zero : normalForm m hG p ≠ 0) :
--   m.leadingTerm (normalForm m hG p) ∉ Ideal.span ((fun g => m.leadingTerm g) '' G.toSet) := by

--     -- Let `r` be the remainder.
--     let r := normalForm m hG p

--     -- Let `I_G` be the ideal generated by the basis `G`.
--     let I_G := Ideal.span (G : Set (MvPolynomial σ k))

--     -- The ideal `<LT(G)>` is generated by `{LT(g) | g ∈ G}`.
--     -- Over a field, this is the same as the monomial ideal generated by `{LM(g) | g ∈ G}`.
--     let I_LT_G := Ideal.span ((fun g => m.leadingTerm g) '' G.toSet)
--     let I_LM_G := monomialIdeal k (G.image m.degree).toSet

--     have h_ideals_eq : I_LT_G = I_LM_G := by sorry

--     have h_span_LT_eq_initialIdeal :
--       Ideal.span ((fun g => m.leadingTerm g) '' G.toSet) = initialIdeal m I_G := by sorry

--     rw [h_span_LT_eq_initialIdeal, initialIdeal_is_monomial_ideal]
--     intro h_lt_r_in_ideal
--     have h_lm_r_in_ideal : monomial (m.degree r) 1 ∈ monomialIdeal k (LM_set m I_G) := by
--       let lc_r := m.leadingCoeff r
--       have hlc_ne_zero : lc_r ≠ 0 := m.leadingCoeff_ne_zero_iff.mpr h_rem_ne_zero
--       rw [show monomial (m.degree r) 1 = C (lc_r⁻¹) * m.leadingTerm r by {
--         rw [leadingTerm, C_mul_monomial, inv_mul_cancel₀ hlc_ne_zero] }]
--       exact Ideal.mul_mem_left _ _ h_lt_r_in_ideal

--     have h_lm_in : monomial (m.degree r) 1 ∈ I_LM_G := by
--       -- monomial (deg r) 1 = C (lc_r⁻¹) * LT(r)
--       have : monomial (m.degree r) 1 = C (lc_r⁻¹) * m.leadingTerm r := by
--         simpa [leadingTerm, C_mul_monomial, inv_mul_cancel₀ hlc_ne_zero]
--       -- use ideal closure under left-multiplication
--       simpa [this] using Ideal.mul_mem_left _ _ h_in_LM
--     rcases (mem_monomialIdeal_iff_divisible.mp (by simpa [I_LM_G] using h_lm_in))


--     rw [mem_monomialIdeal_iff_divisible] at h_lm_r_in_ideal

--     -- This gives `∃ α ∈ (G.image m.degree).toSet, α ≤ m.degree r`.
--     -- Unpacking the image, this means `∃ g ∈ G, m.degree g ≤ m.degree r`.
--     obtain ⟨LMg, ⟨g, ⟨hg_in_I_G, hg_nezero, rfl⟩⟩, h_deg_le⟩ := h_lm_r_in_ideal

--     unfold I_G Ideal.span at hg_in_I_G
--     rw [Submodule.mem_span_finset] at hg_in_I_G
--     obtain ⟨f, ⟨hf_supp_G, hfg⟩⟩ := hg_in_I_G
--     rw [←hfg] at h_deg_le


--     have h_remainder_prop := (normalForm_spec m hG p).2.2
--     have h_deg_in_support : m.degree r ∈ r.support :=
--       MonomialOrder.degree_mem_support h_rem_ne_zero
--     specialize h_remainder_prop (m.degree r) h_deg_in_support
--     have : ∀ b ∈ G, ¬m.degree b ≤ m.degree r := by exact fun b a ↦ h_remainder_prop b a

--     sorry

variable [DecidableEq σ] in
lemma leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
  (G : Finset (MvPolynomial σ k))
  (hG : ∀ g ∈ G, g ≠ 0) (p : MvPolynomial σ k)
  (h_rem_ne_zero : normalForm m hG p ≠ 0) :
  m.leadingTerm (normalForm m hG p) ∉ Ideal.span ((fun g => m.leadingTerm g) '' G.toSet) := by
  classical
  -- Let r be the remainder
  set r := normalForm m hG p
  -- Prove by contradiction
  intro hLT_r_in_span

  -- `span(LT(G))` is contained in the monomial ideal generated by `{LM(g) | g ∈ G}`
  have h_span_le :
      Ideal.span ((fun g => m.leadingTerm g) '' G.toSet)
        ≤ monomialIdeal k ((G.image m.degree).toSet) := by
    refine Ideal.span_le.mpr ?_
    intro t ht
    rcases ht with ⟨g, hgG, rfl⟩
    -- First, the generator `monomial (LM g) 1` is in that monomial ideal
    have hLMg :
        monomial (m.degree g) (1 : k)
          ∈ monomialIdeal k ((G.image m.degree).toSet) := by
      -- Show `m.degree g ∈ (G.image m.degree).toSet`
      have hgG' : g ∈ G := by simpa [Finset.mem_coe] using hgG
      have hα : m.degree g ∈ ((G.image m.degree).toSet) := by
        -- switch to finset membership and back to set
        simpa [Finset.mem_coe] using (Finset.mem_image.mpr ⟨g, hgG', rfl⟩)
      exact (mem_monomialIdeal_iff_divisible.mpr ⟨m.degree g, hα, le_rfl⟩)
    -- `LT g = C (lc g) * monomial (LM g) 1`, so it's in the ideal
    --simpa [leadingTerm, C_mul_monomial] using Ideal.mul_mem_left _ _ hLMg
    simp only [ SetLike.mem_coe]
    unfold leadingTerm
    have : (monomial (m.degree g)) (m.leadingCoeff g) = C (m.leadingCoeff g) * (monomial (m.degree g) (1 : k)) := by rw [C_mul_monomial, mul_one]
    rw [this]
    exact Ideal.mul_mem_left _ _ hLMg

  -- Transport `LT r` into that monomial ideal
  have hLT_r_in_mono :
      m.leadingTerm r ∈ monomialIdeal k ((G.image m.degree).toSet) :=
    h_span_le hLT_r_in_span

  -- Normalize to `LM r` inside the same monomial ideal
  set lc_r := m.leadingCoeff r
  have hlc_ne_zero : lc_r ≠ 0 := m.leadingCoeff_ne_zero_iff.mpr h_rem_ne_zero
  have hLM_r_in_mono :
      monomial (m.degree r) (1 : k)
        ∈ monomialIdeal k ((G.image m.degree).toSet) := by
    have : monomial (m.degree r) (1 : k) = C (lc_r⁻¹) * m.leadingTerm r := by
      simp [leadingTerm, C_mul_monomial]
      dsimp [lc_r]
      rw [inv_mul_cancel₀ hlc_ne_zero]
    simpa [this] using Ideal.mul_mem_left _ _ hLT_r_in_mono


  -- Divisibility in the monomial ideal ⇒ some `m.degree g ≤ m.degree r` with `g ∈ G`
  rcases (mem_monomialIdeal_iff_divisible.mp hLM_r_in_mono)
    with ⟨α, hα_in, hα_le⟩
  simp only [coe_image, Set.mem_image, mem_coe] at hα_in
  rcases hα_in with ⟨g, hgG, rfl⟩

  -- Remainder property forbids any `LM g` (with `g ∈ G`) from dividing `LM r`
  have h_remainder_prop := (normalForm_spec m hG p).2.2
  have h_deg_in_support : m.degree r ∈ r.support :=
    MonomialOrder.degree_mem_support h_rem_ne_zero
  specialize h_remainder_prop (m.degree r) h_deg_in_support
  have forbid : ∀ b ∈ G, ¬ m.degree b ≤ m.degree r :=
    fun b hb => h_remainder_prop b hb

  exact (forbid g hgG) hα_le

variable (m) [DecidableEq σ] in
-- Define the recursive helper first as a private function.
noncomputable def buchberger_aux_old [Finite σ]
  (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
    -- let R := buchberger_step_old m G
    if h_R_ne : (buchberger_step_old m G) = ∅ then
      G
    else
      buchberger_aux_old (G ∪ (buchberger_step_old m G))
  -- Termination proof for buchberger_aux goes here.
  termination_by
  WellFounded.wrap
    (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
    (Ideal.span ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))))
  decreasing_by
    simp only [coe_union, gt_iff_lt, Subtype.coe_lt_coe]
    classical
    by_cases hG : ∀ g ∈ G, g ≠ 0
    · -- 1) Monotonicity: ⟨LT(G)⟩ ≤ ⟨LT(G ∪ R)⟩.
      have hsubset :
        ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k)))
          ⊆ ((fun g => m.leadingTerm g) '' ((G ∪ (buchberger_step_old m G) : Finset _) : Set (MvPolynomial σ k))) := by
        intro t ht
        rcases ht with ⟨g, hgG, rfl⟩
        simp only [coe_union, Set.mem_image, Set.mem_union, mem_coe]
        exact ⟨g, by
          have : (g ∈ (G : Set _)) := hgG
          exact Or.inl this, rfl⟩
      have hle :
        Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _))
          ≤ Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ (buchberger_step_old m G) : Set (MvPolynomial σ k)) : Set _)) := by
          rw [←Finset.coe_union]
          exact Ideal.span_mono hsubset

      -- 2) Strictness: pick r ∈ R with LT(r) ∉ ⟨LT(G)⟩, but of course LT(r) ∈ ⟨LT(G ∪ R)⟩.
      obtain ⟨r, hrR⟩ : ∃ r, r ∈ (buchberger_step_old m G) := by
        classical
        refine Nonempty.exists_mem ?_
        exact nonempty_iff_ne_empty.mpr h_R_ne
      have hlt_r_notin :
      m.leadingTerm r ∉ Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) := by
      -- apply lemma with `p := S_polynomial m p q`
        dsimp [buchberger_step_old] at hrR
        rw [dif_pos hG] at hrR
        simp only [Finset.mem_filter, Finset.mem_image] at hrR
        obtain ⟨pq, hpq_in_pairs, hr_eq_normalForm⟩ := hrR.1
        rw [←hr_eq_normalForm]
        apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
        rw [hr_eq_normalForm]
        exact hrR.2
      apply lt_of_le_of_ne hle
      intro h_ideals_eq
      have h_lt_r_in_old_ideal : m.leadingTerm r ∈ Ideal.span ((fun g ↦ m.leadingTerm g) '' ↑G) := by
        rw [h_ideals_eq]
        apply Ideal.subset_span
        simp only [Set.mem_image, ←coe_union]
        use r
        exact ⟨mem_union_right G hrR, rfl⟩
      exact hlt_r_notin h_lt_r_in_old_ideal
    · have : (buchberger_step_old m G) = ∅ := by dsimp [buchberger_step_old]; rw [dif_neg hG]
      refine False.elim (h_R_ne this)

variable (m) [DecidableEq σ] in
noncomputable def buchberger_step [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0) :
  Finset (MvPolynomial σ k) :=
  let R_index : Finset (MvPolynomial σ k × MvPolynomial σ k) :=
    F.offDiag.filter (fun pq =>
      normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0)
  if h_empty : R_index = ∅ then
    F
  else
    -- pick *some* element (no order needed)
    have : Nonempty R_index := by
      refine Nonempty.to_subtype ?_
      exact nonempty_iff_ne_empty.mpr h_empty
    let pq := (Classical.choice this).val
    let r  := normalForm m hF (S_polynomial m pq.1 pq.2)
    F ∪ {r}

variable (m) [DecidableEq σ] in
lemma buchberger_step_sup [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0) :
  F ⊆ buchberger_step m hF := by
  unfold buchberger_step
  dsimp
  by_cases h_empty : {pq ∈ F.offDiag | ¬normalForm m hF (S_polynomial m pq.1 pq.2) = 0} = ∅
  · rw [dif_pos h_empty]
  · rw [dif_neg h_empty]
    exact subset_union_left

-- variable (m) [DecidableEq σ] in
-- lemma buchberger_step_eq_union [Finite σ]
--   {F : Finset (MvPolynomial σ k)} (hF : ∀ f ∈ F, f ≠ 0)
--   (h_ne : buchberger_step m hF ≠ F) :
--   ∃ r, buchberger_step m hF = F ∪ {r} ∧ r ∉ F := by
--   classical
--   unfold buchberger_step at h_ne ⊢
--   -- unfold and split cases
--   by_cases h_empty : {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} = ∅
--   · -- contradiction: in this case F' = F
--     simp [h_empty] at h_ne
--   · -- the non-empty case
--     simp [h_empty]
--     -- define r explicitly
--     have h_empty' : Nonempty {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} := by
--       have : {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} ≠ ∅ := by exact h_empty
--       rw [←Finset.nonempty_iff_ne_empty] at this
--       exact Nonempty.to_subtype this
--     let pq := (Classical.choice h_empty').val
--     let r  := normalForm m hF (S_polynomial m pq.1 pq.2)
--     use r
--     refine ⟨rfl, ?_⟩
--     intro hr
--     have h_union_neq : F ∪ {r} ≠ F := by
--       rw [dif_neg h_empty] at h_ne
--       exact h_ne
--     have h_union_eq : F ∪ {r} = F := by refine union_eq_left.mpr ?_; exact singleton_subset_iff.mpr hr
--     exact h_union_neq h_union_eq

variable (m) [DecidableEq σ] in
lemma buchberger_step_is_zero_free [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0) :
  ∀ g ∈ buchberger_step m hF, g ≠ 0 := by
  -- Unfold the definition once and split on the same cases
  -- as in the definition (reuse the same `R_index`).
  -- This ensures the choices match on both sides.
  -- reintroduce the same local `R_index` as in the def above
  let R_index : Finset (MvPolynomial σ k × MvPolynomial σ k) :=
    F.offDiag.filter (fun pq =>
      normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0)

  -- We now rewrite the definition into the two branches.
  -- Case 1: R_index = ∅
  by_cases h_empty : {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} = ∅
  · -- In this branch, buchberger_step m hF = F
    intro g hg_mem
    -- show g ≠ 0
    intro hg_zero
    -- from membership in the result (= F), use hF
    have : g ≠ 0 := hF g (by simpa [buchberger_step, R_index, h_empty] using hg_mem)
    exact this hg_zero

  · -- Case 2: R_index ≠ ∅
    unfold buchberger_step
    intro g hg_mem hg_zero
    dsimp only [Lean.Elab.WF.paramLet] at hg_mem
    rw [dif_neg h_empty] at hg_mem
    have : ¬ g ∈ F := by exact fun a ↦ hF g a hg_zero
    simp at hg_mem
    rw [or_iff_not_imp_left] at hg_mem
    have hg_eq_normal := hg_mem this; clear this
    rw [hg_zero] at hg_eq_normal
    have : {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} ≠ ∅ := by exact
      h_empty
    have h_empty' : Nonempty {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} := by
      have : {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} ≠ ∅ := by exact h_empty
      rw [←Finset.nonempty_iff_ne_empty] at this
      exact Nonempty.to_subtype this
    let chosen_pq := (Classical.choice h_empty').val
    have h_pq_in_R_index : chosen_pq ∈ R_index := by exact (Classical.choice h_empty').property
    have h_filter_prop := (Finset.mem_filter.mp h_pq_in_R_index).2
    have h_is_zero : normalForm m hF (S_polynomial m chosen_pq.1 chosen_pq.2) = 0 := by
      exact hg_eq_normal.symm
    exact h_filter_prop h_is_zero

variable (m) [DecidableEq σ] in
lemma buchberger_step_witness [Finite σ]
  {F : Finset (MvPolynomial σ k)} (hF : ∀ f ∈ F, f ≠ 0)
  (h_ne : buchberger_step m hF ≠ F) :
  ∃ pq ∈ F.offDiag,
    let r := normalForm m hF (S_polynomial m pq.1 pq.2)
    r ≠ 0 ∧ buchberger_step m hF = F ∪ {r} := by
    classical
    unfold buchberger_step at h_ne ⊢
    -- unfold and split cases
    by_cases h_empty : {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} = ∅
    · -- contradiction: in this case F' = F
      simp only [ne_eq, h_empty, ↓reduceDIte, not_true_eq_false] at h_ne
    · -- the non-empty case
      simp only [mem_offDiag, ne_eq, h_empty, ↓reduceDIte]
      -- define r explicitly
      have h_empty' : Nonempty {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} := by
        have : {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0} ≠ ∅ := by exact h_empty
        rw [←Finset.nonempty_iff_ne_empty] at this
        exact Nonempty.to_subtype this
      let pq := (Classical.choice h_empty').val
      let r  := normalForm m hF (S_polynomial m pq.1 pq.2)
      have hpq := (Classical.choice h_empty').property
      have hpq_off : pq ∈ F.offDiag := by exact mem_of_mem_filter pq hpq
      have hpq_nz  : normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0 := (Finset.mem_filter.mp hpq).2
      use pq
      constructor
      · exact mem_offDiag.mp hpq_off
      · constructor
        · exact hpq_nz
        · rfl

variable (m) [DecidableEq σ] in
noncomputable def buchberger_alg [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0) :
  Finset (MvPolynomial σ k) :=
  let F' := buchberger_step m hF
  if h_stable : F' = F then
    F
  else
    -- If the set grew, we must prove the new set is zero-free and recurse.
    have hF' : ∀ f ∈ F', f ≠ 0 := buchberger_step_is_zero_free m hF
    buchberger_alg hF'

-- The termination argument is identical to the previous versions.
  termination_by
  WellFounded.wrap
    (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
    (Ideal.span ((fun f => m.leadingTerm f) '' (F : Set (MvPolynomial σ k))))
  decreasing_by

    simp only [gt_iff_lt, Subtype.coe_lt_coe]
    apply lt_of_le_of_ne
    · -- 1) Monotonicity: ⟨LT(F)⟩ ≤ ⟨LT(F ∪ {r})⟩.
      apply Ideal.span_mono
      intro t ht
      rcases ht with ⟨f, hfF, rfl⟩
      simp only [Set.mem_image, mem_coe]
      exact ⟨f, (buchberger_step_sup m hF) hfF, rfl⟩
    · intro h_eq
      obtain ⟨pq, -, hr_ne_zero, hF'_eq⟩ := buchberger_step_witness m hF h_stable
      let r := normalForm m hF (S_polynomial m pq.1 pq.2)
      have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' ↑F) :=
        leadingTerm_normalForm_not_mem_ideal_span_leadingTerm F hF (S_polynomial m pq.1 pq.2) hr_ne_zero
      have h_eq' : Ideal.span ((fun f ↦ m.leadingTerm f) '' (F : Set _)) =
            Ideal.span ((fun f ↦ m.leadingTerm f) '' (F' : Set (MvPolynomial σ k))) := by
        injection h_eq
      have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' (↑F)) := by
        rw [h_eq']
        apply Ideal.subset_span
        simp only [Set.mem_image, mem_coe]
        use r
        constructor
        · unfold F' r; rw [hF'_eq]
          refine mem_union_right F ?_
          exact mem_singleton.mpr rfl
        · rfl
      exact hLT_r_notin hLT_r_in

variable (m) [DecidableEq σ] in
theorem Buchberger_Alg [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  {I : Ideal (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0)
  (hspan : I = Ideal.span F) :
  ∃ G : Finset (MvPolynomial σ k),
  F ⊆ G ∧
  IsGroebnerBasis m I G := by
  -- 1. The state of our recursion is a Finset known to be zero-free.
  let State := { G : Finset (MvPolynomial σ k) // ∀ g ∈ G, g ≠ 0 }

  -- 2. The termination
  let H (s : State) := OrderDual.toDual (@Ideal.span (MvPolynomial σ k) _ (s.val.image (leadingTerm m)))
  let R (s₁ s₂ : State) : Prop := H s₁ < H s₂
  have h_wf : WellFounded R := InvImage.wf H (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))

  -- 3. Define the function for one step of the recursion.
  let buchberger_step_fn (G_sub : State)
    (rec_call : ∀ (G'_sub : State), R G'_sub G_sub → State) : State :=

    -- Unpack the current state
    let G := G_sub.val
    let hG := G_sub.property

    -- Compute the non-zero remainders.
    let new := (G.offDiag.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
    ----------------------------------------------
    if hR_empty : new = ∅ then
      -- Base case: No new remainders. The basis is stable. Return it.
      G_sub
    else
      -- Recursive step: Add the remainders and recurse.
      let G' := G ∪ new
      have hG' : ∀ g ∈ G', g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
        | inl hg_in_G => exact hG g hg_in_G
        | inr hg_in_new => unfold new at hg_in_new; rw [mem_filter] at hg_in_new; exact hg_in_new.2

      -- We must prove the new state is "smaller" to make the recursive call.
      have h_decreasing : R ⟨G', hG'⟩ G_sub := by
        dsimp [R, H, OrderDual.toDual, OrderDual.ofDual]
        -- This is the full `decreasing_by` proof.
        apply lt_of_le_of_ne
        · apply Ideal.span_mono; simp only [coe_image]
          refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          unfold G'; exact subset_union_left
        · intro h_ideals_eq
          simp only [coe_image, EmbeddingLike.apply_eq_iff_eq] at h_ideals_eq
          obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr hR_empty)
          have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' G) := by
            unfold new at hr
            simp only [ne_eq, mem_filter, mem_image] at hr
            obtain ⟨⟨pq, hpq⟩ , hr_nezero⟩ := hr
            rw [←hpq.2]
            apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
            rw [hpq.2]
            exact hr_nezero
          have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' G) := by
            rw [←h_ideals_eq]
            apply Ideal.subset_span
            simp only [Set.mem_image, mem_coe]
            use r
            exact ⟨by unfold G'; exact mem_union_right G hr, rfl⟩
          exact hLT_r_notin hLT_r_in

      rec_call ⟨G', hG'⟩ h_decreasing
    ----------------------------------------------

  let F₀_sub : State := ⟨F.filter (· ≠ 0), fun g hg => (Finset.mem_filter.mp hg).2⟩
  have hF_eq_F₀ : F = F₀_sub.val := Eq.symm (filter_true_of_mem hF)
  let G_sub := @WellFounded.fix State (fun _ => State) R h_wf buchberger_step_fn F₀_sub
  let G := G_sub.val
  use G
  have h_F_sub_G : F ⊆ G := by
    rw [hF_eq_F₀]
    unfold G G_sub
    apply h_wf.induction
      (C := fun s => s.val ⊆ (h_wf.fix buchberger_step_fn s).val)
      F₀_sub
    intro s IH
    let hG := s.property
    let new := (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

    rw [WellFounded.fix_eq]
    unfold buchberger_step_fn
    by_cases h_new_empty : new = ∅
    · rw [dif_pos h_new_empty]
    · rw [dif_neg h_new_empty]
      have h_s_sub_union : s.val ⊆ s.val ∪ new := subset_union_left
      have : ∀ g ∈ ↑s ∪ new, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
          | inl hg_in_G => exact hG g hg_in_G
          | inr hg_in_new => unfold new at hg_in_new; rw [mem_filter] at hg_in_new; exact hg_in_new.2
      let s' : State := ⟨s.val ∪ new, this⟩
      have h_decreasing : R s' s := by
        unfold R H
        simp only [ne_eq, coe_image, OrderDual.toDual_lt_toDual]
        obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_new_empty)
        apply lt_of_le_of_ne
        · apply Ideal.span_mono
          refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          unfold s'; exact subset_union_left
        · intro h_ideals_eq
          have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            unfold new at hr
            simp only [ne_eq, mem_filter, mem_image] at hr
            obtain ⟨⟨pq, hpq⟩ , hr_nezero⟩ := hr
            rw [←hpq.2]
            apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
            rw [hpq.2]
            exact hr_nezero

          have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            rw [h_ideals_eq]
            apply Ideal.subset_span
            simp only [Set.mem_image, mem_coe]
            use r
            exact ⟨by unfold s'; exact mem_union_right s hr, rfl⟩
          exact hLT_r_notin hLT_r_in
      specialize IH s' h_decreasing
      exact Finset.Subset.trans h_s_sub_union IH


  have hG_nonzero : ∀ g ∈ G, g ≠ 0 := by
    exact G_sub.property

  have h_I_eq_span_G : I = Ideal.span G := by
    rw [hspan, hF_eq_F₀]
    apply h_wf.induction
      (C := fun s => Ideal.span s.val = @Ideal.span (MvPolynomial σ k) _ (WellFounded.fix h_wf buchberger_step_fn s).val)
      F₀_sub
    intro s ih
    let hG := s.property
    rw [WellFounded.fix_eq]
    dsimp [buchberger_step_fn]
    let new := (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
    by_cases h_new_empty : new = ∅
    · rw [if_pos h_new_empty]
    · rw [if_neg h_new_empty]
      have : ∀ g ∈ ↑s ∪ new, g ≠ 0 := by
        intro g hg
        cases mem_union.mp hg with
          | inl hg_in_G => exact hG g hg_in_G
          | inr hg_in_new => unfold new at hg_in_new; rw [mem_filter] at hg_in_new; exact hg_in_new.2
      let s' : State := ⟨s.val ∪ new, this⟩

      have h_decreasing : R s' s := by
        unfold R H
        simp only [coe_image, OrderDual.toDual_lt_toDual]
        obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_new_empty)
        apply lt_of_le_of_ne
        · apply Ideal.span_mono
          refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          unfold s'; exact subset_union_left
        · intro h_ideals_eq
          have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            unfold new at hr
            simp only [mem_filter, mem_image] at hr
            obtain ⟨⟨pq, hpq⟩ , hr_nezero⟩ := hr
            rw [←hpq.2]
            apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
            rw [hpq.2]
            exact hr_nezero

          have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' s) := by
            rw [h_ideals_eq]
            apply Ideal.subset_span
            simp only [Set.mem_image, mem_coe]
            use r
            exact ⟨by unfold s'; exact mem_union_right s hr, rfl⟩
          exact hLT_r_notin hLT_r_in

      rw [← ih s' h_decreasing]
      apply le_antisymm
      · apply Ideal.span_mono
        unfold s'
        simp only [coe_union, Set.subset_union_left]
      · rw [Ideal.span_le]
        unfold s'
        simp only [coe_union, Set.union_subset_iff]
        constructor
        · exact Ideal.subset_span
        · unfold new
          simp only [coe_filter, mem_image, mem_offDiag]
          rw [Set.subset_def]
          intro r hr_in_new
          obtain ⟨⟨pq, hpq_in_offDiag, hr_eq_normalForm⟩, hr_ne_zero⟩ := hr_in_new
          rw [← hr_eq_normalForm]

          let S := S_polynomial m pq.1 pq.2
          have h_spec := normalForm_spec' m s.property S
          let q := quotients m s.property S
          let q_sum := q.sum (fun (g : ↥s.val) (h : MvPolynomial σ k) => h * g.val)

          have h_r_eq_sub : r = S - q_sum := by
            have : S = q_sum + r := by
              rw [h_spec.1]
              unfold q_sum q quotients
              congr
            exact eq_sub_of_add_eq' (id (Eq.symm this))
          rw [hr_eq_normalForm, h_r_eq_sub]
          apply Ideal.sub_mem
          · -- First goal: `S ∈ Ideal.span s.val`.
            unfold S S_polynomial
            let I_s := Ideal.span (s.val : Set (MvPolynomial σ k))
            have hp_in_I : pq.1 ∈ I_s := Ideal.subset_span (hpq_in_offDiag.1)
            have hq_in_I : pq.2 ∈ I_s := Ideal.subset_span (hpq_in_offDiag.2.1)
            exact Ideal.sub_mem _ (Ideal.mul_mem_left _ _ hp_in_I) (Ideal.mul_mem_left _ _ hq_in_I)

          · -- Second goal: `q_sum ∈ Ideal.span s.val`.
            unfold q_sum
            rw [Finsupp.sum]
            apply sum_mem
            intro g_sub _
            -- `g_sub` is `⟨g, hg_in_s⟩` of type `↥s.val`.
            -- The term is `(q g_sub) * g_sub.val`.
            apply Ideal.mul_mem_left
            apply Ideal.subset_span
            exact g_sub.property

  have h_G_is_GB : IsGroebnerBasis m I G := by
    apply (Buchberger_criterion m hG_nonzero h_I_eq_span_G).mpr
    intro p q hp hq h_ne
    have h_fix_eq := WellFounded.fix_eq h_wf buchberger_step_fn G_sub
    let new := (G.offDiag.image (fun pq => normalForm m hG_nonzero (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

    have h_new_is_empty : new = ∅ := by sorry
      -- let P (s : State) : Prop :=
      --   let G_final := (WellFounded.fix h_wf buchberger_step_fn s).val
      --   let hG_final := (WellFounded.fix h_wf buchberger_step_fn s).property
      --   let R_final := (G_final.offDiag.image (fun pq => normalForm m hG_final (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
      --   R_final = ∅


    by_contra h_rem_ne_zero

    -- If the remainder is non-zero, it would be in `new`.
    have h_rem_in_new : normalForm m hG_nonzero (S_polynomial m p q) ∈ new := by
      dsimp [new]
      apply Finset.mem_filter.mpr
      constructor
      · simp only [mem_image, mem_offDiag]
        use ⟨p, q⟩
      · exact h_rem_ne_zero

    rw [h_new_is_empty] at h_rem_in_new
    exact Finset.notMem_empty _ h_rem_in_new

  exact ⟨h_F_sub_G, h_G_is_GB⟩






      -- by_contra h_new_ne_empty
      -- unfold buchberger_step_fn at h_fix_eq
      -- rw [dif_neg h_new_ne_empty] at h_fix_eq
      -- have : ∀ g ∈ G ∪ new, g ≠ 0 := by
      --   intro g hg
      --   cases mem_union.mp hg with
      --     | inl hg_in_G => exact hG_nonzero g hg_in_G
      --     | inr hg_in_new => unfold new at hg_in_new; rw [mem_filter] at hg_in_new; exact hg_in_new.2
      -- let G'_sub : State := ⟨G ∪ new, this⟩
      -- have h_decreasing : R G'_sub G_sub := by
      --   unfold R H
      --   simp only [coe_image, OrderDual.toDual_lt_toDual]
      --   obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_new_ne_empty)
      --   apply lt_of_le_of_ne
      --   · apply Ideal.span_mono
      --     refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
      --     unfold G'_sub; exact subset_union_left
      --   · intro h_ideals_eq
      --     have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' G_sub) := by
      --       unfold new at hr
      --       simp only [mem_filter, mem_image] at hr
      --       obtain ⟨⟨pq, hpq⟩ , hr_nezero⟩ := hr
      --       rw [←hpq.2]
      --       apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
      --       rw [hpq.2]
      --       exact hr_nezero

      --     have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' G_sub) := by
      --       rw [h_ideals_eq]
      --       apply Ideal.subset_span
      --       simp only [Set.mem_image, mem_coe]
      --       use r
      --       exact ⟨by unfold G'_sub; exact mem_union_right G_sub hr, rfl⟩
      --     exact hLT_r_notin hLT_r_in
      -- have h_new_sets_are_equal :
      --   new = (G_sub.val.offDiag.image (fun pq => normalForm m G_sub.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0) := by
      --   -- This is true because `G = G_sub.val` and `hG_nonzero = G_sub.property`.
      --   dsimp [new]
      -- rw [h_new_sets_are_equal] at h_new_ne_empty
      -- dsimp only [Lean.Elab.WF.paramLet] at h_fix_eq
      -- rw [WellFounded.fix_eq] at h_fix_eq
      -- rw [dif_neg h_new_ne_empty] at h_fix_eq
      -- have h_R_G_sub_G_sub : R G_sub G_sub := by

      -- have h_G_sub_eq_fix_G' : G_sub = WellFounded.fix h_wf buchberger_step_fn G'_sub := by
      --   dsimp only [Lean.Elab.WF.paramLet] at h_fix_eq
      --   rw [if_neg h_new_ne_empty] at h_fix_eq
      --   exact h_fix_eq

      -- dsimp only [Lean.Elab.WF.paramLet] at h_fix_eq
      -- rw [WellFounded.fix_eq] at h_fix_eq





      -- let P (s : State) : Prop :=
      --   let G_final := (WellFounded.fix h_wf buchberger_step_fn s).val
      --   let hG_final := (WellFounded.fix h_wf buchberger_step_fn s).property
      --   let R_final := (G_final.offDiag.image (fun pq => normalForm m hG_final (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
      --   R_final = ∅

      -- have h_induction_step : ∀ (s : State), (∀ (s_smaller : State), R s_smaller s → P s_smaller) → P s := by
      --   intro s ih

      --   dsimp [P]
      --   rw [WellFounded.fix_eq]
      --   let new_s := (s.val.offDiag.image (fun pq => normalForm m s.property (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
      --   by_cases h_new_s_empty : new_s = ∅
      --   · -- Case 1: `new_s` is empty. The algorithm terminates and returns `s`.
      --     unfold new_s at h_new_s_empty
      --     have h_fix_eq_s : WellFounded.fix h_wf buchberger_step_fn s = s := by
      --       rw [WellFounded.fix_eq]
      --       dsimp [buchberger_step_fn]
      --       rw [if_pos h_new_s_empty]
      --     rw [←h_fix_eq_s, WellFounded.fix_eq] at h_new_s_empty
      --     exact h_new_s_empty



         -- Case 2: `new_s` is not empty. The algorithm recurses.
          -- sorry
          -- unfold buchberger_step_fn
          -- let s' : State := ⟨s.val ∪ new_s, fun g hg =>
          --   by
          --     cases mem_union.mp hg with
          --     | inl hgG => exact s.property g hgG
          --     | inr hg_new => unfold new_s at hg_new; rw [mem_filter] at hg_new; exact hg_new.2⟩
          -- have h_decreasing_s' : R s' s := by
          --   unfold R H
          --   simp only [coe_image, OrderDual.toDual_lt_toDual]
          --   obtain ⟨r, hr⟩ := by refine Nonempty.exists_mem (nonempty_iff_ne_empty.mpr h_new_s_empty)
          --   apply lt_of_le_of_ne
          --   · apply Ideal.span_mono
          --     refine Set.image_subset m.leadingTerm ?_; simp only [coe_subset]
          --     unfold s'; exact subset_union_left
          --   · intro h_ideals_eq
          --     -- pick the witness r ∈ new_s and use the normalForm property
          --     have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' s.val) := by
          --       unfold new_s at hr
          --       simp only [mem_filter, mem_image] at hr
          --       obtain ⟨⟨pq, hpq⟩ , hr_nezero⟩ := hr
          --       rw [←hpq.2]
          --       apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
          --       rw [hpq.2]
          --       exact hr_nezero
          --     have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' s.val) := by
          --       rw [h_ideals_eq]
          --       apply Ideal.subset_span
          --       simp only [Set.mem_image, mem_coe]
          --       use r
          --       exact ⟨by unfold s'; exact mem_union_right s hr, rfl⟩
          --     exact hLT_r_notin hLT_r_in
          -- have h_fix_eq : WellFounded.fix h_wf buchberger_step_fn s = WellFounded.fix h_wf buchberger_step_fn s' := by
          --   -- unfold one step of the fix; in the nonempty branch `buchberger_step_fn s _` is exactly s'
          --   rw [WellFounded.fix_eq]
          --   dsimp [buchberger_step_fn]
          --   -- the body reduces to `dif_neg h_new_s_empty` which yields `rec_call ⟨s.val ∪ new_s, _⟩`,
          --   -- and `rec_call` is `(fun y _ => WellFounded.fix h_wf buchberger_step_fn y)`, so this is `fix s'`.
          --   rw [if_neg h_new_s_empty]
          -- have : P s' := ih s' h_decreasing_s'
          -- unfold P at this
          -- rw [←h_fix_eq] at this
          -- convert this
          -- rw [dif_neg h_new_s_empty]
          -- exact id (Eq.symm h_fix_eq)
          -- simp only [ne_eq, dite_eq_ite]






          -- let s' : State := ⟨s.val ∪ new_s, by sorry⟩ -- proof s' is zero-free
          -- have h_decreasing : R s' s := by sorry -- the decreasing proof

          -- -- The goal is `P(fix s')`, which is what the induction hypothesis `ih` gives us.
          -- -- `ih s' h_decreasing` is a proof of `P s'`.
          -- exact ih s' h_decreasing
  --     have h_P_G_sub := h_wf.induction G_sub h_induction_step
  --     dsimp [P] at h_P_G_sub


  --     have h_fixed_point_property := WellFounded.fix_eq h_wf buchberger_step_fn G_sub
  --     dsimp [buchberger_step_fn] at h_fixed_point_property
  --     rw [if_neg h_new_ne_empty] at h_fixed_point_property

  --     sorry



  --   by_contra h_rem_ne_zero

  --   -- If the remainder is non-zero, it would be in `new`.
  --   have h_rem_in_new : normalForm m hG_nonzero (S_polynomial m p q) ∈ new := by
  --     dsimp [new]
  --     apply Finset.mem_filter.mpr
  --     constructor
  --     · simp only [mem_image, mem_offDiag]
  --       use ⟨p, q⟩
  --     · exact h_rem_ne_zero

  --   rw [h_new_is_empty] at h_rem_in_new
  --   exact Finset.notMem_empty _ h_rem_in_new

  -- exact ⟨h_F_sub_G, h_G_is_GB⟩





--   let F' := buchberger_step m hF
--   if h_stable : F' = F then
--     F
--   else
--     -- If the set grew, we must prove the new set is zero-free and recurse.
--     have hF' : ∀ f ∈ F', f ≠ 0 := buchberger_step_is_zero_free m hF
--     buchberger_Alg hF'

-- -- The termination argument is identical to the previous versions.
--   termination_by
--   WellFounded.wrap
--     (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
--     (Ideal.span ((fun f => m.leadingTerm f) '' (F : Set (MvPolynomial σ k))))
--   decreasing_by

--     simp only [gt_iff_lt, Subtype.coe_lt_coe]
--     apply lt_of_le_of_ne
--     · -- 1) Monotonicity: ⟨LT(F)⟩ ≤ ⟨LT(F ∪ {r})⟩.
--       apply Ideal.span_mono
--       intro t ht
--       rcases ht with ⟨f, hfF, rfl⟩
--       simp only [Set.mem_image, mem_coe]
--       exact ⟨f, (buchberger_step_sup m hF) hfF, rfl⟩
--     · intro h_eq
--       obtain ⟨pq, -, hr_ne_zero, hF'_eq⟩ := buchberger_step_witness m hF h_stable
--       let r := normalForm m hF (S_polynomial m pq.1 pq.2)
--       have hLT_r_notin : m.leadingTerm r ∉ Ideal.span ((fun f ↦ m.leadingTerm f) '' ↑F) :=
--         leadingTerm_normalForm_not_mem_ideal_span_leadingTerm F hF (S_polynomial m pq.1 pq.2) hr_ne_zero
--       have h_eq' : Ideal.span ((fun f ↦ m.leadingTerm f) '' (F : Set _)) =
--             Ideal.span ((fun f ↦ m.leadingTerm f) '' (F' : Set (MvPolynomial σ k))) := by
--         injection h_eq
--       have hLT_r_in : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' (↑F)) := by
--         rw [h_eq']
--         apply Ideal.subset_span
--         simp only [Set.mem_image, mem_coe]
--         use r
--         constructor
--         · unfold F' r; rw [hF'_eq]
--           refine mem_union_right F ?_
--           exact mem_singleton.mpr rfl
--         · rfl
--       exact hLT_r_notin hLT_r_in

-- variable (m) [DecidableEq σ] in
-- noncomputable def buchberger_alg₀ [Finite σ] {G : Finset (MvPolynomial σ k)} (hG : ∀ g ∈ G, g ≠ 0) :
--     Finset (MvPolynomial σ k) :=
--   -- let C (G : Finset (MvPolynomial σ k)) := Finset (MvPolynomial σ k)

--   let R (G₁ G₂ : Finset (MvPolynomial σ k)) : Prop :=
--     Ideal.span (G₁.image (leadingTerm m)) > @Ideal.span (MvPolynomial σ k) _ (G₂.image (leadingTerm m))

--   have hwf : WellFounded R :=
--     InvImage.wf (fun G : Finset (MvPolynomial σ k) => @Ideal.span (MvPolynomial σ k) _ (G.image (leadingTerm m)))
--     (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))

--   @WellFounded.fix (MvPolynomial σ k) (C := fun G => ∀ hG : ∀ g ∈ G, g ≠ 0, Finset (MvPolynomial σ k)) R hwf
--     (λ G rec =>
--       let G' := buchberger_step m hG
--       if h_stable : F' = F then F
--       else
--         have hF' : ∀ f ∈ F', f ≠ 0 := buchberger_step_is_zero_free m hF
--         F) F

-- variable (m) [DecidableEq σ] in
-- lemma buchberger_alg_is_zero_free [Finite σ]
--   {F : Finset (MvPolynomial σ k)}
--   (hF : ∀ f ∈ F, f ≠ 0) :
--   ∀ f ∈ buchberger_alg m hF, f ≠ 0 := by
--   let Rem_index := {pq ∈ F.offDiag | normalForm m hF (S_polynomial m pq.1 pq.2) ≠ 0}
--   let F' := buchberger_step m hF
--   by_cases h_stable : F' = F
--   · unfold buchberger_alg
--     intro f hf_in_F
--     simp only [dite_eq_ite] at hf_in_F
--     rw [if_pos h_stable] at hf_in_F
--     exact hF f hf_in_F

--   let R (F₁ F₂ : Finset (MvPolynomial σ k)) : Prop :=
--     Ideal.span (F₁.image (leadingTerm m)) > @Ideal.span (MvPolynomial σ k) _ (F₂.image (leadingTerm m))

--   have hwf : WellFounded R :=
--     InvImage.wf (fun G : Finset (MvPolynomial σ k) => @Ideal.span (MvPolynomial σ k) _ (G.image (leadingTerm m)))
--     (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))

--   -- theorem WellFounded.induction {α : Sort u} {r : α → α → Prop} (hwf : WellFounded r) {C : α → Prop}
--   -- (a : α) (h : ∀ (x : α), (∀ (y : α), r y x → C y) → C x) : C a

--   let C (F : Finset (MvPolynomial σ k)) : Prop := ∀ f ∈ F, f ≠ 0
--   let P (F_ : Finset (MvPolynomial σ k)) : Prop :=
--     ∀ (hF_ : ∀ f ∈ F_, f ≠ 0), ∀ g ∈ buchberger_alg m hF_, g ≠ 0
--   have h_ind_step : ∀ F_ind, (∀ F_smaller, R F_smaller F_ind → P F_smaller) → P F_ind := by sorry

--   have H : ( ∀ (G : Finset (MvPolynomial σ k)), (∀ (G' : Finset (MvPolynomial σ k)), R G' G → C G') → C G) := by
--     rintro G IH
--     unfold R at IH
--     have := C G'
--     let G' := buchberger_step m hG
--     specialize IH G'
--     by_cases h_stable : G' = G
--     · unfold buchberger_alg at hg_mem
--       dsimp at hg_mem
--       rw [if_pos h_stable] at hg_mem
--       exact hG g hg_mem

--     have hle : Ideal.span (G.image (leadingTerm m)) ≤ @Ideal.span (MvPolynomial σ k) _ (G'.image (leadingTerm m)) := by
--       apply Ideal.span_mono
--       simp only [coe_image]
--       apply Set.image_mono
--       simp only [coe_subset]
--       unfold G'
--       exact buchberger_step_sup m hG

--     sorry

--   apply WellFounded.induction hwf (buchberger_alg m hF) H
--   -- proof finished
--   -- have := WellFounded.induction hwf F H
--   -- unfold C at this
--   -- exact (this hF)

-- lemma buchberger_alg_nonzero [Finite σ] [DecidableEq σ]
--   (F : Finset (MvPolynomial σ k))
--   (hF : ∀ f ∈ F, f ≠ 0) :
--   ∀ g ∈ buchberger_alg m hF, g ≠ 0 := by
--   -- unfold the well-founded recursion
--   unfold buchberger_alg
--   rw [WellFounded.fix_eq]

--   intro F hF IH g hg
--   -- two cases: no new S-polynomials vs. added one
--   by_cases h_empty : buchberger_step m hF = ∅
--   · -- then buchberger_alg just returns F
--     rw [buchberger_alg.eq_of_empty m hF h_empty] at hg
--     exact hF g hg
--   · -- otherwise we added some new r
--     obtain ⟨pq, hpq⟩ := exists_mem_of_ne_empty (by simpa using h_empty)
--     let r := normalForm m hF (S_polynomial m pq.1 pq.2)
--     have hr_ne : r ≠ 0 := by
--       -- because we filtered only nonzero remainders
--       simp at hpq
--       exact hpq
--     rw [buchberger_alg.eq_of_step m hF h_empty] at hg
--     simp at hg
--     rcases hg with (hgF | hgr)
--     · -- case g ∈ F
--       exact hF g hgF
--     · -- case g = r
--       simp [hg, hr_ne]

-- variable [DecidableEq σ] [Finite σ] in
-- theorem buchberger_alg_produces_groebner_basis (I : Ideal (MvPolynomial σ k))
--   (F : Finset (MvPolynomial σ k))
--   (hF : ∀ f ∈ F, f ≠ 0)
--   (hFI : I = Ideal.span F) :
--   IsGroebnerBasis m I (buchberger_alg m hF) := by
--   let G := (buchberger_alg m hF)
--   have hG : ∀ g ∈ G, g ≠ 0 := by
--     intro h hg_mem
--     unfold G buchberger_alg at hg_mem

--   have hGI : I = Ideal.span G := by sorry
--   apply (Buchberger_criterion m hG hGI).mpr
--   show ∀ (g₁ g₂ : MvPolynomial σ k), g₁ ∈ G → g₂ ∈ G → g₁ ≠ g₂ → normalForm m hG (S_polynomial m g₁ g₂) = 0
--   sorry


  -- theorem Buchberger_criterion
  --   {I : Ideal (MvPolynomial σ k)}
  --   {G : Finset (MvPolynomial σ k)}
  --   (hG : ∀ g ∈ G, g ≠ 0)
  --   (hGI : I = Ideal.span G) :
  --   IsGroebnerBasis m I G ↔
  --     (∀ (g₁ g₂ : MvPolynomial σ k),
  --       g₁ ∈ G →
  --       g₂ ∈ G →
  --       g₁ ≠ g₂ → normalForm m hG (S_polynomial m g₁ g₂) = 0)

    -- unfold IsGroebnerBasis
    -- constructor
    -- · intro g hg
    --   have h_zero_free_invariant : ∀ (F' : Finset (MvPolynomial σ k)) (hF' : ∀ f ∈ F', f ≠ 0),
    --     ∀ g ∈ buchberger_alg m hF', g ≠ 0 := by
    --     intro F' hF'
    --     -- theorem WellFounded.induction {α : Sort u} {r : α → α → Prop} (hwf : WellFounded r) {C : α → Prop}
    --     -- (a : α) (h : ∀ (x : α), (∀ (y : α), r y x → C y) → C x) : C a

    --     sorry
    -- · constructor
    --   · have h_subset_invariant :
    --       ∀ (F' : Finset (MvPolynomial σ k)) (hF' : ∀ f ∈ F', f ≠ 0) (h_span_sub : Ideal.span F' ≤ I),
    --       ↑(buchberger_alg m hF') ⊆ I.setLike := by
    --       intro F' hF' h_span_sub

    --       dsimp [buchberger_alg]
    --       let F_next := buchberger_step m hF'
    --       by_cases h_stable : F_next = F'
    --       · rw [if_pos h_stable]; exact Ideal.subset_span_iff.mpr h_span_sub
    --       · rw [if_neg h_stable]
    --         -- By induction, `↑(buchberger_alg m F_next ...) ⊆ I`.
    --         have h_dec := sorry -- decreasing
    --         specialize ih F_next h_dec
    --         have hF_next_zero_free := buchberger_step_is_zero_free m hF'
    --         -- We need to show the span is preserved for the next step.
    --         have h_span_next_sub : Ideal.span F_next ⊆ I := by
    --           rw [span_step_preserved m hF']; exact h_span_sub
    --         exact ih hF_next_zero_free h_span_next_sub
    --   · show Ideal.span ↑(image (fun g ↦ m.leadingTerm g) (buchberger_alg m hF)) = m.initialIdeal I
    --     sorry

-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------




variable (m) [DecidableEq σ] in
noncomputable def buchberger_aux [Finite σ]
  {F : Finset (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0)
  : Finset (MvPolynomial σ k) :=
    -- 1. Create the set of pairs from the current basis G.
    let pairs := F.offDiag

    -- 2. Compute the non-zero remainders of all S-polynomials.
    let R := (pairs.image (fun pq => normalForm m hF (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

    -- 3. Check the termination condition: UNTIL G = G'.
    -- This is equivalent to checking if we found any new polynomials.
    if hR_empty : R = ∅ then
      -- If R is empty, no new polynomials were added. The basis is stable.
      F
    else
      -- 4. G := G ∪ {r}. We add all new non-zero remainders.
      let F' := F ∪ R

      -- We must prove that the new basis G' is also zero-free to make the recursive call.
      have hF' : ∀ f ∈ F', f ≠ 0 := by
        intro f hf_in_F'
        rw [Finset.mem_union] at hf_in_F'
        cases hf_in_F' with
        | inl hf_in_F => exact hF f hf_in_F -- It was non-zero in the old G.
        | inr hr_in_R =>
          -- It's in R, which is defined as the result of a filter for non-zero polynomials.
          -- So by definition, it's not zero.
          exact (Finset.mem_filter.mp hr_in_R).2

      -- 5. REPEAT: Make the recursive call with the new, larger basis.
      buchberger_aux hF'
  termination_by
  WellFounded.wrap
    (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
    (Ideal.span ((fun f => m.leadingTerm f) '' (F : Set (MvPolynomial σ k))))
  decreasing_by
    simp only [coe_union, gt_iff_lt, Subtype.coe_lt_coe]
    classical
      -- 1) Monotonicity: ⟨LT(G)⟩ ≤ ⟨LT(G ∪ R)⟩.
      have hsubset :
        ((fun f => m.leadingTerm f) '' (F : Set (MvPolynomial σ k)))
          ⊆ ((fun f => m.leadingTerm f) '' ((F ∪ R : Finset _) : Set (MvPolynomial σ k))) := by
        intro t ht
        rcases ht with ⟨f, hfF, rfl⟩
        simp only [coe_union, Set.mem_image, Set.mem_union, mem_coe]
        exact ⟨f, by
          have : (f ∈ (F : Set _)) := hfF
          exact Or.inl this, rfl⟩
      have hle :
        Ideal.span ((fun f => m.leadingTerm f) '' (F : Set _))
          ≤ Ideal.span ((fun f => m.leadingTerm f) '' ((F ∪ R : Set (MvPolynomial σ k)) : Set _)) := by
          rw [←Finset.coe_union]
          exact Ideal.span_mono hsubset

      -- 2) Strictness: pick r ∈ R with LT(r) ∉ ⟨LT(G)⟩, but of course LT(r) ∈ ⟨LT(G ∪ R)⟩.
      obtain ⟨r, hrR⟩ : ∃ r, r ∈ R := by
        classical
        refine Nonempty.exists_mem ?_
        exact nonempty_iff_ne_empty.mpr hR_empty
      have hlt_r_notin :
      m.leadingTerm r ∉ Ideal.span ((fun f => m.leadingTerm f) '' (F : Set _)) := by
      -- apply lemma with `p := S_polynomial m p q`
        unfold R at hrR
        simp only [Finset.mem_filter, Finset.mem_image] at hrR
        obtain ⟨pq, -, hr_eq_normalForm⟩ := hrR.1
        rw [←hr_eq_normalForm]
        apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
        rw [hr_eq_normalForm]
        exact hrR.2
      apply lt_of_le_of_ne hle
      intro h_ideals_eq
      have h_lt_r_in_old_ideal : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' ↑F) := by
        rw [h_ideals_eq]
        apply Ideal.subset_span
        simp only [Set.mem_image, ←coe_union]
        use r
        exact ⟨mem_union_right F hrR, rfl⟩
      exact hlt_r_notin h_lt_r_in_old_ideal

variable [DecidableEq σ] in
/-- The `R` constructed at the call `buchberger_aux m F hF` lives in `Ideal.span F`. -/
private lemma step_remainders_mem_span
  (m : MonomialOrder σ) {F : Finset (MvPolynomial σ k)}
  (hF : ∀ f ∈ F, f ≠ 0) :
  ∀ r ∈ ((F.offDiag).image (fun pq => normalForm m hF (S_polynomial m pq.1 pq.2))).filter (· ≠ 0),
    r ∈ Ideal.span (F : Set (MvPolynomial σ k)) := by

  intro r hr
  -- Unpack the definition of the set of remainders.
  rcases Finset.mem_filter.mp hr with ⟨hr_in_image, hr_ne_zero⟩
  rcases Finset.mem_image.mp hr_in_image with ⟨pq, hpq_in_offDiag, hr_eq_normalForm⟩
  rcases Finset.mem_offDiag.mp hpq_in_offDiag with ⟨hp_in_F, hq_in_F, hpq_ne⟩

  -- We now have `r = normalForm m hF (S_polynomial m pq.1 pq.2)`.
  -- Let `S` be the S-polynomial.
  let S := S_polynomial m pq.1 pq.2
  let q := quotients m hF S
  let q_sum := q.sum (fun (g : ↥F) (h : MvPolynomial σ k) => h * g.val)

  -- The division algorithm gives us `S = (linear_combination) + r`.
  have h_repr := (normalForm_spec' m hF S).1
  have h_r_eq_sub : r = S - q_sum := by
    have : S = q_sum + r := by
      rw [h_repr]
      unfold q_sum q quotients
      congr
    exact eq_sub_of_add_eq' (id (Eq.symm this))
  rw [h_r_eq_sub]
  apply Ideal.sub_mem

  · -- First goal: `S ∈ Ideal.span F`.
    -- This proof is correct from your previous attempt.
    unfold S S_polynomial
    let I := Ideal.span (F : Set (MvPolynomial σ k))
    have hp_in_I : pq.1 ∈ I := Ideal.subset_span hp_in_F
    have hq_in_I : pq.2 ∈ I := Ideal.subset_span hq_in_F
    exact Ideal.sub_mem _ (Ideal.mul_mem_left _ _ hp_in_I) (Ideal.mul_mem_left _ _ hq_in_I)

  · -- Second goal: `q_sum ∈ Ideal.span F`.
    -- `q_sum` is `∑ (quotient g) * g`.
    -- Each `g` is in `F`, so each term `(quotient g) * g` is in `Ideal.span F`.
    -- The sum of elements in an ideal is also in the ideal.
    unfold q_sum q
    rw [Finsupp.sum]
    apply sum_mem
    intro f_sub hf_in_supp
    -- `g_sub` is `⟨g, hg_in_F⟩`. We need `(quotient * g) ∈ Ideal.span F`.
    apply Ideal.mul_mem_left
    exact Ideal.subset_span f_sub.property

-- variable (m) [DecidableEq σ] in
-- lemma buchberger_aux_superset₀ [Finite σ]
-- {F : Finset (MvPolynomial σ k)}
-- (hF : ∀ f ∈ F, f ≠ 0) :
-- F ⊆ buchberger_aux m hF := by
-- unfold buchberger_aux
-- let R := {x ∈ image (fun pq ↦ normalForm m hF (S_polynomial m pq.1 pq.2)) F.offDiag | ¬x = 0}
-- by_cases hR_empty : R = ∅
-- · -- base case: R = ∅
--   dsimp only [ne_eq, Lean.Elab.WF.paramLet, dite_eq_ite]
--   rw [if_pos hR_empty]
-- · -- recursive case: R ≠ ∅
--   dsimp only [ne_eq, Lean.Elab.WF.paramLet, dite_eq_ite]
--   rw [if_neg hR_empty]
--   intro f hf
--   -- Step 1: F ⊆ F ∪ R
--   have incl₁ : F ⊆ F ∪ R := fun g hg ↦ Finset.mem_union_left _ hg

--   have incl₂ := buchberger_aux_superset₀ (by
--     intro g hg
--     rcases Finset.mem_union.mp hg with hgF | hgR
--     · exact hF g hgF
--     · unfold R at hgR
--       simp only [ne_eq, mem_filter, mem_image, mem_offDiag, Prod.exists] at hgR
--       exact hgR.2
--   )
--   exact incl₂ (incl₁ hf)
-- termination_by
-- WellFounded.wrap
--   (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k)))
--   (Ideal.span ((fun f => m.leadingTerm f) '' (F : Set (MvPolynomial σ k))))
-- decreasing_by
--   simp only [coe_union, gt_iff_lt, Subtype.coe_lt_coe]
--   classical
--     -- 1) Monotonicity: ⟨LT(G)⟩ ≤ ⟨LT(G ∪ R)⟩.
--     have hsubset :
--       ((fun f => m.leadingTerm f) '' (F : Set (MvPolynomial σ k)))
--         ⊆ ((fun f => m.leadingTerm f) '' ((F ∪ R : Finset _) : Set (MvPolynomial σ k))) := by
--       intro t ht
--       rcases ht with ⟨f, hfF, rfl⟩
--       simp only [coe_union, Set.mem_image, Set.mem_union, mem_coe]
--       exact ⟨f, by
--         have : (f ∈ (F : Set _)) := hfF
--         exact Or.inl this, rfl⟩
--     have hle :
--       Ideal.span ((fun f => m.leadingTerm f) '' (F : Set _))
--         ≤ Ideal.span ((fun f => m.leadingTerm f) '' ((F ∪ R : Set (MvPolynomial σ k)) : Set _)) := by
--         rw [←Finset.coe_union]
--         exact Ideal.span_mono hsubset

--     -- 2) Strictness: pick r ∈ R with LT(r) ∉ ⟨LT(G)⟩, but of course LT(r) ∈ ⟨LT(G ∪ R)⟩.
--     obtain ⟨r, hrR⟩ : ∃ r, r ∈ R := by
--       classical
--       refine Nonempty.exists_mem ?_
--       exact nonempty_iff_ne_empty.mpr hR_empty
--     have hlt_r_notin :
--     m.leadingTerm r ∉ Ideal.span ((fun f => m.leadingTerm f) '' (F : Set _)) := by
--     -- apply lemma with `p := S_polynomial m p q`
--       unfold R at hrR
--       simp only [Finset.mem_filter, Finset.mem_image] at hrR
--       obtain ⟨pq, -, hr_eq_normalForm⟩ := hrR.1
--       rw [←hr_eq_normalForm]
--       apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
--       rw [hr_eq_normalForm]
--       exact hrR.2
--     apply lt_of_le_of_ne hle
--     intro h_ideals_eq
--     have h_lt_r_in_old_ideal : m.leadingTerm r ∈ Ideal.span ((fun f ↦ m.leadingTerm f) '' ↑F) := by
--       rw [h_ideals_eq]
--       apply Ideal.subset_span
--       simp only [Set.mem_image, ←coe_union]
--       use r
--       exact ⟨mem_union_right F hrR, rfl⟩
--     exact hlt_r_notin h_lt_r_in_old_ideal


-- variable [DecidableEq σ] [Finite σ] in
-- /-- Adding the current batch of remainders does not change the ideal. -/
-- private lemma span_preserved
--   (m : MonomialOrder σ) {F : Finset (MvPolynomial σ k)}
--   (hF : ∀ f ∈ F, f ≠ 0) :
--   Ideal.span ((buchberger_aux m hF)) = Ideal.span (F : Set (MvPolynomial σ k)) := by
--   let R := {x ∈ image (fun pq ↦ normalForm m hF (S_polynomial m pq.1 pq.2)) F.offDiag | ¬x = 0}
--   apply le_antisymm
--   · sorry
--   · apply Ideal.span_mono
--     unfold buchberger_aux
--     dsimp
--     by_cases hR_empty : R = ∅
--     · simp only [coe_subset]
--       rw [if_pos hR_empty]
--     · simp only [coe_subset]
--       rw [if_neg hR_empty]
--       have := buchberger_aux_superset₀ m hF
--       unfold buchberger_aux at this
--       dsimp at this
--       rw [if_neg hR_empty] at this
--       exact this




--   -- Let `P G` be the property we want to prove.
--   let P (G : Finset (MvPolynomial σ k)) : Prop :=
--     ∀ (hG : ∀ g ∈ G, g ≠ 0), Ideal.span (buchberger_aux m G hG) = @Ideal.span (MvPolynomial σ k) _ G



--   -- We need to define the well-founded relation.
--   let R (G₁ G₂ : Finset (MvPolynomial σ k)) : Prop :=
--     Ideal.span (G₂.image (leadingTerm m)) < @Ideal.span (MvPolynomial σ k) _ (G₁.image (leadingTerm m))



--   -- Now we use `WellFounded.induction`. It requires us to prove the induction step.
--   -- `h : ∀ x, (∀ y, r y x → P y) → P x`
--   -- We will prove this `h` and then apply it to our initial `F`.
--   have h_induction_step : ∀ (G : Finset (MvPolynomial σ k)), (∀ (y : Finset _), R y G → P y) → P G := by
--     -- Let G be an arbitrary finset, and `ih` be the induction hypothesis.
--     intro G ih
--     -- Now we must prove `P G`, which is `∀ hG, ...`.
--     intro hG

--     -- Unfold one step of `buchberger_aux` to analyze its behavior.
--     dsimp [buchberger_aux]
--     let R_step := (G.offDiag.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

--     -- We split the proof into the two cases of the `if` statement in the algorithm.
--     by_cases hR_empty : R_step = ∅

--     · -- Case 1: The algorithm terminates. `buchberger_aux` returns `G`.
--       rw [if_pos hR_empty]
--       -- The goal is `Ideal.span G = Ideal.span G`, which is true.
--       rfl

--     · -- Case 2: The algorithm recurses. `buchberger_aux` returns `buchberger_aux m (G ∪ R_step) ...`.
--       rw [if_neg hR_empty]

--       -- Let `G' := G ∪ R_step`.
--       let G' := G ∪ R_step
--       have hG' : ∀ g ∈ G', g ≠ 0 := by
--         intro g hg; rw [Finset.mem_union] at hg; cases hg
--         · exact hG g (by assumption)
--         · exact (Finset.mem_filter.mp (by assumption)).2

--       -- We can apply the induction hypothesis `ih` to `G'`.
--       -- To do so, we must prove that `G'` is "smaller" than `G`, i.e., `R G' G`.
--       have h_decreasing : R G' G := by
--         -- This is the full `decreasing_by` proof.
--         apply lt_of_le_of_ne
--         · apply Ideal.span_mono; apply Set.image_subset_image; exact Finset.subset_union_left G R_step
--         · intro h_ideals_eq
--           obtain ⟨r, hrR⟩ := Finset.nonempty_iff_ne_empty.mpr hR_empty
--           have hlt_r_notin : m.leadingTerm r ∉ Ideal.span (G.image (leadingTerm m)) := by
--             -- This is the proof using `leadingTerm_normalForm_not_mem_ideal_span_leadingTerm`.
--             sorry
--           have hlt_r_in_new : m.leadingTerm r ∈ Ideal.span (G'.image (leadingTerm m)) := by
--             apply Ideal.subset_span; apply Finset.mem_image_of_mem; exact Finset.mem_union_right _ hrR
--           rw [h_ideals_eq] at hlt_r_in_new
--           exact hlt_r_notin hlt_r_in_new

--       -- Now we can apply the induction hypothesis.
--       -- `ih G' h_decreasing` gives us a proof of `P G'`.
--       specialize ih G' h_decreasing

--       -- `ih` is now `∀ (hG' : ...), Ideal.span (buchberger_aux m G' hG') = Ideal.span G'`.
--       -- Let's apply it to our specific `hG'`.
--       specialize ih hG'

--       -- `ih` is now `Ideal.span (buchberger_aux m G' hG') = Ideal.span G'`.
--       -- Our goal is `Ideal.span (buchberger_aux m G' hG') = Ideal.span G`.
--       -- We can rewrite the LHS using `ih`.
--       rw [ih]

--       -- The goal becomes `Ideal.span G' = Ideal.span G`.
--       -- This is exactly what `span_step_preserved` proves.
--       exact span_step_preserved m hG

--   -- Now that we have the induction step, we can apply it to our initial `F`.
--   apply h_induction_step F
--   -- The final proof obligation is that the property holds for `F`.
--   exact hF

-- variable [DecidableEq σ] [Finite σ] in
-- /-- The ideal generated by the basis is a loop invariant for the algorithm. -/
-- private lemma span_preserved'
--   (m : MonomialOrder σ) {F : Finset (MvPolynomial σ k)}
--   (hF : ∀ f ∈ F, f ≠ 0) :
--   Ideal.span (buchberger_aux m F hF) = Ideal.span (F : Set (MvPolynomial σ k)) := by

--   -- We prove this by induction, following the recursion of `buchberger_aux`.
--   -- We must use the same termination metric.
--   let H (G : Finset (MvPolynomial σ k)) := @Ideal.span (MvPolynomial σ k) _ (G.image (leadingTerm m))

--   -- We prove a stronger statement: for any intermediate basis G, the property holds.
--   have h_induction : ∀ (G : Finset (MvPolynomial σ k)) (hG : ∀ g ∈ G, g ≠ 0),
--       Ideal.span (buchberger_aux m G hG) = @Ideal.span (MvPolynomial σ k) _ G := by

--     -- Use well-founded induction on the ideal of leading terms.
--     intro G hG
--     apply WellFounded.induction (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k))) _ _

--     intro G ih -- `ih` is the induction hypothesis for all `G'` smaller than `G`.

--     -- Unfold one step of `buchberger_aux`.
--     dsimp [buchberger_aux]
--     let R := (G.offDiag.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)

--     -- Split into the two cases of the `if` statement.
--     by_cases hR_empty : R = ∅

--     · -- Case 1: Base case (termination).
--       -- `buchberger_aux m G hG` returns `G`.
--       rw [if_pos hR_empty]
--       -- The goal is `Ideal.span G = Ideal.span G`, which is true.
--       rfl

--     · -- Case 2: Inductive step (recursion).
--       -- `buchberger_aux m G hG` returns `buchberger_aux m (G ∪ R) hG'`.
--       rw [if_neg hR_empty]

--       -- Let `G' := G ∪ R`.
--       let G' := G ∪ R
--       have hG' : ∀ g ∈ G', g ≠ 0 := sorry -- This proof is standard.

--       -- We must show that the termination metric has decreased to use `ih`.
--       have h_decreasing : H G' < H G := by
--         -- This is the full `decreasing_by` proof we've already established.
--         sorry

--       -- Now, we can apply the induction hypothesis `ih` to `G'`.
--       specialize ih G' h_decreasing

--       -- `ih` is now a proof of `Ideal.span (buchberger_aux m G' hG') = Ideal.span G'`.
--       -- Our goal is `Ideal.span (buchberger_aux m G' hG') = Ideal.span G`.
--       -- So we can rewrite the LHS using `ih`.
--       rw [ih]

--       -- The goal becomes `Ideal.span G' = Ideal.span G`.
--       -- This is exactly what `span_step_preserved` proves.
--       exact span_step_preserved m hG

--   -- Now, apply the proven general statement to our specific initial basis `F`.
--   exact h_induction F hF


-- variable [DecidableEq σ] [Finite σ] in
-- theorem buchberger_aux_produces_groebner_basis (I : Ideal (MvPolynomial σ k))
--   (F : Finset (MvPolynomial σ k))
--   (hF : ∀ f ∈ F, f ≠ 0)
--   (hFI : I = Ideal.span F) :
--   IsGroebnerBasis m I (buchberger_aux m F hF) := by
--   -- have : (buchberger_aux m F hF)
--   let G' := (buchberger_aux m F hF)
--   let pairs := F.offDiag
--   let R := {x ∈ image (fun pq ↦ normalForm m hF (S_polynomial m pq.1 pq.2)) pairs | x ≠ 0}
--   let G := G' ∪ R

--   have hG' : ∀ g ∈ G', g ≠ 0 := by
--     unfold G' buchberger_aux
--     dsimp only [Lean.Elab.WF.paramLet, dite_eq_ite]
--     by_cases hR_empty : R = ∅
--     · rw [if_pos hR_empty]
--       exact hF
--     · rw [if_neg hR_empty]
--       have hIG' : I = Ideal.span G' := by
--         rw [hFI]
--         unfold G' buchberger_aux
--         apply (span_preserved m hF).symm

--     sorry
--   have hG'I : I = Ideal.span G' := by
--     unfold G' buchberger_aux
--     dsimp only [Lean.Elab.WF.paramLet, dite_eq_ite]
--     sorry
--   apply (Buchberger_criterion m hG' hG'I).mpr
--   sorry

--   -- We prove a stronger statement by induction, using the same termination metric
--   -- as the function itself.
--   let H (G : Finset (MvPolynomial σ k)) := @Ideal.span (MvPolynomial σ k) _ (G.image (leadingTerm m))
--   -- apply WellFounded.induction (IsNoetherian.wf (MvPolynomial.isNoetherianRing : IsNoetherian (MvPolynomial σ k) (MvPolynomial σ k))) (Ideal.span F.toSet) _

--   -- The property (motive) we will prove by induction.
--   have h_induction : ∀ (G : Finset (MvPolynomial σ k)) (hG : ∀ g ∈ G, g ≠ 0) (hIG : I = Ideal.span G),
--       IsGroebnerBasis m I (buchberger_aux m G hG) := by

--     -- We use well-founded induction on the ideal of leading terms.
--     -- The relation is `H G' < H G`, which is well-founded.
--     intro G hG hIG
--     -- The induction hypothesis `ih` is available for any `G'` where `H G' < H G`.

--     -- Unfold one step of the `buchberger_aux` definition to analyze its behavior.
--     unfold IsGroebnerBasis
--     let R := (G.offDiag.image (fun pq => normalForm m hG (S_polynomial m pq.1 pq.2))).filter (· ≠ 0)
--     constructor
--     · show ∀ g ∈ buchberger_aux m G hG, g ≠ 0
--       intro g hg_in_buchberger_aux
--       unfold buchberger_aux at hg_in_buchberger_aux
--       simp only [dite_eq_ite] at hg_in_buchberger_aux
--       by_cases hR_empty : R = ∅
--       · -- Case 1: R is empty, the algorithm terminates.
--         rw [if_pos hR_empty] at hg_in_buchberger_aux
--         exact hG g hg_in_buchberger_aux
--       · -- Case 2: R is not empty, the algorithm recurses.
--         rw [if_neg hR_empty] at hg_in_buchberger_aux
--         let G' := G ∪ R
--         -- have hG' : ∀ g ∈ G', g ≠ 0 := by
--         --   intro g hg_in_G'
--         --   rw [Finset.mem_union] at hg_in_G'
--         --   sorry
--         have hIG' : I = Ideal.span G' := by
--           rw [hIG]
--           unfold G' R
--           have : Ideal.span (↑G ∪ ↑({x ∈ image (fun pq ↦ normalForm m hG (S_polynomial m pq.1 pq.2)) G.offDiag | x ≠ 0}))
--             = @Ideal.span (MvPolynomial σ k) _ ↑(G ∪ {x ∈ image (fun pq ↦ normalForm m hG (S_polynomial m pq.1 pq.2)) G.offDiag | x ≠ 0}) := by
--             congr
--             simp only [ne_eq, coe_filter, mem_image, mem_offDiag, Prod.exists, coe_union]
--           rw [←this]
--           apply (span_preserved m hG).symm

--         sorry


--     · constructor
--       · -- show ↑(buchberger_aux m G hG) ⊆ ↑I
--         dsimp [buchberger_aux]

--         by_cases hR_empty : R = ∅
--         · -- Case 1: Terminates. Output is `G`.
--           unfold buchberger_aux
--           simp only [ne_eq, dite_eq_ite]
--           rw [if_pos hR_empty]
--           -- Goal is `↑G ⊆ ↑I`. We know `Ideal.span G = I`.
--           -- `Ideal.subset_span` is `↑G ⊆ Ideal.span G`.
--           rw [hIG]; exact Ideal.subset_span
--         · -- Case 2: Recurses. Output is `buchberger_aux m (G ∪ R) hG'`.
--           unfold buchberger_aux
--           simp only [ne_eq, dite_eq_ite]
--           rw [if_neg hR_empty]
--           sorry

--       · show Ideal.span ↑(image (fun g ↦ m.leadingTerm g) (buchberger_aux m G hG)) = m.initialIdeal I
--         sorry

--   exact h_induction F hF hIF






  -- decreasing_by
  --   simp only [ne_eq, coe_union, coe_filter, mem_image, mem_offDiag, Prod.exists, gt_iff_lt,
  --     Subtype.coe_lt_coe]
  --   classical
  --   by_cases hG : ∀ g ∈ G, g ≠ 0
  --   · -- 1) Monotonicity: ⟨LT(G)⟩ ≤ ⟨LT(G ∪ R)⟩.
  --     have hsubset :
  --       ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k)))
  --         ⊆ ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set (MvPolynomial σ k))) := by
  --       intro t ht
  --       rcases ht with ⟨g, hgG, rfl⟩
  --       simp only [coe_union, Set.mem_image, Set.mem_union, mem_coe]
  --       exact ⟨g, by
  --         have : (g ∈ (G : Set _)) := hgG
  --         exact Or.inl this, rfl⟩
  --     have hle :
  --       Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _))
  --         ≤ Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Set (MvPolynomial σ k)) : Set _)) := by
  --         rw [←Finset.coe_union]
  --         exact Ideal.span_mono hsubset

  --     -- 2) Strictness: pick r ∈ R with LT(r) ∉ ⟨LT(G)⟩, but of course LT(r) ∈ ⟨LT(G ∪ R)⟩.
  --     obtain ⟨r, hrR⟩ : ∃ r, r ∈ R := by
  --       classical
  --       refine Nonempty.exists_mem ?_
  --       exact nonempty_iff_ne_empty.mpr hR_empty
  --     have hlt_r_notin :
  --     m.leadingTerm r ∉ Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) := by sorry
  --     -- apply lemma with `p := S_polynomial m p q`


  --       obtain ⟨pq, hpq_in_pairs, hr_eq_normalForm⟩ := hrR.1
  --       rw [←hr_eq_normalForm]
  --       apply leadingTerm_normalForm_not_mem_ideal_span_leadingTerm
  --       rw [hr_eq_normalForm]
  --       exact hrR.2
  --     sorry
  --     apply lt_of_le_of_ne hle
  --     intro h_ideals_eq
  --     have h_lt_r_in_old_ideal : m.leadingTerm r ∈ Ideal.span ((fun g ↦ m.leadingTerm g) '' ↑G) := by
  --       rw [h_ideals_eq]
  --       apply Ideal.subset_span
  --       simp only [Set.mem_image, ←coe_union]
  --       use r
  --       exact ⟨mem_union_right G hrR, rfl⟩
  --     exact hlt_r_notin h_lt_r_in_old_ideal
  --   · have : (buchberger_step_old m G) = ∅ := by dsimp [buchberger_step_old]; rw [dif_neg hG]


---------------------------------------------------------------------------------------

/-- One Buchberger pass: for an existing finite set `G`, compute all S-pairs,
reduce them by `G`, and adjoin the *nonzero* remainders. -/
noncomputable def buchbergerStep (G : Finset (MvPolynomial σ k)) :
    Finset (MvPolynomial σ k) := by
  classical
  -- Zeros in `G` are irrelevant for reduction; remove them to build the witness `hG`.
  let G' : Finset (MvPolynomial σ k) := G.filter (· ≠ 0)
  have hG' : ∀ g ∈ G', g ≠ 0 := by
    intro g hg
    rcases Finset.mem_filter.mp hg with ⟨_, hg0⟩; exact hg0
  -- All ordered distinct pairs (p,q) with p,q ∈ G'.
  let pairs := G'.offDiag           -- : Finset (MvPolynomial σ k × MvPolynomial σ k)
  -- Remainders of S-polynomials modulo the *current* reducers `G'`.
  let rems := pairs.image (fun pq => normalForm (m:=m) hG' (S_polynomial (m:=m) pq.1 pq.2))
  -- Keep only the nonzero ones; these are the new candidates to adjoin.
  exact rems.filter (· ≠ 0)

-- /-- The invariant: `span` is monotone and stays inside `I` if it started inside. -/
-- lemma span_mono (I : Ideal (MvPolynomial σ k)) (G : Finset (MvPolynomial σ k))
--   (hF : G.toSet ⊆ I) :
--   Ideal.span (buchbergerStep (m:=m) G : Set _) ≤ I := by
--   classical
--   -- Show every new remainder is in `I` using the textbook argument:
--   -- `S(p,q)` is in `I` and dividing by `G ⊆ I` keeps the remainder in `I`.
--   -- Then `span` of the union stays in `I`.
--   sorry

-- /-- If the step adds a new nonzero remainder, the initial ideal strictly gets
-- smaller (the leading term of the new remainder is not divisible by any leading
-- term in the old set). This is the key (1) in the book. -/
-- lemma lt_on_initialIdeal
--   {G : Finset (MvPolynomial σ k)}
--   (hAdd : buchbergerStep (m:=m) G ≠ G) :
--   m.initialIdeal (Ideal.span (buchbergerStep (m:=m) G : Set _))
--     < m.initialIdeal (Ideal.span (G : Set (MvPolynomial σ k))) := by
--   classical
--   -- Expand `hAdd` to extract a specific `r ≠ 0` that was adjoined.
--   -- Use your lemma "LT(r) ∈ ⟨LT(G ∪ {r})⟩ \ ⟨LT(G)⟩" (CLoS Lemma 2 of §4) to get strictness.
--   sorry

-- /-- Stabilization iff all S-pairs reduce to 0. -/
-- lemma stop_iff_all_Spair_reduce
--   {G : Finset (MvPolynomial σ k)}
--   : buchbergerStep (m:=m) G = G ↔
--     (∀ g₁ g₂ ∈ G, g₁ ≠ g₂ →
--       normalForm (m:=m) (by intro g hg; exact by decide) (S_polynomial g₁ g₂) = 0) := by
--   classical
--   -- Unfold `buchbergerStep`; the only way it equals `G` is if there is no nonzero
--   -- remainder among all S-pairs, i.e. all reduce to 0.
--   sorry

-- /-- Well-foundedness on initial ideals yields termination. -/
-- lemma terminates :
--   WellFounded (fun G₁ G₂ : Finset (MvPolynomial σ k) =>
--     initialIdeal (Ideal.span (G₁ : Set _)) < initialIdeal (Ideal.span (G₂ : Set _))) := by
--   classical
--   -- Use that `MvPolynomial σ k` is Noetherian → ACC on ideals → ACC on their images
--   -- under `initialIdeal` (monotone). Then pull back to the well-founded relation.
--   have inst : IsNoetherianRing (MvPolynomial σ k) := by
--     -- from mathlib (Hilbert basis theorem for mv-polynomials).
--     exact inferInstance
--   -- Convert ACC on ideals to `WellFounded` of `<`.
--   -- Use `Ideal.isWellFounded_lt` if available, or build from `IsNoetherian`.
--   sorry

-- /-- The actual recursive algorithm: repeatedly apply `buchbergerStep` until the
-- initial ideal stops decreasing; correctness + termination are proved below. -/
-- noncomputable def buchberger :
--     Finset (MvPolynomial σ k) := by
--   classical
--   -- Use well-founded recursion on the measure `initialIdeal (span G)`.
--   refine
--     (terminates (m:=m) (initialIdeal:=initialIdeal)).fix
--       (C := fun _ => Finset (MvPolynomial σ k))
--       (f := fun G rec =>
--         if h : buchbergerStep (m:=m) G = G then G else rec _ ?hrel) ?start
--   · -- relation proof when the step makes progress
--     intro G h
--     have hlt := lt_on_initialIdeal (m:=m) (initialIdeal:=initialIdeal) (G:=G) (by
--       -- `h` is negation of equality, so step adds something
--       have : buchbergerStep (m:=m) G ≠ G := by exact by exact fun heq => by cases h ▸ rfl
--       exact this)
--     exact hlt
--   · -- start from the given input `F`; you’ll pass it as an argument at use-site
--     exact (∅ : Finset (MvPolynomial σ k))

-- /-- Correctness: the output is a Gröbner basis of the ideal generated by the input.
-- This mirrors the textbook proof: invariants + `stop_iff_all_Spair_reduce` +
-- Buchberger criterion. -/
-- lemma buchberger_spec (F : Finset (MvPolynomial σ k))
--   (I : Ideal (MvPolynomial σ k)) (hFI : (F : Set _) ⊆ I) (hI : I ≠ ⊥ := by decide)
--   (hG0 : ∀ g ∈ F, g ≠ 0 := by intro; decide)
--   :
--   let G := buchberger (m:=m) (initialIdeal:=initialIdeal)
--   in IsGroebnerBasis m I G ∧ Ideal.span (G : Set _) = I := by
--   classical
--   -- 1) `span_mono` keeps `span G ⊆ I`; combined with `F ⊆ G` gives `span G = I`.
--   -- 2) By construction of `buchberger`, the loop ends exactly when
--   --    `buchbergerStep G = G`.
--   -- 3) Apply `stop_iff_all_Spair_reduce` + Buchberger criterion equivalence.
--   -- Fill in rewrites with your existing API lemmas.
--   sorry

-- end BuchbergerAlgorithm

-- /-- ### Helper: characterize membership in `buchbergerStep` when `G` has no zeros. -/
-- lemma mem_buchbergerStep_iff
--   (m : MonomialOrder σ) {G : Finset (MvPolynomial σ k)} (hG : ∀ g ∈ G, g ≠ 0)
--   {r : MvPolynomial σ k} :
--   r ∈ buchbergerStep (m:=m) G ↔
--     ∃ p q, p ∈ G ∧ q ∈ G ∧ p ≠ q ∧ r = normalForm (m:=m) hG (S_polynomial (m:=m) p q) ∧ r ≠ 0 := by
--   classical
--   unfold buchbergerStep
--   -- only the `if hG` branch remains
--   simp [hG, Finset.mem_filter, Finset.mem_image, Finset.mem_offDiag,
--         and_left_comm, and_assoc, exists_prop, Prod.exists, eq_comm]

-- /-- A cleaned-up version of the recursive helper with a `decreasing_by` that closes. -/
-- noncomputable def buchberger_aux_fixed [Finite σ] (m : MonomialOrder σ)
--   (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
--     let R := buchbergerStep (m:=m) G
--     if hR : R = ∅ then G else buchberger_aux_fixed m (G ∪ R)
--   termination_by WellFounded.wrap (IsNoetherian.wf _) (Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)))
--   decreasing_by
--     classical
--     -- expose the recursive branch and grab `hRne : R ≠ ∅`
--     simp [buchberger_aux_fixed]  -- introduces `hRne : buchbergerStep m G ≠ ∅`
--     set R := buchbergerStep (m:=m) G with hRdef
--     have hRne : R ≠ ∅ := by simpa [hRdef] using hRne

--     -- (i) monotonicity of span
--     have hsubset :
--       ((fun g => m.leadingTerm g) '' (G : Set (MvPolynomial σ k))) ⊆
--       ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set (MvPolynomial σ k))) := by
--       intro t ht; rcases ht with ⟨g, hg, rfl⟩; exact ⟨g, Or.inl hg, rfl⟩
--     have hle :
--       Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) ≤
--       Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set _)) :=
--       Ideal.span_mono (by simpa [← Finset.coe_union])

--     -- (ii) strictness via a witness from `R`
--     obtain ⟨r, hrR⟩ := Finset.exists_mem_of_ne_empty hRne

--     -- show that `¬ (∀ g ∈ G, g ≠ 0)` would force `R = ∅` (contradiction), so we have `hG`.
--     have hG : ∀ g ∈ G, g ≠ 0 := by
--       unfold buchbergerStep at hRdef
--       by_cases h : ∀ g ∈ G, g ≠ 0
--       · exact h
--       · simp [h] at hRdef; exact (hRne (by simpa [hRdef]))

--     -- shape of `r`
--     rcases (mem_buchbergerStep_iff (σ:=σ) (k:=k) (m:=m) hG).1 (by simpa [hRdef] using hrR) with
--       ⟨p, q, hpG, hqG, hpq, hr, hr0⟩

--     -- LT(r) is outside `⟨LT(G)⟩` by your NF lemma
--     have hLT_notin :
--       m.leadingTerm r ∉ Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) := by
--       have := leadingTerm_normalForm_not_mem_ideal_span_leadingTerm (m:=m) G hG (S_polynomial (m:=m) p q) (by simpa [hr])
--       simpa [hr] using this

--     -- but in the larger span
--     have hLT_in :
--       m.leadingTerm r ∈ Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set _)) := by
--       apply Ideal.subset_span
--       exact ⟨r, Or.inr (by simpa [Finset.mem_coe, hRdef] using hrR), rfl⟩

--     -- hence spans are unequal
--     have hne :
--       Ideal.span ((fun g => m.leadingTerm g) '' (G : Set _)) ≠
--       Ideal.span ((fun g => m.leadingTerm g) '' ((G ∪ R : Finset _) : Set _)) := by
--       intro heq; exact hLT_notin (heq ▸ hLT_in)

--     -- combine ≤ and ≠ to get `<` on the wrapped order
--     exact lt_of_le_of_ne hle hne






-- ---------------------------------------------------------------------------------------










-- variable [DecidableEq σ] in
-- noncomputable def buchberger (F : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
--   buchberger_aux m (F.filter (· ≠ 0))


--   -- The algorithm starts with G := F.
--   -- We must first filter out any zeros from the initial set, as our algorithm requires it.
--   buchberger_aux (F.filter (· ≠ 0))

-- variable [DecidableEq σ] in
-- /--
-- Buchberger's algorithm: Given a finite generating set `F` for a polynomial ideal `I`,
-- constructs a Gröbner basis for `I`.
-- -/
-- partial def buchberger'
--     (F : Finset (MvPolynomial σ k))
--     (terminate : (Finset (MvPolynomial σ k)) → Bool := fun _ ↦ false) :
--     Finset (MvPolynomial σ k) :=
--   let rec loop (G : Finset (MvPolynomial σ k)) : Finset (MvPolynomial σ k) :=
--     let pairs := (G.product G).filter (fun ⟨p, q⟩ ↦ p ≠ q)
--     let G' := G
--     let newElems :=
--       pairs.foldl (fun acc ⟨p, q⟩ =>
--         let r := (SPolynomial p q).reduceWith G'
--         if r ≠ 0 then acc ∪ {r} else acc
--       ) ∅
--     let Gnext := G ∪ newElems
--     if Gnext = G then G else loop Gnext
--   loop F

-- variable [DecidableEq σ] in
-- /--
-- **Buchberger's theorem**:
-- If `I = ⟨F⟩` is a nonzero polynomial ideal, then `buchberger F`
-- terminates in finitely many steps and returns a Gröbner basis of `I`.
-- -/
-- theorem Buchberger_Algorithm
--     (F : Finset (MvPolynomial σ k)) :
--     ∃ G, F ⊆ G ∧ IsGroebnerBasis m (Ideal.span F) G := by sorry

-- variable [DecidableEq σ] in
-- lemma grobner_basis_remove_redundant
--   {I : Ideal _} {G : Finset _} {p : MvPolynomial σ k}
--   (hG : IsGroebnerBasis m I G)
--   (hpG : p ∈ G)
--   (hLT : leadingTerm m p ∈ Ideal.span ((G.erase p).image (fun g ↦ leadingTerm m g))) :
--   IsGroebnerBasis m I (G.erase p) := by sorry

-- def countdown (n : Nat) : List Nat :=
--   match n with
--   | 0 => []
--   | n' + 1 => n' :: countdown n'

-- def countdown' (n : Nat) : List Nat :=
--   if n == 0 then []
--   else
--     let n' := n - 1
--     n' :: countdown' n'

-- def countdown'' (n : Nat) : List Nat :=
--   if n = 0 then []
--   else
--     let n' := n - 1
--     n' :: countdown' n'
